{
  "version": 3,
  "sources": ["../../mux.js/es/utils/stream.js", "../../mux.js/es/utils/clock.js", "../../mux.js/es/codecs/adts.js", "../../mux.js/es/utils/exp-golomb.js", "../../mux.js/es/codecs/h264.js", "../../mux.js/es/codecs/index.js", "../../mux.js/es/mp4/mp4-generator.js", "../../mux.js/es/utils/bin.js", "../../mux.js/es/mp4/parse-type.js", "../../mux.js/es/mp4/find-box.js", "../../mux.js/es/tools/parse-tfhd.js", "../../mux.js/es/tools/parse-sample-flags.js", "../../mux.js/es/tools/parse-trun.js", "../../mux.js/es/tools/parse-tfdt.js", "../../mux.js/es/mp4/probe.js", "../../mux.js/es/mp4/frame-utils.js", "../../mux.js/es/data/silence.js", "../../mux.js/es/mp4/audio-frame-utils.js", "../../mux.js/es/mp4/track-decode-info.js", "../../mux.js/es/tools/caption-packet-parser.js", "../../mux.js/es/m2ts/caption-stream.js", "../../mux.js/es/m2ts/stream-types.js", "../../mux.js/es/m2ts/timestamp-rollover-stream.js", "../../mux.js/es/m2ts/metadata-stream.js", "../../mux.js/es/m2ts/m2ts.js", "../../mux.js/es/aac/utils.js", "../../mux.js/es/aac/index.js", "../../mux.js/es/constants/audio-properties.js", "../../mux.js/es/constants/video-properties.js", "../../mux.js/es/mp4/transmuxer.js", "../../mux.js/es/mp4/caption-parser.js", "../../mux.js/es/mp4/index.js", "../../mux.js/es/flv/flv-tag.js", "../../mux.js/es/flv/coalesce-stream.js", "../../mux.js/es/flv/tag-list.js", "../../mux.js/es/flv/transmuxer.js", "../../mux.js/es/flv/flv-header.js", "../../mux.js/es/flv/index.js", "../../mux.js/es/m2ts/index.js", "../../mux.js/es/partial/audio-segment-stream.js", "../../mux.js/es/partial/video-segment-stream.js", "../../mux.js/es/partial/transmuxer.js", "../../mux.js/es/partial/index.js", "../../mux.js/es/tools/parse-sidx.js", "../../mux.js/es/tools/mp4-inspector.js", "../../mux.js/es/tools/flv-inspector.js", "../../mux.js/es/m2ts/probe.js", "../../mux.js/es/tools/ts-inspector.js", "../../mux.js/es/index.js"],
  "sourcesContent": ["/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * A lightweight readable stream implemention that handles event dispatching.\n * Objects that inherit from streams should call init in their constructors.\n */\n'use strict';\n\nvar Stream = function Stream() {\n  this.init = function () {\n    var listeners = {};\n    /**\n     * Add a listener for a specified event type.\n     * @param type {string} the event name\n     * @param listener {function} the callback to be invoked when an event of\n     * the specified type occurs\n     */\n\n    this.on = function (type, listener) {\n      if (!listeners[type]) {\n        listeners[type] = [];\n      }\n\n      listeners[type] = listeners[type].concat(listener);\n    };\n    /**\n     * Remove a listener for a specified event type.\n     * @param type {string} the event name\n     * @param listener {function} a function previously registered for this\n     * type of event through `on`\n     */\n\n\n    this.off = function (type, listener) {\n      var index;\n\n      if (!listeners[type]) {\n        return false;\n      }\n\n      index = listeners[type].indexOf(listener);\n      listeners[type] = listeners[type].slice();\n      listeners[type].splice(index, 1);\n      return index > -1;\n    };\n    /**\n     * Trigger an event of the specified type on this stream. Any additional\n     * arguments to this function are passed as parameters to event listeners.\n     * @param type {string} the event name\n     */\n\n\n    this.trigger = function (type) {\n      var callbacks, i, length, args;\n      callbacks = listeners[type];\n\n      if (!callbacks) {\n        return;\n      } // Slicing the arguments on every invocation of this method\n      // can add a significant amount of overhead. Avoid the\n      // intermediate object creation for the common case of a\n      // single callback argument\n\n\n      if (arguments.length === 2) {\n        length = callbacks.length;\n\n        for (i = 0; i < length; ++i) {\n          callbacks[i].call(this, arguments[1]);\n        }\n      } else {\n        args = [];\n        i = arguments.length;\n\n        for (i = 1; i < arguments.length; ++i) {\n          args.push(arguments[i]);\n        }\n\n        length = callbacks.length;\n\n        for (i = 0; i < length; ++i) {\n          callbacks[i].apply(this, args);\n        }\n      }\n    };\n    /**\n     * Destroys the stream and cleans up.\n     */\n\n\n    this.dispose = function () {\n      listeners = {};\n    };\n  };\n};\n/**\n * Forwards all `data` events on this stream to the destination stream. The\n * destination stream should provide a method `push` to receive the data\n * events as they arrive.\n * @param destination {stream} the stream that will receive all `data` events\n * @param autoFlush {boolean} if false, we will not call `flush` on the destination\n *                            when the current stream emits a 'done' event\n * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n */\n\n\nStream.prototype.pipe = function (destination) {\n  this.on('data', function (data) {\n    destination.push(data);\n  });\n  this.on('done', function (flushSource) {\n    destination.flush(flushSource);\n  });\n  this.on('partialdone', function (flushSource) {\n    destination.partialFlush(flushSource);\n  });\n  this.on('endedtimeline', function (flushSource) {\n    destination.endTimeline(flushSource);\n  });\n  this.on('reset', function (flushSource) {\n    destination.reset(flushSource);\n  });\n  return destination;\n}; // Default stream functions that are expected to be overridden to perform\n// actual work. These are provided by the prototype as a sort of no-op\n// implementation so that we don't have to check for their existence in the\n// `pipe` function above.\n\n\nStream.prototype.push = function (data) {\n  this.trigger('data', data);\n};\n\nStream.prototype.flush = function (flushSource) {\n  this.trigger('done', flushSource);\n};\n\nStream.prototype.partialFlush = function (flushSource) {\n  this.trigger('partialdone', flushSource);\n};\n\nStream.prototype.endTimeline = function (flushSource) {\n  this.trigger('endedtimeline', flushSource);\n};\n\nStream.prototype.reset = function (flushSource) {\n  this.trigger('reset', flushSource);\n};\n\nmodule.exports = Stream;", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\nvar ONE_SECOND_IN_TS = 90000,\n    // 90kHz clock\nsecondsToVideoTs,\n    secondsToAudioTs,\n    videoTsToSeconds,\n    audioTsToSeconds,\n    audioTsToVideoTs,\n    videoTsToAudioTs,\n    metadataTsToSeconds;\n\nsecondsToVideoTs = function secondsToVideoTs(seconds) {\n  return seconds * ONE_SECOND_IN_TS;\n};\n\nsecondsToAudioTs = function secondsToAudioTs(seconds, sampleRate) {\n  return seconds * sampleRate;\n};\n\nvideoTsToSeconds = function videoTsToSeconds(timestamp) {\n  return timestamp / ONE_SECOND_IN_TS;\n};\n\naudioTsToSeconds = function audioTsToSeconds(timestamp, sampleRate) {\n  return timestamp / sampleRate;\n};\n\naudioTsToVideoTs = function audioTsToVideoTs(timestamp, sampleRate) {\n  return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\n};\n\nvideoTsToAudioTs = function videoTsToAudioTs(timestamp, sampleRate) {\n  return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\n};\n/**\n * Adjust ID3 tag or caption timing information by the timeline pts values\n * (if keepOriginalTimestamps is false) and convert to seconds\n */\n\n\nmetadataTsToSeconds = function metadataTsToSeconds(timestamp, timelineStartPts, keepOriginalTimestamps) {\n  return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);\n};\n\nmodule.exports = {\n  ONE_SECOND_IN_TS: ONE_SECOND_IN_TS,\n  secondsToVideoTs: secondsToVideoTs,\n  secondsToAudioTs: secondsToAudioTs,\n  videoTsToSeconds: videoTsToSeconds,\n  audioTsToSeconds: audioTsToSeconds,\n  audioTsToVideoTs: audioTsToVideoTs,\n  videoTsToAudioTs: videoTsToAudioTs,\n  metadataTsToSeconds: metadataTsToSeconds\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js');\n\nvar ONE_SECOND_IN_TS = require('../utils/clock').ONE_SECOND_IN_TS;\n\nvar _AdtsStream;\n\nvar ADTS_SAMPLING_FREQUENCIES = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n/*\n * Accepts a ElementaryStream and emits data events with parsed\n * AAC Audio Frames of the individual packets. Input audio in ADTS\n * format is unpacked and re-emitted as AAC frames.\n *\n * @see http://wiki.multimedia.cx/index.php?title=ADTS\n * @see http://wiki.multimedia.cx/?title=Understanding_AAC\n */\n\n_AdtsStream = function AdtsStream(handlePartialSegments) {\n  var buffer,\n      frameNum = 0;\n\n  _AdtsStream.prototype.init.call(this);\n\n  this.skipWarn_ = function (start, end) {\n    this.trigger('log', {\n      level: 'warn',\n      message: \"adts skiping bytes \" + start + \" to \" + end + \" in frame \" + frameNum + \" outside syncword\"\n    });\n  };\n\n  this.push = function (packet) {\n    var i = 0,\n        frameLength,\n        protectionSkipBytes,\n        frameEnd,\n        oldBuffer,\n        sampleCount,\n        adtsFrameDuration;\n\n    if (!handlePartialSegments) {\n      frameNum = 0;\n    }\n\n    if (packet.type !== 'audio') {\n      // ignore non-audio data\n      return;\n    } // Prepend any data in the buffer to the input data so that we can parse\n    // aac frames the cross a PES packet boundary\n\n\n    if (buffer && buffer.length) {\n      oldBuffer = buffer;\n      buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);\n      buffer.set(oldBuffer);\n      buffer.set(packet.data, oldBuffer.byteLength);\n    } else {\n      buffer = packet.data;\n    } // unpack any ADTS frames which have been fully received\n    // for details on the ADTS header, see http://wiki.multimedia.cx/index.php?title=ADTS\n\n\n    var skip; // We use i + 7 here because we want to be able to parse the entire header.\n    // If we don't have enough bytes to do that, then we definitely won't have a full frame.\n\n    while (i + 7 < buffer.length) {\n      // Look for the start of an ADTS header..\n      if (buffer[i] !== 0xFF || (buffer[i + 1] & 0xF6) !== 0xF0) {\n        if (typeof skip !== 'number') {\n          skip = i;\n        } // If a valid header was not found,  jump one forward and attempt to\n        // find a valid ADTS header starting at the next byte\n\n\n        i++;\n        continue;\n      }\n\n      if (typeof skip === 'number') {\n        this.skipWarn_(skip, i);\n        skip = null;\n      } // The protection skip bit tells us if we have 2 bytes of CRC data at the\n      // end of the ADTS header\n\n\n      protectionSkipBytes = (~buffer[i + 1] & 0x01) * 2; // Frame length is a 13 bit integer starting 16 bits from the\n      // end of the sync sequence\n      // NOTE: frame length includes the size of the header\n\n      frameLength = (buffer[i + 3] & 0x03) << 11 | buffer[i + 4] << 3 | (buffer[i + 5] & 0xe0) >> 5;\n      sampleCount = ((buffer[i + 6] & 0x03) + 1) * 1024;\n      adtsFrameDuration = sampleCount * ONE_SECOND_IN_TS / ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2]; // If we don't have enough data to actually finish this ADTS frame,\n      // then we have to wait for more data\n\n      if (buffer.byteLength - i < frameLength) {\n        break;\n      } // Otherwise, deliver the complete AAC frame\n\n\n      this.trigger('data', {\n        pts: packet.pts + frameNum * adtsFrameDuration,\n        dts: packet.dts + frameNum * adtsFrameDuration,\n        sampleCount: sampleCount,\n        audioobjecttype: (buffer[i + 2] >>> 6 & 0x03) + 1,\n        channelcount: (buffer[i + 2] & 1) << 2 | (buffer[i + 3] & 0xc0) >>> 6,\n        samplerate: ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2],\n        samplingfrequencyindex: (buffer[i + 2] & 0x3c) >>> 2,\n        // assume ISO/IEC 14496-12 AudioSampleEntry default of 16\n        samplesize: 16,\n        // data is the frame without it's header\n        data: buffer.subarray(i + 7 + protectionSkipBytes, i + frameLength)\n      });\n      frameNum++;\n      i += frameLength;\n    }\n\n    if (typeof skip === 'number') {\n      this.skipWarn_(skip, i);\n      skip = null;\n    } // remove processed bytes from the buffer.\n\n\n    buffer = buffer.subarray(i);\n  };\n\n  this.flush = function () {\n    frameNum = 0;\n    this.trigger('done');\n  };\n\n  this.reset = function () {\n    buffer = void 0;\n    this.trigger('reset');\n  };\n\n  this.endTimeline = function () {\n    buffer = void 0;\n    this.trigger('endedtimeline');\n  };\n};\n\n_AdtsStream.prototype = new Stream();\nmodule.exports = _AdtsStream;", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nvar ExpGolomb;\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding\n * scheme used by h264.\n */\n\nExpGolomb = function ExpGolomb(workingData) {\n  var // the number of bytes left to examine in workingData\n  workingBytesAvailable = workingData.byteLength,\n      // the current word being examined\n  workingWord = 0,\n      // :uint\n  // the number of bits left to examine in the current word\n  workingBitsAvailable = 0; // :uint;\n  // ():uint\n\n  this.length = function () {\n    return 8 * workingBytesAvailable;\n  }; // ():uint\n\n\n  this.bitsAvailable = function () {\n    return 8 * workingBytesAvailable + workingBitsAvailable;\n  }; // ():void\n\n\n  this.loadWord = function () {\n    var position = workingData.byteLength - workingBytesAvailable,\n        workingBytes = new Uint8Array(4),\n        availableBytes = Math.min(4, workingBytesAvailable);\n\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n\n    workingBytes.set(workingData.subarray(position, position + availableBytes));\n    workingWord = new DataView(workingBytes.buffer).getUint32(0); // track the amount of workingData that has been processed\n\n    workingBitsAvailable = availableBytes * 8;\n    workingBytesAvailable -= availableBytes;\n  }; // (count:int):void\n\n\n  this.skipBits = function (count) {\n    var skipBytes; // :int\n\n    if (workingBitsAvailable > count) {\n      workingWord <<= count;\n      workingBitsAvailable -= count;\n    } else {\n      count -= workingBitsAvailable;\n      skipBytes = Math.floor(count / 8);\n      count -= skipBytes * 8;\n      workingBytesAvailable -= skipBytes;\n      this.loadWord();\n      workingWord <<= count;\n      workingBitsAvailable -= count;\n    }\n  }; // (size:int):uint\n\n\n  this.readBits = function (size) {\n    var bits = Math.min(workingBitsAvailable, size),\n        // :uint\n    valu = workingWord >>> 32 - bits; // :uint\n    // if size > 31, handle error\n\n    workingBitsAvailable -= bits;\n\n    if (workingBitsAvailable > 0) {\n      workingWord <<= bits;\n    } else if (workingBytesAvailable > 0) {\n      this.loadWord();\n    }\n\n    bits = size - bits;\n\n    if (bits > 0) {\n      return valu << bits | this.readBits(bits);\n    }\n\n    return valu;\n  }; // ():uint\n\n\n  this.skipLeadingZeros = function () {\n    var leadingZeroCount; // :uint\n\n    for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\n      if ((workingWord & 0x80000000 >>> leadingZeroCount) !== 0) {\n        // the first bit of working word is 1\n        workingWord <<= leadingZeroCount;\n        workingBitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    } // we exhausted workingWord and still have not found a 1\n\n\n    this.loadWord();\n    return leadingZeroCount + this.skipLeadingZeros();\n  }; // ():void\n\n\n  this.skipUnsignedExpGolomb = function () {\n    this.skipBits(1 + this.skipLeadingZeros());\n  }; // ():void\n\n\n  this.skipExpGolomb = function () {\n    this.skipBits(1 + this.skipLeadingZeros());\n  }; // ():uint\n\n\n  this.readUnsignedExpGolomb = function () {\n    var clz = this.skipLeadingZeros(); // :uint\n\n    return this.readBits(clz + 1) - 1;\n  }; // ():int\n\n\n  this.readExpGolomb = function () {\n    var valu = this.readUnsignedExpGolomb(); // :int\n\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n    }\n\n    return -1 * (valu >>> 1); // divide by two then make it negative\n  }; // Some convenience functions\n  // :Boolean\n\n\n  this.readBoolean = function () {\n    return this.readBits(1) === 1;\n  }; // ():int\n\n\n  this.readUnsignedByte = function () {\n    return this.readBits(8);\n  };\n\n  this.loadWord();\n};\n\nmodule.exports = ExpGolomb;", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js');\n\nvar ExpGolomb = require('../utils/exp-golomb.js');\n\nvar _H264Stream, _NalByteStream;\n\nvar PROFILES_WITH_OPTIONAL_SPS_DATA;\n/**\n * Accepts a NAL unit byte stream and unpacks the embedded NAL units.\n */\n\n_NalByteStream = function NalByteStream() {\n  var syncPoint = 0,\n      i,\n      buffer;\n\n  _NalByteStream.prototype.init.call(this);\n  /*\n   * Scans a byte stream and triggers a data event with the NAL units found.\n   * @param {Object} data Event received from H264Stream\n   * @param {Uint8Array} data.data The h264 byte stream to be scanned\n   *\n   * @see H264Stream.push\n   */\n\n\n  this.push = function (data) {\n    var swapBuffer;\n\n    if (!buffer) {\n      buffer = data.data;\n    } else {\n      swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);\n      swapBuffer.set(buffer);\n      swapBuffer.set(data.data, buffer.byteLength);\n      buffer = swapBuffer;\n    }\n\n    var len = buffer.byteLength; // Rec. ITU-T H.264, Annex B\n    // scan for NAL unit boundaries\n    // a match looks like this:\n    // 0 0 1 .. NAL .. 0 0 1\n    // ^ sync point        ^ i\n    // or this:\n    // 0 0 1 .. NAL .. 0 0 0\n    // ^ sync point        ^ i\n    // advance the sync point to a NAL start, if necessary\n\n    for (; syncPoint < len - 3; syncPoint++) {\n      if (buffer[syncPoint + 2] === 1) {\n        // the sync point is properly aligned\n        i = syncPoint + 5;\n        break;\n      }\n    }\n\n    while (i < len) {\n      // look at the current byte to determine if we've hit the end of\n      // a NAL unit boundary\n      switch (buffer[i]) {\n        case 0:\n          // skip past non-sync sequences\n          if (buffer[i - 1] !== 0) {\n            i += 2;\n            break;\n          } else if (buffer[i - 2] !== 0) {\n            i++;\n            break;\n          } // deliver the NAL unit if it isn't empty\n\n\n          if (syncPoint + 3 !== i - 2) {\n            this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n          } // drop trailing zeroes\n\n\n          do {\n            i++;\n          } while (buffer[i] !== 1 && i < len);\n\n          syncPoint = i - 2;\n          i += 3;\n          break;\n\n        case 1:\n          // skip past non-sync sequences\n          if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {\n            i += 3;\n            break;\n          } // deliver the NAL unit\n\n\n          this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n          syncPoint = i - 2;\n          i += 3;\n          break;\n\n        default:\n          // the current byte isn't a one or zero, so it cannot be part\n          // of a sync sequence\n          i += 3;\n          break;\n      }\n    } // filter out the NAL units that were delivered\n\n\n    buffer = buffer.subarray(syncPoint);\n    i -= syncPoint;\n    syncPoint = 0;\n  };\n\n  this.reset = function () {\n    buffer = null;\n    syncPoint = 0;\n    this.trigger('reset');\n  };\n\n  this.flush = function () {\n    // deliver the last buffered NAL unit\n    if (buffer && buffer.byteLength > 3) {\n      this.trigger('data', buffer.subarray(syncPoint + 3));\n    } // reset the stream state\n\n\n    buffer = null;\n    syncPoint = 0;\n    this.trigger('done');\n  };\n\n  this.endTimeline = function () {\n    this.flush();\n    this.trigger('endedtimeline');\n  };\n};\n\n_NalByteStream.prototype = new Stream(); // values of profile_idc that indicate additional fields are included in the SPS\n// see Recommendation ITU-T H.264 (4/2013),\n// 7.3.2.1.1 Sequence parameter set data syntax\n\nPROFILES_WITH_OPTIONAL_SPS_DATA = {\n  100: true,\n  110: true,\n  122: true,\n  244: true,\n  44: true,\n  83: true,\n  86: true,\n  118: true,\n  128: true,\n  // TODO: the three profiles below don't\n  // appear to have sps data in the specificiation anymore?\n  138: true,\n  139: true,\n  134: true\n};\n/**\n * Accepts input from a ElementaryStream and produces H.264 NAL unit data\n * events.\n */\n\n_H264Stream = function H264Stream() {\n  var nalByteStream = new _NalByteStream(),\n      self,\n      trackId,\n      currentPts,\n      currentDts,\n      discardEmulationPreventionBytes,\n      readSequenceParameterSet,\n      skipScalingList;\n\n  _H264Stream.prototype.init.call(this);\n\n  self = this;\n  /*\n   * Pushes a packet from a stream onto the NalByteStream\n   *\n   * @param {Object} packet - A packet received from a stream\n   * @param {Uint8Array} packet.data - The raw bytes of the packet\n   * @param {Number} packet.dts - Decode timestamp of the packet\n   * @param {Number} packet.pts - Presentation timestamp of the packet\n   * @param {Number} packet.trackId - The id of the h264 track this packet came from\n   * @param {('video'|'audio')} packet.type - The type of packet\n   *\n   */\n\n  this.push = function (packet) {\n    if (packet.type !== 'video') {\n      return;\n    }\n\n    trackId = packet.trackId;\n    currentPts = packet.pts;\n    currentDts = packet.dts;\n    nalByteStream.push(packet);\n  };\n  /*\n   * Identify NAL unit types and pass on the NALU, trackId, presentation and decode timestamps\n   * for the NALUs to the next stream component.\n   * Also, preprocess caption and sequence parameter NALUs.\n   *\n   * @param {Uint8Array} data - A NAL unit identified by `NalByteStream.push`\n   * @see NalByteStream.push\n   */\n\n\n  nalByteStream.on('data', function (data) {\n    var event = {\n      trackId: trackId,\n      pts: currentPts,\n      dts: currentDts,\n      data: data,\n      nalUnitTypeCode: data[0] & 0x1f\n    };\n\n    switch (event.nalUnitTypeCode) {\n      case 0x05:\n        event.nalUnitType = 'slice_layer_without_partitioning_rbsp_idr';\n        break;\n\n      case 0x06:\n        event.nalUnitType = 'sei_rbsp';\n        event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n        break;\n\n      case 0x07:\n        event.nalUnitType = 'seq_parameter_set_rbsp';\n        event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n        event.config = readSequenceParameterSet(event.escapedRBSP);\n        break;\n\n      case 0x08:\n        event.nalUnitType = 'pic_parameter_set_rbsp';\n        break;\n\n      case 0x09:\n        event.nalUnitType = 'access_unit_delimiter_rbsp';\n        break;\n\n      default:\n        break;\n    } // This triggers data on the H264Stream\n\n\n    self.trigger('data', event);\n  });\n  nalByteStream.on('done', function () {\n    self.trigger('done');\n  });\n  nalByteStream.on('partialdone', function () {\n    self.trigger('partialdone');\n  });\n  nalByteStream.on('reset', function () {\n    self.trigger('reset');\n  });\n  nalByteStream.on('endedtimeline', function () {\n    self.trigger('endedtimeline');\n  });\n\n  this.flush = function () {\n    nalByteStream.flush();\n  };\n\n  this.partialFlush = function () {\n    nalByteStream.partialFlush();\n  };\n\n  this.reset = function () {\n    nalByteStream.reset();\n  };\n\n  this.endTimeline = function () {\n    nalByteStream.endTimeline();\n  };\n  /**\n   * Advance the ExpGolomb decoder past a scaling list. The scaling\n   * list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count {number} the number of entries in this scaling list\n   * @param expGolombDecoder {object} an ExpGolomb pointed to the\n   * start of a scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */\n\n\n  skipScalingList = function skipScalingList(count, expGolombDecoder) {\n    var lastScale = 8,\n        nextScale = 8,\n        j,\n        deltaScale;\n\n    for (j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = expGolombDecoder.readExpGolomb();\n        nextScale = (lastScale + deltaScale + 256) % 256;\n      }\n\n      lastScale = nextScale === 0 ? lastScale : nextScale;\n    }\n  };\n  /**\n   * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n   * Sequence Payload\"\n   * @param data {Uint8Array} the bytes of a RBSP from a NAL\n   * unit\n   * @return {Uint8Array} the RBSP without any Emulation\n   * Prevention Bytes\n   */\n\n\n  discardEmulationPreventionBytes = function discardEmulationPreventionBytes(data) {\n    var length = data.byteLength,\n        emulationPreventionBytesPositions = [],\n        i = 1,\n        newLength,\n        newData; // Find all `Emulation Prevention Bytes`\n\n    while (i < length - 2) {\n      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n        emulationPreventionBytesPositions.push(i + 2);\n        i += 2;\n      } else {\n        i++;\n      }\n    } // If no Emulation Prevention Bytes were found just return the original\n    // array\n\n\n    if (emulationPreventionBytesPositions.length === 0) {\n      return data;\n    } // Create a new array to hold the NAL unit data\n\n\n    newLength = length - emulationPreventionBytesPositions.length;\n    newData = new Uint8Array(newLength);\n    var sourceIndex = 0;\n\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\n        // Skip this byte\n        sourceIndex++; // Remove this position index\n\n        emulationPreventionBytesPositions.shift();\n      }\n\n      newData[i] = data[sourceIndex];\n    }\n\n    return newData;\n  };\n  /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @param data {Uint8Array} the bytes of a sequence parameter set\n   * @return {object} an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */\n\n\n  readSequenceParameterSet = function readSequenceParameterSet(data) {\n    var frameCropLeftOffset = 0,\n        frameCropRightOffset = 0,\n        frameCropTopOffset = 0,\n        frameCropBottomOffset = 0,\n        sarScale = 1,\n        expGolombDecoder,\n        profileIdc,\n        levelIdc,\n        profileCompatibility,\n        chromaFormatIdc,\n        picOrderCntType,\n        numRefFramesInPicOrderCntCycle,\n        picWidthInMbsMinus1,\n        picHeightInMapUnitsMinus1,\n        frameMbsOnlyFlag,\n        scalingListCount,\n        sarRatio = [1, 1],\n        aspectRatioIdc,\n        i;\n    expGolombDecoder = new ExpGolomb(data);\n    profileIdc = expGolombDecoder.readUnsignedByte(); // profile_idc\n\n    profileCompatibility = expGolombDecoder.readUnsignedByte(); // constraint_set[0-5]_flag\n\n    levelIdc = expGolombDecoder.readUnsignedByte(); // level_idc u(8)\n\n    expGolombDecoder.skipUnsignedExpGolomb(); // seq_parameter_set_id\n    // some profiles have more optional data we don't need\n\n    if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {\n      chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();\n\n      if (chromaFormatIdc === 3) {\n        expGolombDecoder.skipBits(1); // separate_colour_plane_flag\n      }\n\n      expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_luma_minus8\n\n      expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_chroma_minus8\n\n      expGolombDecoder.skipBits(1); // qpprime_y_zero_transform_bypass_flag\n\n      if (expGolombDecoder.readBoolean()) {\n        // seq_scaling_matrix_present_flag\n        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n\n        for (i = 0; i < scalingListCount; i++) {\n          if (expGolombDecoder.readBoolean()) {\n            // seq_scaling_list_present_flag[ i ]\n            if (i < 6) {\n              skipScalingList(16, expGolombDecoder);\n            } else {\n              skipScalingList(64, expGolombDecoder);\n            }\n          }\n        }\n      }\n    }\n\n    expGolombDecoder.skipUnsignedExpGolomb(); // log2_max_frame_num_minus4\n\n    picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();\n\n    if (picOrderCntType === 0) {\n      expGolombDecoder.readUnsignedExpGolomb(); // log2_max_pic_order_cnt_lsb_minus4\n    } else if (picOrderCntType === 1) {\n      expGolombDecoder.skipBits(1); // delta_pic_order_always_zero_flag\n\n      expGolombDecoder.skipExpGolomb(); // offset_for_non_ref_pic\n\n      expGolombDecoder.skipExpGolomb(); // offset_for_top_to_bottom_field\n\n      numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();\n\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        expGolombDecoder.skipExpGolomb(); // offset_for_ref_frame[ i ]\n      }\n    }\n\n    expGolombDecoder.skipUnsignedExpGolomb(); // max_num_ref_frames\n\n    expGolombDecoder.skipBits(1); // gaps_in_frame_num_value_allowed_flag\n\n    picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n    picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n    frameMbsOnlyFlag = expGolombDecoder.readBits(1);\n\n    if (frameMbsOnlyFlag === 0) {\n      expGolombDecoder.skipBits(1); // mb_adaptive_frame_field_flag\n    }\n\n    expGolombDecoder.skipBits(1); // direct_8x8_inference_flag\n\n    if (expGolombDecoder.readBoolean()) {\n      // frame_cropping_flag\n      frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();\n      frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();\n      frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();\n      frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();\n    }\n\n    if (expGolombDecoder.readBoolean()) {\n      // vui_parameters_present_flag\n      if (expGolombDecoder.readBoolean()) {\n        // aspect_ratio_info_present_flag\n        aspectRatioIdc = expGolombDecoder.readUnsignedByte();\n\n        switch (aspectRatioIdc) {\n          case 1:\n            sarRatio = [1, 1];\n            break;\n\n          case 2:\n            sarRatio = [12, 11];\n            break;\n\n          case 3:\n            sarRatio = [10, 11];\n            break;\n\n          case 4:\n            sarRatio = [16, 11];\n            break;\n\n          case 5:\n            sarRatio = [40, 33];\n            break;\n\n          case 6:\n            sarRatio = [24, 11];\n            break;\n\n          case 7:\n            sarRatio = [20, 11];\n            break;\n\n          case 8:\n            sarRatio = [32, 11];\n            break;\n\n          case 9:\n            sarRatio = [80, 33];\n            break;\n\n          case 10:\n            sarRatio = [18, 11];\n            break;\n\n          case 11:\n            sarRatio = [15, 11];\n            break;\n\n          case 12:\n            sarRatio = [64, 33];\n            break;\n\n          case 13:\n            sarRatio = [160, 99];\n            break;\n\n          case 14:\n            sarRatio = [4, 3];\n            break;\n\n          case 15:\n            sarRatio = [3, 2];\n            break;\n\n          case 16:\n            sarRatio = [2, 1];\n            break;\n\n          case 255:\n            {\n              sarRatio = [expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte()];\n              break;\n            }\n        }\n\n        if (sarRatio) {\n          sarScale = sarRatio[0] / sarRatio[1];\n        }\n      }\n    }\n\n    return {\n      profileIdc: profileIdc,\n      levelIdc: levelIdc,\n      profileCompatibility: profileCompatibility,\n      width: (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2,\n      height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2,\n      // sar is sample aspect ratio\n      sarRatio: sarRatio\n    };\n  };\n};\n\n_H264Stream.prototype = new Stream();\nmodule.exports = {\n  H264Stream: _H264Stream,\n  NalByteStream: _NalByteStream\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\nmodule.exports = {\n  Adts: require('./adts'),\n  h264: require('./h264')\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Functions that generate fragmented MP4s suitable for use with Media\n * Source Extensions.\n */\n'use strict';\n\nvar UINT32_MAX = Math.pow(2, 32) - 1;\nvar box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS; // pre-calculate constants\n\n(function () {\n  var i;\n  types = {\n    avc1: [],\n    // codingname\n    avcC: [],\n    btrt: [],\n    dinf: [],\n    dref: [],\n    esds: [],\n    ftyp: [],\n    hdlr: [],\n    mdat: [],\n    mdhd: [],\n    mdia: [],\n    mfhd: [],\n    minf: [],\n    moof: [],\n    moov: [],\n    mp4a: [],\n    // codingname\n    mvex: [],\n    mvhd: [],\n    pasp: [],\n    sdtp: [],\n    smhd: [],\n    stbl: [],\n    stco: [],\n    stsc: [],\n    stsd: [],\n    stsz: [],\n    stts: [],\n    styp: [],\n    tfdt: [],\n    tfhd: [],\n    traf: [],\n    trak: [],\n    trun: [],\n    trex: [],\n    tkhd: [],\n    vmhd: []\n  }; // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\n  // don't throw an error\n\n  if (typeof Uint8Array === 'undefined') {\n    return;\n  }\n\n  for (i in types) {\n    if (types.hasOwnProperty(i)) {\n      types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n    }\n  }\n\n  MAJOR_BRAND = new Uint8Array(['i'.charCodeAt(0), 's'.charCodeAt(0), 'o'.charCodeAt(0), 'm'.charCodeAt(0)]);\n  AVC1_BRAND = new Uint8Array(['a'.charCodeAt(0), 'v'.charCodeAt(0), 'c'.charCodeAt(0), '1'.charCodeAt(0)]);\n  MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\n  VIDEO_HDLR = new Uint8Array([0x00, // version 0\n  0x00, 0x00, 0x00, // flags\n  0x00, 0x00, 0x00, 0x00, // pre_defined\n  0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n  0x00, 0x00, 0x00, 0x00, // reserved\n  0x00, 0x00, 0x00, 0x00, // reserved\n  0x00, 0x00, 0x00, 0x00, // reserved\n  0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n  ]);\n  AUDIO_HDLR = new Uint8Array([0x00, // version 0\n  0x00, 0x00, 0x00, // flags\n  0x00, 0x00, 0x00, 0x00, // pre_defined\n  0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n  0x00, 0x00, 0x00, 0x00, // reserved\n  0x00, 0x00, 0x00, 0x00, // reserved\n  0x00, 0x00, 0x00, 0x00, // reserved\n  0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n  ]);\n  HDLR_TYPES = {\n    video: VIDEO_HDLR,\n    audio: AUDIO_HDLR\n  };\n  DREF = new Uint8Array([0x00, // version 0\n  0x00, 0x00, 0x00, // flags\n  0x00, 0x00, 0x00, 0x01, // entry_count\n  0x00, 0x00, 0x00, 0x0c, // entry_size\n  0x75, 0x72, 0x6c, 0x20, // 'url' type\n  0x00, // version 0\n  0x00, 0x00, 0x01 // entry_flags\n  ]);\n  SMHD = new Uint8Array([0x00, // version\n  0x00, 0x00, 0x00, // flags\n  0x00, 0x00, // balance, 0 means centered\n  0x00, 0x00 // reserved\n  ]);\n  STCO = new Uint8Array([0x00, // version\n  0x00, 0x00, 0x00, // flags\n  0x00, 0x00, 0x00, 0x00 // entry_count\n  ]);\n  STSC = STCO;\n  STSZ = new Uint8Array([0x00, // version\n  0x00, 0x00, 0x00, // flags\n  0x00, 0x00, 0x00, 0x00, // sample_size\n  0x00, 0x00, 0x00, 0x00 // sample_count\n  ]);\n  STTS = STCO;\n  VMHD = new Uint8Array([0x00, // version\n  0x00, 0x00, 0x01, // flags\n  0x00, 0x00, // graphicsmode\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n  ]);\n})();\n\nbox = function box(type) {\n  var payload = [],\n      size = 0,\n      i,\n      result,\n      view;\n\n  for (i = 1; i < arguments.length; i++) {\n    payload.push(arguments[i]);\n  }\n\n  i = payload.length; // calculate the total size we need to allocate\n\n  while (i--) {\n    size += payload[i].byteLength;\n  }\n\n  result = new Uint8Array(size + 8);\n  view = new DataView(result.buffer, result.byteOffset, result.byteLength);\n  view.setUint32(0, result.byteLength);\n  result.set(type, 4); // copy the payload into the result\n\n  for (i = 0, size = 8; i < payload.length; i++) {\n    result.set(payload[i], size);\n    size += payload[i].byteLength;\n  }\n\n  return result;\n};\n\ndinf = function dinf() {\n  return box(types.dinf, box(types.dref, DREF));\n};\n\nesds = function esds(track) {\n  return box(types.esds, new Uint8Array([0x00, // version\n  0x00, 0x00, 0x00, // flags\n  // ES_Descriptor\n  0x03, // tag, ES_DescrTag\n  0x19, // length\n  0x00, 0x00, // ES_ID\n  0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\n  // DecoderConfigDescriptor\n  0x04, // tag, DecoderConfigDescrTag\n  0x11, // length\n  0x40, // object type\n  0x15, // streamType\n  0x00, 0x06, 0x00, // bufferSizeDB\n  0x00, 0x00, 0xda, 0xc0, // maxBitrate\n  0x00, 0x00, 0xda, 0xc0, // avgBitrate\n  // DecoderSpecificInfo\n  0x05, // tag, DecoderSpecificInfoTag\n  0x02, // length\n  // ISO/IEC 14496-3, AudioSpecificConfig\n  // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\n  track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1, track.samplingfrequencyindex << 7 | track.channelcount << 3, 0x06, 0x01, 0x02 // GASpecificConfig\n  ]));\n};\n\nftyp = function ftyp() {\n  return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\n};\n\nhdlr = function hdlr(type) {\n  return box(types.hdlr, HDLR_TYPES[type]);\n};\n\nmdat = function mdat(data) {\n  return box(types.mdat, data);\n};\n\nmdhd = function mdhd(track) {\n  var result = new Uint8Array([0x00, // version 0\n  0x00, 0x00, 0x00, // flags\n  0x00, 0x00, 0x00, 0x02, // creation_time\n  0x00, 0x00, 0x00, 0x03, // modification_time\n  0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n  track.duration >>> 24 & 0xFF, track.duration >>> 16 & 0xFF, track.duration >>> 8 & 0xFF, track.duration & 0xFF, // duration\n  0x55, 0xc4, // 'und' language (undetermined)\n  0x00, 0x00]); // Use the sample rate from the track metadata, when it is\n  // defined. The sample rate can be parsed out of an ADTS header, for\n  // instance.\n\n  if (track.samplerate) {\n    result[12] = track.samplerate >>> 24 & 0xFF;\n    result[13] = track.samplerate >>> 16 & 0xFF;\n    result[14] = track.samplerate >>> 8 & 0xFF;\n    result[15] = track.samplerate & 0xFF;\n  }\n\n  return box(types.mdhd, result);\n};\n\nmdia = function mdia(track) {\n  return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\n};\n\nmfhd = function mfhd(sequenceNumber) {\n  return box(types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags\n  (sequenceNumber & 0xFF000000) >> 24, (sequenceNumber & 0xFF0000) >> 16, (sequenceNumber & 0xFF00) >> 8, sequenceNumber & 0xFF // sequence_number\n  ]));\n};\n\nminf = function minf(track) {\n  return box(types.minf, track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));\n};\n\nmoof = function moof(sequenceNumber, tracks) {\n  var trackFragments = [],\n      i = tracks.length; // build traf boxes for each track fragment\n\n  while (i--) {\n    trackFragments[i] = traf(tracks[i]);\n  }\n\n  return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));\n};\n/**\n * Returns a movie box.\n * @param tracks {array} the tracks associated with this movie\n * @see ISO/IEC 14496-12:2012(E), section 8.2.1\n */\n\n\nmoov = function moov(tracks) {\n  var i = tracks.length,\n      boxes = [];\n\n  while (i--) {\n    boxes[i] = trak(tracks[i]);\n  }\n\n  return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\n};\n\nmvex = function mvex(tracks) {\n  var i = tracks.length,\n      boxes = [];\n\n  while (i--) {\n    boxes[i] = trex(tracks[i]);\n  }\n\n  return box.apply(null, [types.mvex].concat(boxes));\n};\n\nmvhd = function mvhd(duration) {\n  var bytes = new Uint8Array([0x00, // version 0\n  0x00, 0x00, 0x00, // flags\n  0x00, 0x00, 0x00, 0x01, // creation_time\n  0x00, 0x00, 0x00, 0x02, // modification_time\n  0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n  (duration & 0xFF000000) >> 24, (duration & 0xFF0000) >> 16, (duration & 0xFF00) >> 8, duration & 0xFF, // duration\n  0x00, 0x01, 0x00, 0x00, // 1.0 rate\n  0x01, 0x00, // 1.0 volume\n  0x00, 0x00, // reserved\n  0x00, 0x00, 0x00, 0x00, // reserved\n  0x00, 0x00, 0x00, 0x00, // reserved\n  0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n  0xff, 0xff, 0xff, 0xff // next_track_ID\n  ]);\n  return box(types.mvhd, bytes);\n};\n\nsdtp = function sdtp(track) {\n  var samples = track.samples || [],\n      bytes = new Uint8Array(4 + samples.length),\n      flags,\n      i; // leave the full box header (4 bytes) all zero\n  // write the sample table\n\n  for (i = 0; i < samples.length; i++) {\n    flags = samples[i].flags;\n    bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n  }\n\n  return box(types.sdtp, bytes);\n};\n\nstbl = function stbl(track) {\n  return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));\n};\n\n(function () {\n  var videoSample, audioSample;\n\n  stsd = function stsd(track) {\n    return box(types.stsd, new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01]), track.type === 'video' ? videoSample(track) : audioSample(track));\n  };\n\n  videoSample = function videoSample(track) {\n    var sps = track.sps || [],\n        pps = track.pps || [],\n        sequenceParameterSets = [],\n        pictureParameterSets = [],\n        i,\n        avc1Box; // assemble the SPSs\n\n    for (i = 0; i < sps.length; i++) {\n      sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\n      sequenceParameterSets.push(sps[i].byteLength & 0xFF); // sequenceParameterSetLength\n\n      sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\n    } // assemble the PPSs\n\n\n    for (i = 0; i < pps.length; i++) {\n      pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\n      pictureParameterSets.push(pps[i].byteLength & 0xFF);\n      pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\n    }\n\n    avc1Box = [types.avc1, new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, // data_reference_index\n    0x00, 0x00, // pre_defined\n    0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n    (track.width & 0xff00) >> 8, track.width & 0xff, // width\n    (track.height & 0xff00) >> 8, track.height & 0xff, // height\n    0x00, 0x48, 0x00, 0x00, // horizresolution\n    0x00, 0x48, 0x00, 0x00, // vertresolution\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, // frame_count\n    0x13, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x6a, 0x73, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62, 0x2d, 0x68, 0x6c, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname\n    0x00, 0x18, // depth = 24\n    0x11, 0x11 // pre_defined = -1\n    ]), box(types.avcC, new Uint8Array([0x01, // configurationVersion\n    track.profileIdc, // AVCProfileIndication\n    track.profileCompatibility, // profile_compatibility\n    track.levelIdc, // AVCLevelIndication\n    0xff // lengthSizeMinusOne, hard-coded to 4 bytes\n    ].concat([sps.length], // numOfSequenceParameterSets\n    sequenceParameterSets, // \"SPS\"\n    [pps.length], // numOfPictureParameterSets\n    pictureParameterSets // \"PPS\"\n    ))), box(types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n    0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n    0x00, 0x2d, 0xc6, 0xc0 // avgBitrate\n    ]))];\n\n    if (track.sarRatio) {\n      var hSpacing = track.sarRatio[0],\n          vSpacing = track.sarRatio[1];\n      avc1Box.push(box(types.pasp, new Uint8Array([(hSpacing & 0xFF000000) >> 24, (hSpacing & 0xFF0000) >> 16, (hSpacing & 0xFF00) >> 8, hSpacing & 0xFF, (vSpacing & 0xFF000000) >> 24, (vSpacing & 0xFF0000) >> 16, (vSpacing & 0xFF00) >> 8, vSpacing & 0xFF])));\n    }\n\n    return box.apply(null, avc1Box);\n  };\n\n  audioSample = function audioSample(track) {\n    return box(types.mp4a, new Uint8Array([// SampleEntry, ISO/IEC 14496-12\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, // data_reference_index\n    // AudioSampleEntry, ISO/IEC 14496-12\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    (track.channelcount & 0xff00) >> 8, track.channelcount & 0xff, // channelcount\n    (track.samplesize & 0xff00) >> 8, track.samplesize & 0xff, // samplesize\n    0x00, 0x00, // pre_defined\n    0x00, 0x00, // reserved\n    (track.samplerate & 0xff00) >> 8, track.samplerate & 0xff, 0x00, 0x00 // samplerate, 16.16\n    // MP4AudioSampleEntry, ISO/IEC 14496-14\n    ]), esds(track));\n  };\n})();\n\ntkhd = function tkhd(track) {\n  var result = new Uint8Array([0x00, // version 0\n  0x00, 0x00, 0x07, // flags\n  0x00, 0x00, 0x00, 0x00, // creation_time\n  0x00, 0x00, 0x00, 0x00, // modification_time\n  (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\n  0x00, 0x00, 0x00, 0x00, // reserved\n  (track.duration & 0xFF000000) >> 24, (track.duration & 0xFF0000) >> 16, (track.duration & 0xFF00) >> 8, track.duration & 0xFF, // duration\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n  0x00, 0x00, // layer\n  0x00, 0x00, // alternate_group\n  0x01, 0x00, // non-audio track volume\n  0x00, 0x00, // reserved\n  0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n  (track.width & 0xFF00) >> 8, track.width & 0xFF, 0x00, 0x00, // width\n  (track.height & 0xFF00) >> 8, track.height & 0xFF, 0x00, 0x00 // height\n  ]);\n  return box(types.tkhd, result);\n};\n/**\n * Generate a track fragment (traf) box. A traf box collects metadata\n * about tracks in a movie fragment (moof) box.\n */\n\n\ntraf = function traf(track) {\n  var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;\n  trackFragmentHeader = box(types.tfhd, new Uint8Array([0x00, // version 0\n  0x00, 0x00, 0x3a, // flags\n  (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\n  0x00, 0x00, 0x00, 0x01, // sample_description_index\n  0x00, 0x00, 0x00, 0x00, // default_sample_duration\n  0x00, 0x00, 0x00, 0x00, // default_sample_size\n  0x00, 0x00, 0x00, 0x00 // default_sample_flags\n  ]));\n  upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / (UINT32_MAX + 1));\n  lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % (UINT32_MAX + 1));\n  trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([0x01, // version 1\n  0x00, 0x00, 0x00, // flags\n  // baseMediaDecodeTime\n  upperWordBaseMediaDecodeTime >>> 24 & 0xFF, upperWordBaseMediaDecodeTime >>> 16 & 0xFF, upperWordBaseMediaDecodeTime >>> 8 & 0xFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >>> 24 & 0xFF, lowerWordBaseMediaDecodeTime >>> 16 & 0xFF, lowerWordBaseMediaDecodeTime >>> 8 & 0xFF, lowerWordBaseMediaDecodeTime & 0xFF])); // the data offset specifies the number of bytes from the start of\n  // the containing moof to the first payload byte of the associated\n  // mdat\n\n  dataOffset = 32 + // tfhd\n  20 + // tfdt\n  8 + // traf header\n  16 + // mfhd\n  8 + // moof header\n  8; // mdat header\n  // audio tracks require less metadata\n\n  if (track.type === 'audio') {\n    trackFragmentRun = trun(track, dataOffset);\n    return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);\n  } // video tracks should contain an independent and disposable samples\n  // box (sdtp)\n  // generate one and adjust offsets to match\n\n\n  sampleDependencyTable = sdtp(track);\n  trackFragmentRun = trun(track, sampleDependencyTable.length + dataOffset);\n  return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);\n};\n/**\n * Generate a track box.\n * @param track {object} a track definition\n * @return {Uint8Array} the track box\n */\n\n\ntrak = function trak(track) {\n  track.duration = track.duration || 0xffffffff;\n  return box(types.trak, tkhd(track), mdia(track));\n};\n\ntrex = function trex(track) {\n  var result = new Uint8Array([0x00, // version 0\n  0x00, 0x00, 0x00, // flags\n  (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\n  0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n  0x00, 0x00, 0x00, 0x00, // default_sample_duration\n  0x00, 0x00, 0x00, 0x00, // default_sample_size\n  0x00, 0x01, 0x00, 0x01 // default_sample_flags\n  ]); // the last two bytes of default_sample_flags is the sample\n  // degradation priority, a hint about the importance of this sample\n  // relative to others. Lower the degradation priority for all sample\n  // types other than video.\n\n  if (track.type !== 'video') {\n    result[result.length - 1] = 0x00;\n  }\n\n  return box(types.trex, result);\n};\n\n(function () {\n  var audioTrun, videoTrun, trunHeader; // This method assumes all samples are uniform. That is, if a\n  // duration is present for the first sample, it will be present for\n  // all subsequent samples.\n  // see ISO/IEC 14496-12:2012, Section 8.8.8.1\n\n  trunHeader = function trunHeader(samples, offset) {\n    var durationPresent = 0,\n        sizePresent = 0,\n        flagsPresent = 0,\n        compositionTimeOffset = 0; // trun flag constants\n\n    if (samples.length) {\n      if (samples[0].duration !== undefined) {\n        durationPresent = 0x1;\n      }\n\n      if (samples[0].size !== undefined) {\n        sizePresent = 0x2;\n      }\n\n      if (samples[0].flags !== undefined) {\n        flagsPresent = 0x4;\n      }\n\n      if (samples[0].compositionTimeOffset !== undefined) {\n        compositionTimeOffset = 0x8;\n      }\n    }\n\n    return [0x00, // version 0\n    0x00, durationPresent | sizePresent | flagsPresent | compositionTimeOffset, 0x01, // flags\n    (samples.length & 0xFF000000) >>> 24, (samples.length & 0xFF0000) >>> 16, (samples.length & 0xFF00) >>> 8, samples.length & 0xFF, // sample_count\n    (offset & 0xFF000000) >>> 24, (offset & 0xFF0000) >>> 16, (offset & 0xFF00) >>> 8, offset & 0xFF // data_offset\n    ];\n  };\n\n  videoTrun = function videoTrun(track, offset) {\n    var bytesOffest, bytes, header, samples, sample, i;\n    samples = track.samples || [];\n    offset += 8 + 12 + 16 * samples.length;\n    header = trunHeader(samples, offset);\n    bytes = new Uint8Array(header.length + samples.length * 16);\n    bytes.set(header);\n    bytesOffest = header.length;\n\n    for (i = 0; i < samples.length; i++) {\n      sample = samples[i];\n      bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;\n      bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;\n      bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;\n      bytes[bytesOffest++] = sample.duration & 0xFF; // sample_duration\n\n      bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;\n      bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;\n      bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;\n      bytes[bytesOffest++] = sample.size & 0xFF; // sample_size\n\n      bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn;\n      bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample;\n      bytes[bytesOffest++] = sample.flags.degradationPriority & 0xF0 << 8;\n      bytes[bytesOffest++] = sample.flags.degradationPriority & 0x0F; // sample_flags\n\n      bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF000000) >>> 24;\n      bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF0000) >>> 16;\n      bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF00) >>> 8;\n      bytes[bytesOffest++] = sample.compositionTimeOffset & 0xFF; // sample_composition_time_offset\n    }\n\n    return box(types.trun, bytes);\n  };\n\n  audioTrun = function audioTrun(track, offset) {\n    var bytes, bytesOffest, header, samples, sample, i;\n    samples = track.samples || [];\n    offset += 8 + 12 + 8 * samples.length;\n    header = trunHeader(samples, offset);\n    bytes = new Uint8Array(header.length + samples.length * 8);\n    bytes.set(header);\n    bytesOffest = header.length;\n\n    for (i = 0; i < samples.length; i++) {\n      sample = samples[i];\n      bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;\n      bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;\n      bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;\n      bytes[bytesOffest++] = sample.duration & 0xFF; // sample_duration\n\n      bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;\n      bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;\n      bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;\n      bytes[bytesOffest++] = sample.size & 0xFF; // sample_size\n    }\n\n    return box(types.trun, bytes);\n  };\n\n  trun = function trun(track, offset) {\n    if (track.type === 'audio') {\n      return audioTrun(track, offset);\n    }\n\n    return videoTrun(track, offset);\n  };\n})();\n\nmodule.exports = {\n  ftyp: ftyp,\n  mdat: mdat,\n  moof: moof,\n  moov: moov,\n  initSegment: function initSegment(tracks) {\n    var fileType = ftyp(),\n        movie = moov(tracks),\n        result;\n    result = new Uint8Array(fileType.byteLength + movie.byteLength);\n    result.set(fileType);\n    result.set(movie, fileType.byteLength);\n    return result;\n  }\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\nvar toUnsigned = function toUnsigned(value) {\n  return value >>> 0;\n};\n\nvar toHexString = function toHexString(value) {\n  return ('00' + value.toString(16)).slice(-2);\n};\n\nmodule.exports = {\n  toUnsigned: toUnsigned,\n  toHexString: toHexString\n};", "var parseType = function parseType(buffer) {\n  var result = '';\n  result += String.fromCharCode(buffer[0]);\n  result += String.fromCharCode(buffer[1]);\n  result += String.fromCharCode(buffer[2]);\n  result += String.fromCharCode(buffer[3]);\n  return result;\n};\n\nmodule.exports = parseType;", "var toUnsigned = require('../utils/bin').toUnsigned;\n\nvar parseType = require('./parse-type.js');\n\nvar findBox = function findBox(data, path) {\n  var results = [],\n      i,\n      size,\n      type,\n      end,\n      subresults;\n\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return null;\n  }\n\n  for (i = 0; i < data.byteLength;) {\n    size = toUnsigned(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]);\n    type = parseType(data.subarray(i + 4, i + 8));\n    end = size > 1 ? i + size : data.byteLength;\n\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, end));\n      } else {\n        // recursively search for the next box along the path\n        subresults = findBox(data.subarray(i + 8, end), path.slice(1));\n\n        if (subresults.length) {\n          results = results.concat(subresults);\n        }\n      }\n    }\n\n    i = end;\n  } // we've finished searching all of data\n\n\n  return results;\n};\n\nmodule.exports = findBox;", "var tfhd = function tfhd(data) {\n  var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n      result = {\n    version: data[0],\n    flags: new Uint8Array(data.subarray(1, 4)),\n    trackId: view.getUint32(4)\n  },\n      baseDataOffsetPresent = result.flags[2] & 0x01,\n      sampleDescriptionIndexPresent = result.flags[2] & 0x02,\n      defaultSampleDurationPresent = result.flags[2] & 0x08,\n      defaultSampleSizePresent = result.flags[2] & 0x10,\n      defaultSampleFlagsPresent = result.flags[2] & 0x20,\n      durationIsEmpty = result.flags[0] & 0x010000,\n      defaultBaseIsMoof = result.flags[0] & 0x020000,\n      i;\n  i = 8;\n\n  if (baseDataOffsetPresent) {\n    i += 4; // truncate top 4 bytes\n    // FIXME: should we read the full 64 bits?\n\n    result.baseDataOffset = view.getUint32(12);\n    i += 4;\n  }\n\n  if (sampleDescriptionIndexPresent) {\n    result.sampleDescriptionIndex = view.getUint32(i);\n    i += 4;\n  }\n\n  if (defaultSampleDurationPresent) {\n    result.defaultSampleDuration = view.getUint32(i);\n    i += 4;\n  }\n\n  if (defaultSampleSizePresent) {\n    result.defaultSampleSize = view.getUint32(i);\n    i += 4;\n  }\n\n  if (defaultSampleFlagsPresent) {\n    result.defaultSampleFlags = view.getUint32(i);\n  }\n\n  if (durationIsEmpty) {\n    result.durationIsEmpty = true;\n  }\n\n  if (!baseDataOffsetPresent && defaultBaseIsMoof) {\n    result.baseDataOffsetIsMoof = true;\n  }\n\n  return result;\n};\n\nmodule.exports = tfhd;", "var parseSampleFlags = function parseSampleFlags(flags) {\n  return {\n    isLeading: (flags[0] & 0x0c) >>> 2,\n    dependsOn: flags[0] & 0x03,\n    isDependedOn: (flags[1] & 0xc0) >>> 6,\n    hasRedundancy: (flags[1] & 0x30) >>> 4,\n    paddingValue: (flags[1] & 0x0e) >>> 1,\n    isNonSyncSample: flags[1] & 0x01,\n    degradationPriority: flags[2] << 8 | flags[3]\n  };\n};\n\nmodule.exports = parseSampleFlags;", "var parseSampleFlags = require('./parse-sample-flags.js');\n\nvar trun = function trun(data) {\n  var result = {\n    version: data[0],\n    flags: new Uint8Array(data.subarray(1, 4)),\n    samples: []\n  },\n      view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n      // Flag interpretation\n  dataOffsetPresent = result.flags[2] & 0x01,\n      // compare with 2nd byte of 0x1\n  firstSampleFlagsPresent = result.flags[2] & 0x04,\n      // compare with 2nd byte of 0x4\n  sampleDurationPresent = result.flags[1] & 0x01,\n      // compare with 2nd byte of 0x100\n  sampleSizePresent = result.flags[1] & 0x02,\n      // compare with 2nd byte of 0x200\n  sampleFlagsPresent = result.flags[1] & 0x04,\n      // compare with 2nd byte of 0x400\n  sampleCompositionTimeOffsetPresent = result.flags[1] & 0x08,\n      // compare with 2nd byte of 0x800\n  sampleCount = view.getUint32(4),\n      offset = 8,\n      sample;\n\n  if (dataOffsetPresent) {\n    // 32 bit signed integer\n    result.dataOffset = view.getInt32(offset);\n    offset += 4;\n  } // Overrides the flags for the first sample only. The order of\n  // optional values will be: duration, size, compositionTimeOffset\n\n\n  if (firstSampleFlagsPresent && sampleCount) {\n    sample = {\n      flags: parseSampleFlags(data.subarray(offset, offset + 4))\n    };\n    offset += 4;\n\n    if (sampleDurationPresent) {\n      sample.duration = view.getUint32(offset);\n      offset += 4;\n    }\n\n    if (sampleSizePresent) {\n      sample.size = view.getUint32(offset);\n      offset += 4;\n    }\n\n    if (sampleCompositionTimeOffsetPresent) {\n      if (result.version === 1) {\n        sample.compositionTimeOffset = view.getInt32(offset);\n      } else {\n        sample.compositionTimeOffset = view.getUint32(offset);\n      }\n\n      offset += 4;\n    }\n\n    result.samples.push(sample);\n    sampleCount--;\n  }\n\n  while (sampleCount--) {\n    sample = {};\n\n    if (sampleDurationPresent) {\n      sample.duration = view.getUint32(offset);\n      offset += 4;\n    }\n\n    if (sampleSizePresent) {\n      sample.size = view.getUint32(offset);\n      offset += 4;\n    }\n\n    if (sampleFlagsPresent) {\n      sample.flags = parseSampleFlags(data.subarray(offset, offset + 4));\n      offset += 4;\n    }\n\n    if (sampleCompositionTimeOffsetPresent) {\n      if (result.version === 1) {\n        sample.compositionTimeOffset = view.getInt32(offset);\n      } else {\n        sample.compositionTimeOffset = view.getUint32(offset);\n      }\n\n      offset += 4;\n    }\n\n    result.samples.push(sample);\n  }\n\n  return result;\n};\n\nmodule.exports = trun;", "var toUnsigned = require('../utils/bin').toUnsigned;\n\nvar tfdt = function tfdt(data) {\n  var result = {\n    version: data[0],\n    flags: new Uint8Array(data.subarray(1, 4)),\n    baseMediaDecodeTime: toUnsigned(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7])\n  };\n\n  if (result.version === 1) {\n    result.baseMediaDecodeTime *= Math.pow(2, 32);\n    result.baseMediaDecodeTime += toUnsigned(data[8] << 24 | data[9] << 16 | data[10] << 8 | data[11]);\n  }\n\n  return result;\n};\n\nmodule.exports = tfdt;", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Utilities to detect basic properties and metadata about MP4s.\n */\n'use strict';\n\nvar toUnsigned = require('../utils/bin').toUnsigned;\n\nvar toHexString = require('../utils/bin').toHexString;\n\nvar findBox = require('../mp4/find-box.js');\n\nvar parseType = require('../mp4/parse-type.js');\n\nvar parseTfhd = require('../tools/parse-tfhd.js');\n\nvar parseTrun = require('../tools/parse-trun.js');\n\nvar parseTfdt = require('../tools/parse-tfdt.js');\n\nvar timescale, startTime, compositionStartTime, getVideoTrackIds, getTracks, getTimescaleFromMediaHeader;\n/**\n * Parses an MP4 initialization segment and extracts the timescale\n * values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * ```\n * @param init {Uint8Array} the bytes of the init segment\n * @return {object} a hash of track ids to timescale values or null if\n * the init segment is malformed.\n */\n\ntimescale = function timescale(init) {\n  var result = {},\n      traks = findBox(init, ['moov', 'trak']); // mdhd timescale\n\n  return traks.reduce(function (result, trak) {\n    var tkhd, version, index, id, mdhd;\n    tkhd = findBox(trak, ['tkhd'])[0];\n\n    if (!tkhd) {\n      return null;\n    }\n\n    version = tkhd[0];\n    index = version === 0 ? 12 : 20;\n    id = toUnsigned(tkhd[index] << 24 | tkhd[index + 1] << 16 | tkhd[index + 2] << 8 | tkhd[index + 3]);\n    mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n\n    if (!mdhd) {\n      return null;\n    }\n\n    version = mdhd[0];\n    index = version === 0 ? 12 : 20;\n    result[id] = toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);\n    return result;\n  }, result);\n};\n/**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param timescale {object} a hash of track ids to timescale values.\n * @return {number} the earliest base media decode start time for the\n * fragment, in seconds\n */\n\n\nstartTime = function startTime(timescale, fragment) {\n  var trafs, baseTimes, result; // we need info from two childrend of each track fragment box\n\n  trafs = findBox(fragment, ['moof', 'traf']); // determine the start times for each track\n\n  baseTimes = [].concat.apply([], trafs.map(function (traf) {\n    return findBox(traf, ['tfhd']).map(function (tfhd) {\n      var id, scale, baseTime; // get the track id from the tfhd\n\n      id = toUnsigned(tfhd[4] << 24 | tfhd[5] << 16 | tfhd[6] << 8 | tfhd[7]); // assume a 90kHz clock if no timescale was specified\n\n      scale = timescale[id] || 90e3; // get the base media decode time from the tfdt\n\n      baseTime = findBox(traf, ['tfdt']).map(function (tfdt) {\n        var version, result;\n        version = tfdt[0];\n        result = toUnsigned(tfdt[4] << 24 | tfdt[5] << 16 | tfdt[6] << 8 | tfdt[7]);\n\n        if (version === 1) {\n          result *= Math.pow(2, 32);\n          result += toUnsigned(tfdt[8] << 24 | tfdt[9] << 16 | tfdt[10] << 8 | tfdt[11]);\n        }\n\n        return result;\n      })[0];\n      baseTime = typeof baseTime === 'number' && !isNaN(baseTime) ? baseTime : Infinity; // convert base time to seconds\n\n      return baseTime / scale;\n    });\n  })); // return the minimum\n\n  result = Math.min.apply(null, baseTimes);\n  return isFinite(result) ? result : 0;\n};\n/**\n * Determine the composition start, in seconds, for an MP4\n * fragment.\n *\n * The composition start time of a fragment can be calculated using the base\n * media decode time, composition time offset, and timescale, as follows:\n *\n * compositionStartTime = (baseMediaDecodeTime + compositionTimeOffset) / timescale\n *\n * All of the aforementioned information is contained within a media fragment's\n * `traf` box, except for timescale info, which comes from the initialization\n * segment, so a track id (also contained within a `traf`) is also necessary to\n * associate it with a timescale\n *\n *\n * @param timescales {object} - a hash of track ids to timescale values.\n * @param fragment {Unit8Array} - the bytes of a media segment\n * @return {number} the composition start time for the fragment, in seconds\n **/\n\n\ncompositionStartTime = function compositionStartTime(timescales, fragment) {\n  var trafBoxes = findBox(fragment, ['moof', 'traf']);\n  var baseMediaDecodeTime = 0;\n  var compositionTimeOffset = 0;\n  var trackId;\n\n  if (trafBoxes && trafBoxes.length) {\n    // The spec states that track run samples contained within a `traf` box are contiguous, but\n    // it does not explicitly state whether the `traf` boxes themselves are contiguous.\n    // We will assume that they are, so we only need the first to calculate start time.\n    var tfhd = findBox(trafBoxes[0], ['tfhd'])[0];\n    var trun = findBox(trafBoxes[0], ['trun'])[0];\n    var tfdt = findBox(trafBoxes[0], ['tfdt'])[0];\n\n    if (tfhd) {\n      var parsedTfhd = parseTfhd(tfhd);\n      trackId = parsedTfhd.trackId;\n    }\n\n    if (tfdt) {\n      var parsedTfdt = parseTfdt(tfdt);\n      baseMediaDecodeTime = parsedTfdt.baseMediaDecodeTime;\n    }\n\n    if (trun) {\n      var parsedTrun = parseTrun(trun);\n\n      if (parsedTrun.samples && parsedTrun.samples.length) {\n        compositionTimeOffset = parsedTrun.samples[0].compositionTimeOffset || 0;\n      }\n    }\n  } // Get timescale for this specific track. Assume a 90kHz clock if no timescale was\n  // specified.\n\n\n  var timescale = timescales[trackId] || 90e3; // return the composition start time, in seconds\n\n  return (baseMediaDecodeTime + compositionTimeOffset) / timescale;\n};\n/**\n  * Find the trackIds of the video tracks in this source.\n  * Found by parsing the Handler Reference and Track Header Boxes:\n  *   moov > trak > mdia > hdlr\n  *   moov > trak > tkhd\n  *\n  * @param {Uint8Array} init - The bytes of the init segment for this source\n  * @return {Number[]} A list of trackIds\n  *\n  * @see ISO-BMFF-12/2015, Section 8.4.3\n **/\n\n\ngetVideoTrackIds = function getVideoTrackIds(init) {\n  var traks = findBox(init, ['moov', 'trak']);\n  var videoTrackIds = [];\n  traks.forEach(function (trak) {\n    var hdlrs = findBox(trak, ['mdia', 'hdlr']);\n    var tkhds = findBox(trak, ['tkhd']);\n    hdlrs.forEach(function (hdlr, index) {\n      var handlerType = parseType(hdlr.subarray(8, 12));\n      var tkhd = tkhds[index];\n      var view;\n      var version;\n      var trackId;\n\n      if (handlerType === 'vide') {\n        view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n        version = view.getUint8(0);\n        trackId = version === 0 ? view.getUint32(12) : view.getUint32(20);\n        videoTrackIds.push(trackId);\n      }\n    });\n  });\n  return videoTrackIds;\n};\n\ngetTimescaleFromMediaHeader = function getTimescaleFromMediaHeader(mdhd) {\n  // mdhd is a FullBox, meaning it will have its own version as the first byte\n  var version = mdhd[0];\n  var index = version === 0 ? 12 : 20;\n  return toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);\n};\n/**\n * Get all the video, audio, and hint tracks from a non fragmented\n * mp4 segment\n */\n\n\ngetTracks = function getTracks(init) {\n  var traks = findBox(init, ['moov', 'trak']);\n  var tracks = [];\n  traks.forEach(function (trak) {\n    var track = {};\n    var tkhd = findBox(trak, ['tkhd'])[0];\n    var view, tkhdVersion; // id\n\n    if (tkhd) {\n      view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n      tkhdVersion = view.getUint8(0);\n      track.id = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);\n    }\n\n    var hdlr = findBox(trak, ['mdia', 'hdlr'])[0]; // type\n\n    if (hdlr) {\n      var type = parseType(hdlr.subarray(8, 12));\n\n      if (type === 'vide') {\n        track.type = 'video';\n      } else if (type === 'soun') {\n        track.type = 'audio';\n      } else {\n        track.type = type;\n      }\n    } // codec\n\n\n    var stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n\n    if (stsd) {\n      var sampleDescriptions = stsd.subarray(8); // gives the codec type string\n\n      track.codec = parseType(sampleDescriptions.subarray(4, 8));\n      var codecBox = findBox(sampleDescriptions, [track.codec])[0];\n      var codecConfig, codecConfigType;\n\n      if (codecBox) {\n        // https://tools.ietf.org/html/rfc6381#section-3.3\n        if (/^[asm]vc[1-9]$/i.test(track.codec)) {\n          // we don't need anything but the \"config\" parameter of the\n          // avc1 codecBox\n          codecConfig = codecBox.subarray(78);\n          codecConfigType = parseType(codecConfig.subarray(4, 8));\n\n          if (codecConfigType === 'avcC' && codecConfig.length > 11) {\n            track.codec += '.'; // left padded with zeroes for single digit hex\n            // profile idc\n\n            track.codec += toHexString(codecConfig[9]); // the byte containing the constraint_set flags\n\n            track.codec += toHexString(codecConfig[10]); // level idc\n\n            track.codec += toHexString(codecConfig[11]);\n          } else {\n            // TODO: show a warning that we couldn't parse the codec\n            // and are using the default\n            track.codec = 'avc1.4d400d';\n          }\n        } else if (/^mp4[a,v]$/i.test(track.codec)) {\n          // we do not need anything but the streamDescriptor of the mp4a codecBox\n          codecConfig = codecBox.subarray(28);\n          codecConfigType = parseType(codecConfig.subarray(4, 8));\n\n          if (codecConfigType === 'esds' && codecConfig.length > 20 && codecConfig[19] !== 0) {\n            track.codec += '.' + toHexString(codecConfig[19]); // this value is only a single digit\n\n            track.codec += '.' + toHexString(codecConfig[20] >>> 2 & 0x3f).replace(/^0/, '');\n          } else {\n            // TODO: show a warning that we couldn't parse the codec\n            // and are using the default\n            track.codec = 'mp4a.40.2';\n          }\n        } else {\n          // flac, opus, etc\n          track.codec = track.codec.toLowerCase();\n        }\n      }\n    }\n\n    var mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n\n    if (mdhd) {\n      track.timescale = getTimescaleFromMediaHeader(mdhd);\n    }\n\n    tracks.push(track);\n  });\n  return tracks;\n};\n\nmodule.exports = {\n  // export mp4 inspector's findBox and parseType for backwards compatibility\n  findBox: findBox,\n  parseType: parseType,\n  timescale: timescale,\n  startTime: startTime,\n  compositionStartTime: compositionStartTime,\n  videoTrackIds: getVideoTrackIds,\n  tracks: getTracks,\n  getTimescaleFromMediaHeader: getTimescaleFromMediaHeader\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n// Convert an array of nal units into an array of frames with each frame being\n// composed of the nal units that make up that frame\n// Also keep track of cummulative data about the frame from the nal units such\n// as the frame duration, starting pts, etc.\nvar groupNalsIntoFrames = function groupNalsIntoFrames(nalUnits) {\n  var i,\n      currentNal,\n      currentFrame = [],\n      frames = []; // TODO added for LHLS, make sure this is OK\n\n  frames.byteLength = 0;\n  frames.nalCount = 0;\n  frames.duration = 0;\n  currentFrame.byteLength = 0;\n\n  for (i = 0; i < nalUnits.length; i++) {\n    currentNal = nalUnits[i]; // Split on 'aud'-type nal units\n\n    if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n      // Since the very first nal unit is expected to be an AUD\n      // only push to the frames array when currentFrame is not empty\n      if (currentFrame.length) {\n        currentFrame.duration = currentNal.dts - currentFrame.dts; // TODO added for LHLS, make sure this is OK\n\n        frames.byteLength += currentFrame.byteLength;\n        frames.nalCount += currentFrame.length;\n        frames.duration += currentFrame.duration;\n        frames.push(currentFrame);\n      }\n\n      currentFrame = [currentNal];\n      currentFrame.byteLength = currentNal.data.byteLength;\n      currentFrame.pts = currentNal.pts;\n      currentFrame.dts = currentNal.dts;\n    } else {\n      // Specifically flag key frames for ease of use later\n      if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n        currentFrame.keyFrame = true;\n      }\n\n      currentFrame.duration = currentNal.dts - currentFrame.dts;\n      currentFrame.byteLength += currentNal.data.byteLength;\n      currentFrame.push(currentNal);\n    }\n  } // For the last frame, use the duration of the previous frame if we\n  // have nothing better to go on\n\n\n  if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) {\n    currentFrame.duration = frames[frames.length - 1].duration;\n  } // Push the final frame\n  // TODO added for LHLS, make sure this is OK\n\n\n  frames.byteLength += currentFrame.byteLength;\n  frames.nalCount += currentFrame.length;\n  frames.duration += currentFrame.duration;\n  frames.push(currentFrame);\n  return frames;\n}; // Convert an array of frames into an array of Gop with each Gop being composed\n// of the frames that make up that Gop\n// Also keep track of cummulative data about the Gop from the frames such as the\n// Gop duration, starting pts, etc.\n\n\nvar groupFramesIntoGops = function groupFramesIntoGops(frames) {\n  var i,\n      currentFrame,\n      currentGop = [],\n      gops = []; // We must pre-set some of the values on the Gop since we\n  // keep running totals of these values\n\n  currentGop.byteLength = 0;\n  currentGop.nalCount = 0;\n  currentGop.duration = 0;\n  currentGop.pts = frames[0].pts;\n  currentGop.dts = frames[0].dts; // store some metadata about all the Gops\n\n  gops.byteLength = 0;\n  gops.nalCount = 0;\n  gops.duration = 0;\n  gops.pts = frames[0].pts;\n  gops.dts = frames[0].dts;\n\n  for (i = 0; i < frames.length; i++) {\n    currentFrame = frames[i];\n\n    if (currentFrame.keyFrame) {\n      // Since the very first frame is expected to be an keyframe\n      // only push to the gops array when currentGop is not empty\n      if (currentGop.length) {\n        gops.push(currentGop);\n        gops.byteLength += currentGop.byteLength;\n        gops.nalCount += currentGop.nalCount;\n        gops.duration += currentGop.duration;\n      }\n\n      currentGop = [currentFrame];\n      currentGop.nalCount = currentFrame.length;\n      currentGop.byteLength = currentFrame.byteLength;\n      currentGop.pts = currentFrame.pts;\n      currentGop.dts = currentFrame.dts;\n      currentGop.duration = currentFrame.duration;\n    } else {\n      currentGop.duration += currentFrame.duration;\n      currentGop.nalCount += currentFrame.length;\n      currentGop.byteLength += currentFrame.byteLength;\n      currentGop.push(currentFrame);\n    }\n  }\n\n  if (gops.length && currentGop.duration <= 0) {\n    currentGop.duration = gops[gops.length - 1].duration;\n  }\n\n  gops.byteLength += currentGop.byteLength;\n  gops.nalCount += currentGop.nalCount;\n  gops.duration += currentGop.duration; // push the final Gop\n\n  gops.push(currentGop);\n  return gops;\n};\n/*\n * Search for the first keyframe in the GOPs and throw away all frames\n * until that keyframe. Then extend the duration of the pulled keyframe\n * and pull the PTS and DTS of the keyframe so that it covers the time\n * range of the frames that were disposed.\n *\n * @param {Array} gops video GOPs\n * @returns {Array} modified video GOPs\n */\n\n\nvar extendFirstKeyFrame = function extendFirstKeyFrame(gops) {\n  var currentGop;\n\n  if (!gops[0][0].keyFrame && gops.length > 1) {\n    // Remove the first GOP\n    currentGop = gops.shift();\n    gops.byteLength -= currentGop.byteLength;\n    gops.nalCount -= currentGop.nalCount; // Extend the first frame of what is now the\n    // first gop to cover the time period of the\n    // frames we just removed\n\n    gops[0][0].dts = currentGop.dts;\n    gops[0][0].pts = currentGop.pts;\n    gops[0][0].duration += currentGop.duration;\n  }\n\n  return gops;\n};\n/**\n * Default sample object\n * see ISO/IEC 14496-12:2012, section 8.6.4.3\n */\n\n\nvar createDefaultSample = function createDefaultSample() {\n  return {\n    size: 0,\n    flags: {\n      isLeading: 0,\n      dependsOn: 1,\n      isDependedOn: 0,\n      hasRedundancy: 0,\n      degradationPriority: 0,\n      isNonSyncSample: 1\n    }\n  };\n};\n/*\n * Collates information from a video frame into an object for eventual\n * entry into an MP4 sample table.\n *\n * @param {Object} frame the video frame\n * @param {Number} dataOffset the byte offset to position the sample\n * @return {Object} object containing sample table info for a frame\n */\n\n\nvar sampleForFrame = function sampleForFrame(frame, dataOffset) {\n  var sample = createDefaultSample();\n  sample.dataOffset = dataOffset;\n  sample.compositionTimeOffset = frame.pts - frame.dts;\n  sample.duration = frame.duration;\n  sample.size = 4 * frame.length; // Space for nal unit size\n\n  sample.size += frame.byteLength;\n\n  if (frame.keyFrame) {\n    sample.flags.dependsOn = 2;\n    sample.flags.isNonSyncSample = 0;\n  }\n\n  return sample;\n}; // generate the track's sample table from an array of gops\n\n\nvar generateSampleTable = function generateSampleTable(gops, baseDataOffset) {\n  var h,\n      i,\n      sample,\n      currentGop,\n      currentFrame,\n      dataOffset = baseDataOffset || 0,\n      samples = [];\n\n  for (h = 0; h < gops.length; h++) {\n    currentGop = gops[h];\n\n    for (i = 0; i < currentGop.length; i++) {\n      currentFrame = currentGop[i];\n      sample = sampleForFrame(currentFrame, dataOffset);\n      dataOffset += sample.size;\n      samples.push(sample);\n    }\n  }\n\n  return samples;\n}; // generate the track's raw mdat data from an array of gops\n\n\nvar concatenateNalData = function concatenateNalData(gops) {\n  var h,\n      i,\n      j,\n      currentGop,\n      currentFrame,\n      currentNal,\n      dataOffset = 0,\n      nalsByteLength = gops.byteLength,\n      numberOfNals = gops.nalCount,\n      totalByteLength = nalsByteLength + 4 * numberOfNals,\n      data = new Uint8Array(totalByteLength),\n      view = new DataView(data.buffer); // For each Gop..\n\n  for (h = 0; h < gops.length; h++) {\n    currentGop = gops[h]; // For each Frame..\n\n    for (i = 0; i < currentGop.length; i++) {\n      currentFrame = currentGop[i]; // For each NAL..\n\n      for (j = 0; j < currentFrame.length; j++) {\n        currentNal = currentFrame[j];\n        view.setUint32(dataOffset, currentNal.data.byteLength);\n        dataOffset += 4;\n        data.set(currentNal.data, dataOffset);\n        dataOffset += currentNal.data.byteLength;\n      }\n    }\n  }\n\n  return data;\n}; // generate the track's sample table from a frame\n\n\nvar generateSampleTableForFrame = function generateSampleTableForFrame(frame, baseDataOffset) {\n  var sample,\n      dataOffset = baseDataOffset || 0,\n      samples = [];\n  sample = sampleForFrame(frame, dataOffset);\n  samples.push(sample);\n  return samples;\n}; // generate the track's raw mdat data from a frame\n\n\nvar concatenateNalDataForFrame = function concatenateNalDataForFrame(frame) {\n  var i,\n      currentNal,\n      dataOffset = 0,\n      nalsByteLength = frame.byteLength,\n      numberOfNals = frame.length,\n      totalByteLength = nalsByteLength + 4 * numberOfNals,\n      data = new Uint8Array(totalByteLength),\n      view = new DataView(data.buffer); // For each NAL..\n\n  for (i = 0; i < frame.length; i++) {\n    currentNal = frame[i];\n    view.setUint32(dataOffset, currentNal.data.byteLength);\n    dataOffset += 4;\n    data.set(currentNal.data, dataOffset);\n    dataOffset += currentNal.data.byteLength;\n  }\n\n  return data;\n};\n\nmodule.exports = {\n  groupNalsIntoFrames: groupNalsIntoFrames,\n  groupFramesIntoGops: groupFramesIntoGops,\n  extendFirstKeyFrame: extendFirstKeyFrame,\n  generateSampleTable: generateSampleTable,\n  concatenateNalData: concatenateNalData,\n  generateSampleTableForFrame: generateSampleTableForFrame,\n  concatenateNalDataForFrame: concatenateNalDataForFrame\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\nvar highPrefix = [33, 16, 5, 32, 164, 27];\nvar lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];\n\nvar zeroFill = function zeroFill(count) {\n  var a = [];\n\n  while (count--) {\n    a.push(0);\n  }\n\n  return a;\n};\n\nvar makeTable = function makeTable(metaTable) {\n  return Object.keys(metaTable).reduce(function (obj, key) {\n    obj[key] = new Uint8Array(metaTable[key].reduce(function (arr, part) {\n      return arr.concat(part);\n    }, []));\n    return obj;\n  }, {});\n};\n\nvar silence;\n\nmodule.exports = function () {\n  if (!silence) {\n    // Frames-of-silence to use for filling in missing AAC frames\n    var coneOfSilence = {\n      96000: [highPrefix, [227, 64], zeroFill(154), [56]],\n      88200: [highPrefix, [231], zeroFill(170), [56]],\n      64000: [highPrefix, [248, 192], zeroFill(240), [56]],\n      48000: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],\n      44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],\n      32000: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],\n      24000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],\n      16000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],\n      12000: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],\n      11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],\n      8000: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]\n    };\n    silence = makeTable(coneOfSilence);\n  }\n\n  return silence;\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\nvar coneOfSilence = require('../data/silence');\n\nvar clock = require('../utils/clock');\n/**\n * Sum the `byteLength` properties of the data in each AAC frame\n */\n\n\nvar sumFrameByteLengths = function sumFrameByteLengths(array) {\n  var i,\n      currentObj,\n      sum = 0; // sum the byteLength's all each nal unit in the frame\n\n  for (i = 0; i < array.length; i++) {\n    currentObj = array[i];\n    sum += currentObj.data.byteLength;\n  }\n\n  return sum;\n}; // Possibly pad (prefix) the audio track with silence if appending this track\n// would lead to the introduction of a gap in the audio buffer\n\n\nvar prefixWithSilence = function prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {\n  var baseMediaDecodeTimeTs,\n      frameDuration = 0,\n      audioGapDuration = 0,\n      audioFillFrameCount = 0,\n      audioFillDuration = 0,\n      silentFrame,\n      i,\n      firstFrame;\n\n  if (!frames.length) {\n    return;\n  }\n\n  baseMediaDecodeTimeTs = clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate); // determine frame clock duration based on sample rate, round up to avoid overfills\n\n  frameDuration = Math.ceil(clock.ONE_SECOND_IN_TS / (track.samplerate / 1024));\n\n  if (audioAppendStartTs && videoBaseMediaDecodeTime) {\n    // insert the shortest possible amount (audio gap or audio to video gap)\n    audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime); // number of full frames in the audio gap\n\n    audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);\n    audioFillDuration = audioFillFrameCount * frameDuration;\n  } // don't attempt to fill gaps smaller than a single frame or larger\n  // than a half second\n\n\n  if (audioFillFrameCount < 1 || audioFillDuration > clock.ONE_SECOND_IN_TS / 2) {\n    return;\n  }\n\n  silentFrame = coneOfSilence()[track.samplerate];\n\n  if (!silentFrame) {\n    // we don't have a silent frame pregenerated for the sample rate, so use a frame\n    // from the content instead\n    silentFrame = frames[0].data;\n  }\n\n  for (i = 0; i < audioFillFrameCount; i++) {\n    firstFrame = frames[0];\n    frames.splice(0, 0, {\n      data: silentFrame,\n      dts: firstFrame.dts - frameDuration,\n      pts: firstFrame.pts - frameDuration\n    });\n  }\n\n  track.baseMediaDecodeTime -= Math.floor(clock.videoTsToAudioTs(audioFillDuration, track.samplerate));\n  return audioFillDuration;\n}; // If the audio segment extends before the earliest allowed dts\n// value, remove AAC frames until starts at or after the earliest\n// allowed DTS so that we don't end up with a negative baseMedia-\n// DecodeTime for the audio track\n\n\nvar trimAdtsFramesByEarliestDts = function trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts) {\n  if (track.minSegmentDts >= earliestAllowedDts) {\n    return adtsFrames;\n  } // We will need to recalculate the earliest segment Dts\n\n\n  track.minSegmentDts = Infinity;\n  return adtsFrames.filter(function (currentFrame) {\n    // If this is an allowed frame, keep it and record it's Dts\n    if (currentFrame.dts >= earliestAllowedDts) {\n      track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\n      track.minSegmentPts = track.minSegmentDts;\n      return true;\n    } // Otherwise, discard it\n\n\n    return false;\n  });\n}; // generate the track's raw mdat data from an array of frames\n\n\nvar generateSampleTable = function generateSampleTable(frames) {\n  var i,\n      currentFrame,\n      samples = [];\n\n  for (i = 0; i < frames.length; i++) {\n    currentFrame = frames[i];\n    samples.push({\n      size: currentFrame.data.byteLength,\n      duration: 1024 // For AAC audio, all samples contain 1024 samples\n\n    });\n  }\n\n  return samples;\n}; // generate the track's sample table from an array of frames\n\n\nvar concatenateFrameData = function concatenateFrameData(frames) {\n  var i,\n      currentFrame,\n      dataOffset = 0,\n      data = new Uint8Array(sumFrameByteLengths(frames));\n\n  for (i = 0; i < frames.length; i++) {\n    currentFrame = frames[i];\n    data.set(currentFrame.data, dataOffset);\n    dataOffset += currentFrame.data.byteLength;\n  }\n\n  return data;\n};\n\nmodule.exports = {\n  prefixWithSilence: prefixWithSilence,\n  trimAdtsFramesByEarliestDts: trimAdtsFramesByEarliestDts,\n  generateSampleTable: generateSampleTable,\n  concatenateFrameData: concatenateFrameData\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\nvar ONE_SECOND_IN_TS = require('../utils/clock').ONE_SECOND_IN_TS;\n/**\n * Store information about the start and end of the track and the\n * duration for each frame/sample we process in order to calculate\n * the baseMediaDecodeTime\n */\n\n\nvar collectDtsInfo = function collectDtsInfo(track, data) {\n  if (typeof data.pts === 'number') {\n    if (track.timelineStartInfo.pts === undefined) {\n      track.timelineStartInfo.pts = data.pts;\n    }\n\n    if (track.minSegmentPts === undefined) {\n      track.minSegmentPts = data.pts;\n    } else {\n      track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\n    }\n\n    if (track.maxSegmentPts === undefined) {\n      track.maxSegmentPts = data.pts;\n    } else {\n      track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\n    }\n  }\n\n  if (typeof data.dts === 'number') {\n    if (track.timelineStartInfo.dts === undefined) {\n      track.timelineStartInfo.dts = data.dts;\n    }\n\n    if (track.minSegmentDts === undefined) {\n      track.minSegmentDts = data.dts;\n    } else {\n      track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\n    }\n\n    if (track.maxSegmentDts === undefined) {\n      track.maxSegmentDts = data.dts;\n    } else {\n      track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\n    }\n  }\n};\n/**\n * Clear values used to calculate the baseMediaDecodeTime between\n * tracks\n */\n\n\nvar clearDtsInfo = function clearDtsInfo(track) {\n  delete track.minSegmentDts;\n  delete track.maxSegmentDts;\n  delete track.minSegmentPts;\n  delete track.maxSegmentPts;\n};\n/**\n * Calculate the track's baseMediaDecodeTime based on the earliest\n * DTS the transmuxer has ever seen and the minimum DTS for the\n * current track\n * @param track {object} track metadata configuration\n * @param keepOriginalTimestamps {boolean} If true, keep the timestamps\n *        in the source; false to adjust the first segment to start at 0.\n */\n\n\nvar calculateTrackBaseMediaDecodeTime = function calculateTrackBaseMediaDecodeTime(track, keepOriginalTimestamps) {\n  var baseMediaDecodeTime,\n      scale,\n      minSegmentDts = track.minSegmentDts; // Optionally adjust the time so the first segment starts at zero.\n\n  if (!keepOriginalTimestamps) {\n    minSegmentDts -= track.timelineStartInfo.dts;\n  } // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\n  // we want the start of the first segment to be placed\n\n\n  baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime; // Add to that the distance this segment is from the very first\n\n  baseMediaDecodeTime += minSegmentDts; // baseMediaDecodeTime must not become negative\n\n  baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);\n\n  if (track.type === 'audio') {\n    // Audio has a different clock equal to the sampling_rate so we need to\n    // scale the PTS values into the clock rate of the track\n    scale = track.samplerate / ONE_SECOND_IN_TS;\n    baseMediaDecodeTime *= scale;\n    baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);\n  }\n\n  return baseMediaDecodeTime;\n};\n\nmodule.exports = {\n  clearDtsInfo: clearDtsInfo,\n  calculateTrackBaseMediaDecodeTime: calculateTrackBaseMediaDecodeTime,\n  collectDtsInfo: collectDtsInfo\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Reads in-band caption information from a video elementary\n * stream. Captions must follow the CEA-708 standard for injection\n * into an MPEG-2 transport streams.\n * @see https://en.wikipedia.org/wiki/CEA-708\n * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n */\n'use strict'; // Supplemental enhancement information (SEI) NAL units have a\n// payload type field to indicate how they are to be\n// interpreted. CEAS-708 caption content is always transmitted with\n// payload type 0x04.\n\nvar USER_DATA_REGISTERED_ITU_T_T35 = 4,\n    RBSP_TRAILING_BITS = 128;\n/**\n  * Parse a supplemental enhancement information (SEI) NAL unit.\n  * Stops parsing once a message of type ITU T T35 has been found.\n  *\n  * @param bytes {Uint8Array} the bytes of a SEI NAL unit\n  * @return {object} the parsed SEI payload\n  * @see Rec. ITU-T H.264, 7.3.2.3.1\n  */\n\nvar parseSei = function parseSei(bytes) {\n  var i = 0,\n      result = {\n    payloadType: -1,\n    payloadSize: 0\n  },\n      payloadType = 0,\n      payloadSize = 0; // go through the sei_rbsp parsing each each individual sei_message\n\n  while (i < bytes.byteLength) {\n    // stop once we have hit the end of the sei_rbsp\n    if (bytes[i] === RBSP_TRAILING_BITS) {\n      break;\n    } // Parse payload type\n\n\n    while (bytes[i] === 0xFF) {\n      payloadType += 255;\n      i++;\n    }\n\n    payloadType += bytes[i++]; // Parse payload size\n\n    while (bytes[i] === 0xFF) {\n      payloadSize += 255;\n      i++;\n    }\n\n    payloadSize += bytes[i++]; // this sei_message is a 608/708 caption so save it and break\n    // there can only ever be one caption message in a frame's sei\n\n    if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\n      var userIdentifier = String.fromCharCode(bytes[i + 3], bytes[i + 4], bytes[i + 5], bytes[i + 6]);\n\n      if (userIdentifier === 'GA94') {\n        result.payloadType = payloadType;\n        result.payloadSize = payloadSize;\n        result.payload = bytes.subarray(i, i + payloadSize);\n        break;\n      } else {\n        result.payload = void 0;\n      }\n    } // skip the payload and parse the next message\n\n\n    i += payloadSize;\n    payloadType = 0;\n    payloadSize = 0;\n  }\n\n  return result;\n}; // see ANSI/SCTE 128-1 (2013), section 8.1\n\n\nvar parseUserData = function parseUserData(sei) {\n  // itu_t_t35_contry_code must be 181 (United States) for\n  // captions\n  if (sei.payload[0] !== 181) {\n    return null;\n  } // itu_t_t35_provider_code should be 49 (ATSC) for captions\n\n\n  if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {\n    return null;\n  } // the user_identifier should be \"GA94\" to indicate ATSC1 data\n\n\n  if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== 'GA94') {\n    return null;\n  } // finally, user_data_type_code should be 0x03 for caption data\n\n\n  if (sei.payload[7] !== 0x03) {\n    return null;\n  } // return the user_data_type_structure and strip the trailing\n  // marker bits\n\n\n  return sei.payload.subarray(8, sei.payload.length - 1);\n}; // see CEA-708-D, section 4.4\n\n\nvar parseCaptionPackets = function parseCaptionPackets(pts, userData) {\n  var results = [],\n      i,\n      count,\n      offset,\n      data; // if this is just filler, return immediately\n\n  if (!(userData[0] & 0x40)) {\n    return results;\n  } // parse out the cc_data_1 and cc_data_2 fields\n\n\n  count = userData[0] & 0x1f;\n\n  for (i = 0; i < count; i++) {\n    offset = i * 3;\n    data = {\n      type: userData[offset + 2] & 0x03,\n      pts: pts\n    }; // capture cc data when cc_valid is 1\n\n    if (userData[offset + 2] & 0x04) {\n      data.ccData = userData[offset + 3] << 8 | userData[offset + 4];\n      results.push(data);\n    }\n  }\n\n  return results;\n};\n\nvar discardEmulationPreventionBytes = function discardEmulationPreventionBytes(data) {\n  var length = data.byteLength,\n      emulationPreventionBytesPositions = [],\n      i = 1,\n      newLength,\n      newData; // Find all `Emulation Prevention Bytes`\n\n  while (i < length - 2) {\n    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n      emulationPreventionBytesPositions.push(i + 2);\n      i += 2;\n    } else {\n      i++;\n    }\n  } // If no Emulation Prevention Bytes were found just return the original\n  // array\n\n\n  if (emulationPreventionBytesPositions.length === 0) {\n    return data;\n  } // Create a new array to hold the NAL unit data\n\n\n  newLength = length - emulationPreventionBytesPositions.length;\n  newData = new Uint8Array(newLength);\n  var sourceIndex = 0;\n\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === emulationPreventionBytesPositions[0]) {\n      // Skip this byte\n      sourceIndex++; // Remove this position index\n\n      emulationPreventionBytesPositions.shift();\n    }\n\n    newData[i] = data[sourceIndex];\n  }\n\n  return newData;\n}; // exports\n\n\nmodule.exports = {\n  parseSei: parseSei,\n  parseUserData: parseUserData,\n  parseCaptionPackets: parseCaptionPackets,\n  discardEmulationPreventionBytes: discardEmulationPreventionBytes,\n  USER_DATA_REGISTERED_ITU_T_T35: USER_DATA_REGISTERED_ITU_T_T35\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Reads in-band caption information from a video elementary\n * stream. Captions must follow the CEA-708 standard for injection\n * into an MPEG-2 transport streams.\n * @see https://en.wikipedia.org/wiki/CEA-708\n * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n */\n'use strict'; // -----------------\n// Link To Transport\n// -----------------\n\nvar Stream = require('../utils/stream');\n\nvar cea708Parser = require('../tools/caption-packet-parser');\n\nvar CaptionStream = function CaptionStream(options) {\n  options = options || {};\n  CaptionStream.prototype.init.call(this); // parse708captions flag, default to true\n\n  this.parse708captions_ = typeof options.parse708captions === 'boolean' ? options.parse708captions : true;\n  this.captionPackets_ = [];\n  this.ccStreams_ = [new Cea608Stream(0, 0), // eslint-disable-line no-use-before-define\n  new Cea608Stream(0, 1), // eslint-disable-line no-use-before-define\n  new Cea608Stream(1, 0), // eslint-disable-line no-use-before-define\n  new Cea608Stream(1, 1) // eslint-disable-line no-use-before-define\n  ];\n\n  if (this.parse708captions_) {\n    this.cc708Stream_ = new Cea708Stream({\n      captionServices: options.captionServices\n    }); // eslint-disable-line no-use-before-define\n  }\n\n  this.reset(); // forward data and done events from CCs to this CaptionStream\n\n  this.ccStreams_.forEach(function (cc) {\n    cc.on('data', this.trigger.bind(this, 'data'));\n    cc.on('partialdone', this.trigger.bind(this, 'partialdone'));\n    cc.on('done', this.trigger.bind(this, 'done'));\n  }, this);\n\n  if (this.parse708captions_) {\n    this.cc708Stream_.on('data', this.trigger.bind(this, 'data'));\n    this.cc708Stream_.on('partialdone', this.trigger.bind(this, 'partialdone'));\n    this.cc708Stream_.on('done', this.trigger.bind(this, 'done'));\n  }\n};\n\nCaptionStream.prototype = new Stream();\n\nCaptionStream.prototype.push = function (event) {\n  var sei, userData, newCaptionPackets; // only examine SEI NALs\n\n  if (event.nalUnitType !== 'sei_rbsp') {\n    return;\n  } // parse the sei\n\n\n  sei = cea708Parser.parseSei(event.escapedRBSP); // no payload data, skip\n\n  if (!sei.payload) {\n    return;\n  } // ignore everything but user_data_registered_itu_t_t35\n\n\n  if (sei.payloadType !== cea708Parser.USER_DATA_REGISTERED_ITU_T_T35) {\n    return;\n  } // parse out the user data payload\n\n\n  userData = cea708Parser.parseUserData(sei); // ignore unrecognized userData\n\n  if (!userData) {\n    return;\n  } // Sometimes, the same segment # will be downloaded twice. To stop the\n  // caption data from being processed twice, we track the latest dts we've\n  // received and ignore everything with a dts before that. However, since\n  // data for a specific dts can be split across packets on either side of\n  // a segment boundary, we need to make sure we *don't* ignore the packets\n  // from the *next* segment that have dts === this.latestDts_. By constantly\n  // tracking the number of packets received with dts === this.latestDts_, we\n  // know how many should be ignored once we start receiving duplicates.\n\n\n  if (event.dts < this.latestDts_) {\n    // We've started getting older data, so set the flag.\n    this.ignoreNextEqualDts_ = true;\n    return;\n  } else if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {\n    this.numSameDts_--;\n\n    if (!this.numSameDts_) {\n      // We've received the last duplicate packet, time to start processing again\n      this.ignoreNextEqualDts_ = false;\n    }\n\n    return;\n  } // parse out CC data packets and save them for later\n\n\n  newCaptionPackets = cea708Parser.parseCaptionPackets(event.pts, userData);\n  this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);\n\n  if (this.latestDts_ !== event.dts) {\n    this.numSameDts_ = 0;\n  }\n\n  this.numSameDts_++;\n  this.latestDts_ = event.dts;\n};\n\nCaptionStream.prototype.flushCCStreams = function (flushType) {\n  this.ccStreams_.forEach(function (cc) {\n    return flushType === 'flush' ? cc.flush() : cc.partialFlush();\n  }, this);\n};\n\nCaptionStream.prototype.flushStream = function (flushType) {\n  // make sure we actually parsed captions before proceeding\n  if (!this.captionPackets_.length) {\n    this.flushCCStreams(flushType);\n    return;\n  } // In Chrome, the Array#sort function is not stable so add a\n  // presortIndex that we can use to ensure we get a stable-sort\n\n\n  this.captionPackets_.forEach(function (elem, idx) {\n    elem.presortIndex = idx;\n  }); // sort caption byte-pairs based on their PTS values\n\n  this.captionPackets_.sort(function (a, b) {\n    if (a.pts === b.pts) {\n      return a.presortIndex - b.presortIndex;\n    }\n\n    return a.pts - b.pts;\n  });\n  this.captionPackets_.forEach(function (packet) {\n    if (packet.type < 2) {\n      // Dispatch packet to the right Cea608Stream\n      this.dispatchCea608Packet(packet);\n    } else {\n      // Dispatch packet to the Cea708Stream\n      this.dispatchCea708Packet(packet);\n    }\n  }, this);\n  this.captionPackets_.length = 0;\n  this.flushCCStreams(flushType);\n};\n\nCaptionStream.prototype.flush = function () {\n  return this.flushStream('flush');\n}; // Only called if handling partial data\n\n\nCaptionStream.prototype.partialFlush = function () {\n  return this.flushStream('partialFlush');\n};\n\nCaptionStream.prototype.reset = function () {\n  this.latestDts_ = null;\n  this.ignoreNextEqualDts_ = false;\n  this.numSameDts_ = 0;\n  this.activeCea608Channel_ = [null, null];\n  this.ccStreams_.forEach(function (ccStream) {\n    ccStream.reset();\n  });\n}; // From the CEA-608 spec:\n\n/*\n * When XDS sub-packets are interleaved with other services, the end of each sub-packet shall be followed\n * by a control pair to change to a different service. When any of the control codes from 0x10 to 0x1F is\n * used to begin a control code pair, it indicates the return to captioning or Text data. The control code pair\n * and subsequent data should then be processed according to the FCC rules. It may be necessary for the\n * line 21 data encoder to automatically insert a control code pair (i.e. RCL, RU2, RU3, RU4, RDC, or RTD)\n * to switch to captioning or Text.\n*/\n// With that in mind, we ignore any data between an XDS control code and a\n// subsequent closed-captioning control code.\n\n\nCaptionStream.prototype.dispatchCea608Packet = function (packet) {\n  // NOTE: packet.type is the CEA608 field\n  if (this.setsTextOrXDSActive(packet)) {\n    this.activeCea608Channel_[packet.type] = null;\n  } else if (this.setsChannel1Active(packet)) {\n    this.activeCea608Channel_[packet.type] = 0;\n  } else if (this.setsChannel2Active(packet)) {\n    this.activeCea608Channel_[packet.type] = 1;\n  }\n\n  if (this.activeCea608Channel_[packet.type] === null) {\n    // If we haven't received anything to set the active channel, or the\n    // packets are Text/XDS data, discard the data; we don't want jumbled\n    // captions\n    return;\n  }\n\n  this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);\n};\n\nCaptionStream.prototype.setsChannel1Active = function (packet) {\n  return (packet.ccData & 0x7800) === 0x1000;\n};\n\nCaptionStream.prototype.setsChannel2Active = function (packet) {\n  return (packet.ccData & 0x7800) === 0x1800;\n};\n\nCaptionStream.prototype.setsTextOrXDSActive = function (packet) {\n  return (packet.ccData & 0x7100) === 0x0100 || (packet.ccData & 0x78fe) === 0x102a || (packet.ccData & 0x78fe) === 0x182a;\n};\n\nCaptionStream.prototype.dispatchCea708Packet = function (packet) {\n  if (this.parse708captions_) {\n    this.cc708Stream_.push(packet);\n  }\n}; // ----------------------\n// Session to Application\n// ----------------------\n// This hash maps special and extended character codes to their\n// proper Unicode equivalent. The first one-byte key is just a\n// non-standard character code. The two-byte keys that follow are\n// the extended CEA708 character codes, along with the preceding\n// 0x10 extended character byte to distinguish these codes from\n// non-extended character codes. Every CEA708 character code that\n// is not in this object maps directly to a standard unicode\n// character code.\n// The transparent space and non-breaking transparent space are\n// technically not fully supported since there is no code to\n// make them transparent, so they have normal non-transparent\n// stand-ins.\n// The special closed caption (CC) character isn't a standard\n// unicode character, so a fairly similar unicode character was\n// chosen in it's place.\n\n\nvar CHARACTER_TRANSLATION_708 = {\n  0x7f: 0x266a,\n  // ♪\n  0x1020: 0x20,\n  // Transparent Space\n  0x1021: 0xa0,\n  // Nob-breaking Transparent Space\n  0x1025: 0x2026,\n  // …\n  0x102a: 0x0160,\n  // Š\n  0x102c: 0x0152,\n  // Œ\n  0x1030: 0x2588,\n  // █\n  0x1031: 0x2018,\n  // ‘\n  0x1032: 0x2019,\n  // ’\n  0x1033: 0x201c,\n  // “\n  0x1034: 0x201d,\n  // ”\n  0x1035: 0x2022,\n  // •\n  0x1039: 0x2122,\n  // ™\n  0x103a: 0x0161,\n  // š\n  0x103c: 0x0153,\n  // œ\n  0x103d: 0x2120,\n  // ℠\n  0x103f: 0x0178,\n  // Ÿ\n  0x1076: 0x215b,\n  // ⅛\n  0x1077: 0x215c,\n  // ⅜\n  0x1078: 0x215d,\n  // ⅝\n  0x1079: 0x215e,\n  // ⅞\n  0x107a: 0x23d0,\n  // ⏐\n  0x107b: 0x23a4,\n  // ⎤\n  0x107c: 0x23a3,\n  // ⎣\n  0x107d: 0x23af,\n  // ⎯\n  0x107e: 0x23a6,\n  // ⎦\n  0x107f: 0x23a1,\n  // ⎡\n  0x10a0: 0x3138 // ㄸ (CC char)\n\n};\n\nvar get708CharFromCode = function get708CharFromCode(code) {\n  var newCode = CHARACTER_TRANSLATION_708[code] || code;\n\n  if (code & 0x1000 && code === newCode) {\n    // Invalid extended code\n    return '';\n  }\n\n  return String.fromCharCode(newCode);\n};\n\nvar within708TextBlock = function within708TextBlock(b) {\n  return 0x20 <= b && b <= 0x7f || 0xa0 <= b && b <= 0xff;\n};\n\nvar Cea708Window = function Cea708Window(windowNum) {\n  this.windowNum = windowNum;\n  this.reset();\n};\n\nCea708Window.prototype.reset = function () {\n  this.clearText();\n  this.pendingNewLine = false;\n  this.winAttr = {};\n  this.penAttr = {};\n  this.penLoc = {};\n  this.penColor = {}; // These default values are arbitrary,\n  // defineWindow will usually override them\n\n  this.visible = 0;\n  this.rowLock = 0;\n  this.columnLock = 0;\n  this.priority = 0;\n  this.relativePositioning = 0;\n  this.anchorVertical = 0;\n  this.anchorHorizontal = 0;\n  this.anchorPoint = 0;\n  this.rowCount = 1;\n  this.virtualRowCount = this.rowCount + 1;\n  this.columnCount = 41;\n  this.windowStyle = 0;\n  this.penStyle = 0;\n};\n\nCea708Window.prototype.getText = function () {\n  return this.rows.join('\\n');\n};\n\nCea708Window.prototype.clearText = function () {\n  this.rows = [''];\n  this.rowIdx = 0;\n};\n\nCea708Window.prototype.newLine = function (pts) {\n  if (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow === 'function') {\n    this.beforeRowOverflow(pts);\n  }\n\n  if (this.rows.length > 0) {\n    this.rows.push('');\n    this.rowIdx++;\n  } // Show all virtual rows since there's no visible scrolling\n\n\n  while (this.rows.length > this.virtualRowCount) {\n    this.rows.shift();\n    this.rowIdx--;\n  }\n};\n\nCea708Window.prototype.isEmpty = function () {\n  if (this.rows.length === 0) {\n    return true;\n  } else if (this.rows.length === 1) {\n    return this.rows[0] === '';\n  }\n\n  return false;\n};\n\nCea708Window.prototype.addText = function (text) {\n  this.rows[this.rowIdx] += text;\n};\n\nCea708Window.prototype.backspace = function () {\n  if (!this.isEmpty()) {\n    var row = this.rows[this.rowIdx];\n    this.rows[this.rowIdx] = row.substr(0, row.length - 1);\n  }\n};\n\nvar Cea708Service = function Cea708Service(serviceNum, encoding, stream) {\n  this.serviceNum = serviceNum;\n  this.text = '';\n  this.currentWindow = new Cea708Window(-1);\n  this.windows = [];\n  this.stream = stream; // Try to setup a TextDecoder if an `encoding` value was provided\n\n  if (typeof encoding === 'string') {\n    this.createTextDecoder(encoding);\n  }\n};\n/**\n * Initialize service windows\n * Must be run before service use\n *\n * @param  {Integer}  pts               PTS value\n * @param  {Function} beforeRowOverflow Function to execute before row overflow of a window\n */\n\n\nCea708Service.prototype.init = function (pts, beforeRowOverflow) {\n  this.startPts = pts;\n\n  for (var win = 0; win < 8; win++) {\n    this.windows[win] = new Cea708Window(win);\n\n    if (typeof beforeRowOverflow === 'function') {\n      this.windows[win].beforeRowOverflow = beforeRowOverflow;\n    }\n  }\n};\n/**\n * Set current window of service to be affected by commands\n *\n * @param  {Integer} windowNum Window number\n */\n\n\nCea708Service.prototype.setCurrentWindow = function (windowNum) {\n  this.currentWindow = this.windows[windowNum];\n};\n/**\n * Try to create a TextDecoder if it is natively supported\n */\n\n\nCea708Service.prototype.createTextDecoder = function (encoding) {\n  if (typeof TextDecoder === 'undefined') {\n    this.stream.trigger('log', {\n      level: 'warn',\n      message: 'The `encoding` option is unsupported without TextDecoder support'\n    });\n  } else {\n    try {\n      this.textDecoder_ = new TextDecoder(encoding);\n    } catch (error) {\n      this.stream.trigger('log', {\n        level: 'warn',\n        message: 'TextDecoder could not be created with ' + encoding + ' encoding. ' + error\n      });\n    }\n  }\n};\n\nvar Cea708Stream = function Cea708Stream(options) {\n  options = options || {};\n  Cea708Stream.prototype.init.call(this);\n  var self = this;\n  var captionServices = options.captionServices || {};\n  var captionServiceEncodings = {};\n  var serviceProps; // Get service encodings from captionServices option block\n\n  Object.keys(captionServices).forEach(function (serviceName) {\n    serviceProps = captionServices[serviceName];\n\n    if (/^SERVICE/.test(serviceName)) {\n      captionServiceEncodings[serviceName] = serviceProps.encoding;\n    }\n  });\n  this.serviceEncodings = captionServiceEncodings;\n  this.current708Packet = null;\n  this.services = {};\n\n  this.push = function (packet) {\n    if (packet.type === 3) {\n      // 708 packet start\n      self.new708Packet();\n      self.add708Bytes(packet);\n    } else {\n      if (self.current708Packet === null) {\n        // This should only happen at the start of a file if there's no packet start.\n        self.new708Packet();\n      }\n\n      self.add708Bytes(packet);\n    }\n  };\n};\n\nCea708Stream.prototype = new Stream();\n/**\n * Push current 708 packet, create new 708 packet.\n */\n\nCea708Stream.prototype.new708Packet = function () {\n  if (this.current708Packet !== null) {\n    this.push708Packet();\n  }\n\n  this.current708Packet = {\n    data: [],\n    ptsVals: []\n  };\n};\n/**\n * Add pts and both bytes from packet into current 708 packet.\n */\n\n\nCea708Stream.prototype.add708Bytes = function (packet) {\n  var data = packet.ccData;\n  var byte0 = data >>> 8;\n  var byte1 = data & 0xff; // I would just keep a list of packets instead of bytes, but it isn't clear in the spec\n  // that service blocks will always line up with byte pairs.\n\n  this.current708Packet.ptsVals.push(packet.pts);\n  this.current708Packet.data.push(byte0);\n  this.current708Packet.data.push(byte1);\n};\n/**\n * Parse completed 708 packet into service blocks and push each service block.\n */\n\n\nCea708Stream.prototype.push708Packet = function () {\n  var packet708 = this.current708Packet;\n  var packetData = packet708.data;\n  var serviceNum = null;\n  var blockSize = null;\n  var i = 0;\n  var b = packetData[i++];\n  packet708.seq = b >> 6;\n  packet708.sizeCode = b & 0x3f; // 0b00111111;\n\n  for (; i < packetData.length; i++) {\n    b = packetData[i++];\n    serviceNum = b >> 5;\n    blockSize = b & 0x1f; // 0b00011111\n\n    if (serviceNum === 7 && blockSize > 0) {\n      // Extended service num\n      b = packetData[i++];\n      serviceNum = b;\n    }\n\n    this.pushServiceBlock(serviceNum, i, blockSize);\n\n    if (blockSize > 0) {\n      i += blockSize - 1;\n    }\n  }\n};\n/**\n * Parse service block, execute commands, read text.\n *\n * Note: While many of these commands serve important purposes,\n * many others just parse out the parameters or attributes, but\n * nothing is done with them because this is not a full and complete\n * implementation of the entire 708 spec.\n *\n * @param  {Integer} serviceNum Service number\n * @param  {Integer} start      Start index of the 708 packet data\n * @param  {Integer} size       Block size\n */\n\n\nCea708Stream.prototype.pushServiceBlock = function (serviceNum, start, size) {\n  var b;\n  var i = start;\n  var packetData = this.current708Packet.data;\n  var service = this.services[serviceNum];\n\n  if (!service) {\n    service = this.initService(serviceNum, i);\n  }\n\n  for (; i < start + size && i < packetData.length; i++) {\n    b = packetData[i];\n\n    if (within708TextBlock(b)) {\n      i = this.handleText(i, service);\n    } else if (b === 0x18) {\n      i = this.multiByteCharacter(i, service);\n    } else if (b === 0x10) {\n      i = this.extendedCommands(i, service);\n    } else if (0x80 <= b && b <= 0x87) {\n      i = this.setCurrentWindow(i, service);\n    } else if (0x98 <= b && b <= 0x9f) {\n      i = this.defineWindow(i, service);\n    } else if (b === 0x88) {\n      i = this.clearWindows(i, service);\n    } else if (b === 0x8c) {\n      i = this.deleteWindows(i, service);\n    } else if (b === 0x89) {\n      i = this.displayWindows(i, service);\n    } else if (b === 0x8a) {\n      i = this.hideWindows(i, service);\n    } else if (b === 0x8b) {\n      i = this.toggleWindows(i, service);\n    } else if (b === 0x97) {\n      i = this.setWindowAttributes(i, service);\n    } else if (b === 0x90) {\n      i = this.setPenAttributes(i, service);\n    } else if (b === 0x91) {\n      i = this.setPenColor(i, service);\n    } else if (b === 0x92) {\n      i = this.setPenLocation(i, service);\n    } else if (b === 0x8f) {\n      service = this.reset(i, service);\n    } else if (b === 0x08) {\n      // BS: Backspace\n      service.currentWindow.backspace();\n    } else if (b === 0x0c) {\n      // FF: Form feed\n      service.currentWindow.clearText();\n    } else if (b === 0x0d) {\n      // CR: Carriage return\n      service.currentWindow.pendingNewLine = true;\n    } else if (b === 0x0e) {\n      // HCR: Horizontal carriage return\n      service.currentWindow.clearText();\n    } else if (b === 0x8d) {\n      // DLY: Delay, nothing to do\n      i++;\n    } else if (b === 0x8e) {// DLC: Delay cancel, nothing to do\n    } else if (b === 0x03) {// ETX: End Text, don't need to do anything\n    } else if (b === 0x00) {// Padding\n    } else {// Unknown command\n      }\n  }\n};\n/**\n * Execute an extended command\n *\n * @param  {Integer} i        Current index in the 708 packet\n * @param  {Service} service  The service object to be affected\n * @return {Integer}          New index after parsing\n */\n\n\nCea708Stream.prototype.extendedCommands = function (i, service) {\n  var packetData = this.current708Packet.data;\n  var b = packetData[++i];\n\n  if (within708TextBlock(b)) {\n    i = this.handleText(i, service, {\n      isExtended: true\n    });\n  } else {// Unknown command\n  }\n\n  return i;\n};\n/**\n * Get PTS value of a given byte index\n *\n * @param  {Integer} byteIndex  Index of the byte\n * @return {Integer}            PTS\n */\n\n\nCea708Stream.prototype.getPts = function (byteIndex) {\n  // There's 1 pts value per 2 bytes\n  return this.current708Packet.ptsVals[Math.floor(byteIndex / 2)];\n};\n/**\n * Initializes a service\n *\n * @param  {Integer} serviceNum Service number\n * @return {Service}            Initialized service object\n */\n\n\nCea708Stream.prototype.initService = function (serviceNum, i) {\n  var serviceName = 'SERVICE' + serviceNum;\n  var self = this;\n  var serviceName;\n  var encoding;\n\n  if (serviceName in this.serviceEncodings) {\n    encoding = this.serviceEncodings[serviceName];\n  }\n\n  this.services[serviceNum] = new Cea708Service(serviceNum, encoding, self);\n  this.services[serviceNum].init(this.getPts(i), function (pts) {\n    self.flushDisplayed(pts, self.services[serviceNum]);\n  });\n  return this.services[serviceNum];\n};\n/**\n * Execute text writing to current window\n *\n * @param  {Integer} i        Current index in the 708 packet\n * @param  {Service} service  The service object to be affected\n * @return {Integer}          New index after parsing\n */\n\n\nCea708Stream.prototype.handleText = function (i, service, options) {\n  var isExtended = options && options.isExtended;\n  var isMultiByte = options && options.isMultiByte;\n  var packetData = this.current708Packet.data;\n  var extended = isExtended ? 0x1000 : 0x0000;\n  var currentByte = packetData[i];\n  var nextByte = packetData[i + 1];\n  var win = service.currentWindow;\n  var char;\n  var charCodeArray; // Use the TextDecoder if one was created for this service\n\n  if (service.textDecoder_ && !isExtended) {\n    if (isMultiByte) {\n      charCodeArray = [currentByte, nextByte];\n      i++;\n    } else {\n      charCodeArray = [currentByte];\n    }\n\n    char = service.textDecoder_.decode(new Uint8Array(charCodeArray));\n  } else {\n    char = get708CharFromCode(extended | currentByte);\n  }\n\n  if (win.pendingNewLine && !win.isEmpty()) {\n    win.newLine(this.getPts(i));\n  }\n\n  win.pendingNewLine = false;\n  win.addText(char);\n  return i;\n};\n/**\n * Handle decoding of multibyte character\n *\n * @param  {Integer} i        Current index in the 708 packet\n * @param  {Service} service  The service object to be affected\n * @return {Integer}          New index after parsing\n */\n\n\nCea708Stream.prototype.multiByteCharacter = function (i, service) {\n  var packetData = this.current708Packet.data;\n  var firstByte = packetData[i + 1];\n  var secondByte = packetData[i + 2];\n\n  if (within708TextBlock(firstByte) && within708TextBlock(secondByte)) {\n    i = this.handleText(++i, service, {\n      isMultiByte: true\n    });\n  } else {// Unknown command\n  }\n\n  return i;\n};\n/**\n * Parse and execute the CW# command.\n *\n * Set the current window.\n *\n * @param  {Integer} i        Current index in the 708 packet\n * @param  {Service} service  The service object to be affected\n * @return {Integer}          New index after parsing\n */\n\n\nCea708Stream.prototype.setCurrentWindow = function (i, service) {\n  var packetData = this.current708Packet.data;\n  var b = packetData[i];\n  var windowNum = b & 0x07;\n  service.setCurrentWindow(windowNum);\n  return i;\n};\n/**\n * Parse and execute the DF# command.\n *\n * Define a window and set it as the current window.\n *\n * @param  {Integer} i        Current index in the 708 packet\n * @param  {Service} service  The service object to be affected\n * @return {Integer}          New index after parsing\n */\n\n\nCea708Stream.prototype.defineWindow = function (i, service) {\n  var packetData = this.current708Packet.data;\n  var b = packetData[i];\n  var windowNum = b & 0x07;\n  service.setCurrentWindow(windowNum);\n  var win = service.currentWindow;\n  b = packetData[++i];\n  win.visible = (b & 0x20) >> 5; // v\n\n  win.rowLock = (b & 0x10) >> 4; // rl\n\n  win.columnLock = (b & 0x08) >> 3; // cl\n\n  win.priority = b & 0x07; // p\n\n  b = packetData[++i];\n  win.relativePositioning = (b & 0x80) >> 7; // rp\n\n  win.anchorVertical = b & 0x7f; // av\n\n  b = packetData[++i];\n  win.anchorHorizontal = b; // ah\n\n  b = packetData[++i];\n  win.anchorPoint = (b & 0xf0) >> 4; // ap\n\n  win.rowCount = b & 0x0f; // rc\n\n  b = packetData[++i];\n  win.columnCount = b & 0x3f; // cc\n\n  b = packetData[++i];\n  win.windowStyle = (b & 0x38) >> 3; // ws\n\n  win.penStyle = b & 0x07; // ps\n  // The spec says there are (rowCount+1) \"virtual rows\"\n\n  win.virtualRowCount = win.rowCount + 1;\n  return i;\n};\n/**\n * Parse and execute the SWA command.\n *\n * Set attributes of the current window.\n *\n * @param  {Integer} i        Current index in the 708 packet\n * @param  {Service} service  The service object to be affected\n * @return {Integer}          New index after parsing\n */\n\n\nCea708Stream.prototype.setWindowAttributes = function (i, service) {\n  var packetData = this.current708Packet.data;\n  var b = packetData[i];\n  var winAttr = service.currentWindow.winAttr;\n  b = packetData[++i];\n  winAttr.fillOpacity = (b & 0xc0) >> 6; // fo\n\n  winAttr.fillRed = (b & 0x30) >> 4; // fr\n\n  winAttr.fillGreen = (b & 0x0c) >> 2; // fg\n\n  winAttr.fillBlue = b & 0x03; // fb\n\n  b = packetData[++i];\n  winAttr.borderType = (b & 0xc0) >> 6; // bt\n\n  winAttr.borderRed = (b & 0x30) >> 4; // br\n\n  winAttr.borderGreen = (b & 0x0c) >> 2; // bg\n\n  winAttr.borderBlue = b & 0x03; // bb\n\n  b = packetData[++i];\n  winAttr.borderType += (b & 0x80) >> 5; // bt\n\n  winAttr.wordWrap = (b & 0x40) >> 6; // ww\n\n  winAttr.printDirection = (b & 0x30) >> 4; // pd\n\n  winAttr.scrollDirection = (b & 0x0c) >> 2; // sd\n\n  winAttr.justify = b & 0x03; // j\n\n  b = packetData[++i];\n  winAttr.effectSpeed = (b & 0xf0) >> 4; // es\n\n  winAttr.effectDirection = (b & 0x0c) >> 2; // ed\n\n  winAttr.displayEffect = b & 0x03; // de\n\n  return i;\n};\n/**\n * Gather text from all displayed windows and push a caption to output.\n *\n * @param  {Integer} i        Current index in the 708 packet\n * @param  {Service} service  The service object to be affected\n */\n\n\nCea708Stream.prototype.flushDisplayed = function (pts, service) {\n  var displayedText = []; // TODO: Positioning not supported, displaying multiple windows will not necessarily\n  // display text in the correct order, but sample files so far have not shown any issue.\n\n  for (var winId = 0; winId < 8; winId++) {\n    if (service.windows[winId].visible && !service.windows[winId].isEmpty()) {\n      displayedText.push(service.windows[winId].getText());\n    }\n  }\n\n  service.endPts = pts;\n  service.text = displayedText.join('\\n\\n');\n  this.pushCaption(service);\n  service.startPts = pts;\n};\n/**\n * Push a caption to output if the caption contains text.\n *\n * @param  {Service} service  The service object to be affected\n */\n\n\nCea708Stream.prototype.pushCaption = function (service) {\n  if (service.text !== '') {\n    this.trigger('data', {\n      startPts: service.startPts,\n      endPts: service.endPts,\n      text: service.text,\n      stream: 'cc708_' + service.serviceNum\n    });\n    service.text = '';\n    service.startPts = service.endPts;\n  }\n};\n/**\n * Parse and execute the DSW command.\n *\n * Set visible property of windows based on the parsed bitmask.\n *\n * @param  {Integer} i        Current index in the 708 packet\n * @param  {Service} service  The service object to be affected\n * @return {Integer}          New index after parsing\n */\n\n\nCea708Stream.prototype.displayWindows = function (i, service) {\n  var packetData = this.current708Packet.data;\n  var b = packetData[++i];\n  var pts = this.getPts(i);\n  this.flushDisplayed(pts, service);\n\n  for (var winId = 0; winId < 8; winId++) {\n    if (b & 0x01 << winId) {\n      service.windows[winId].visible = 1;\n    }\n  }\n\n  return i;\n};\n/**\n * Parse and execute the HDW command.\n *\n * Set visible property of windows based on the parsed bitmask.\n *\n * @param  {Integer} i        Current index in the 708 packet\n * @param  {Service} service  The service object to be affected\n * @return {Integer}          New index after parsing\n */\n\n\nCea708Stream.prototype.hideWindows = function (i, service) {\n  var packetData = this.current708Packet.data;\n  var b = packetData[++i];\n  var pts = this.getPts(i);\n  this.flushDisplayed(pts, service);\n\n  for (var winId = 0; winId < 8; winId++) {\n    if (b & 0x01 << winId) {\n      service.windows[winId].visible = 0;\n    }\n  }\n\n  return i;\n};\n/**\n * Parse and execute the TGW command.\n *\n * Set visible property of windows based on the parsed bitmask.\n *\n * @param  {Integer} i        Current index in the 708 packet\n * @param  {Service} service  The service object to be affected\n * @return {Integer}          New index after parsing\n */\n\n\nCea708Stream.prototype.toggleWindows = function (i, service) {\n  var packetData = this.current708Packet.data;\n  var b = packetData[++i];\n  var pts = this.getPts(i);\n  this.flushDisplayed(pts, service);\n\n  for (var winId = 0; winId < 8; winId++) {\n    if (b & 0x01 << winId) {\n      service.windows[winId].visible ^= 1;\n    }\n  }\n\n  return i;\n};\n/**\n * Parse and execute the CLW command.\n *\n * Clear text of windows based on the parsed bitmask.\n *\n * @param  {Integer} i        Current index in the 708 packet\n * @param  {Service} service  The service object to be affected\n * @return {Integer}          New index after parsing\n */\n\n\nCea708Stream.prototype.clearWindows = function (i, service) {\n  var packetData = this.current708Packet.data;\n  var b = packetData[++i];\n  var pts = this.getPts(i);\n  this.flushDisplayed(pts, service);\n\n  for (var winId = 0; winId < 8; winId++) {\n    if (b & 0x01 << winId) {\n      service.windows[winId].clearText();\n    }\n  }\n\n  return i;\n};\n/**\n * Parse and execute the DLW command.\n *\n * Re-initialize windows based on the parsed bitmask.\n *\n * @param  {Integer} i        Current index in the 708 packet\n * @param  {Service} service  The service object to be affected\n * @return {Integer}          New index after parsing\n */\n\n\nCea708Stream.prototype.deleteWindows = function (i, service) {\n  var packetData = this.current708Packet.data;\n  var b = packetData[++i];\n  var pts = this.getPts(i);\n  this.flushDisplayed(pts, service);\n\n  for (var winId = 0; winId < 8; winId++) {\n    if (b & 0x01 << winId) {\n      service.windows[winId].reset();\n    }\n  }\n\n  return i;\n};\n/**\n * Parse and execute the SPA command.\n *\n * Set pen attributes of the current window.\n *\n * @param  {Integer} i        Current index in the 708 packet\n * @param  {Service} service  The service object to be affected\n * @return {Integer}          New index after parsing\n */\n\n\nCea708Stream.prototype.setPenAttributes = function (i, service) {\n  var packetData = this.current708Packet.data;\n  var b = packetData[i];\n  var penAttr = service.currentWindow.penAttr;\n  b = packetData[++i];\n  penAttr.textTag = (b & 0xf0) >> 4; // tt\n\n  penAttr.offset = (b & 0x0c) >> 2; // o\n\n  penAttr.penSize = b & 0x03; // s\n\n  b = packetData[++i];\n  penAttr.italics = (b & 0x80) >> 7; // i\n\n  penAttr.underline = (b & 0x40) >> 6; // u\n\n  penAttr.edgeType = (b & 0x38) >> 3; // et\n\n  penAttr.fontStyle = b & 0x07; // fs\n\n  return i;\n};\n/**\n * Parse and execute the SPC command.\n *\n * Set pen color of the current window.\n *\n * @param  {Integer} i        Current index in the 708 packet\n * @param  {Service} service  The service object to be affected\n * @return {Integer}          New index after parsing\n */\n\n\nCea708Stream.prototype.setPenColor = function (i, service) {\n  var packetData = this.current708Packet.data;\n  var b = packetData[i];\n  var penColor = service.currentWindow.penColor;\n  b = packetData[++i];\n  penColor.fgOpacity = (b & 0xc0) >> 6; // fo\n\n  penColor.fgRed = (b & 0x30) >> 4; // fr\n\n  penColor.fgGreen = (b & 0x0c) >> 2; // fg\n\n  penColor.fgBlue = b & 0x03; // fb\n\n  b = packetData[++i];\n  penColor.bgOpacity = (b & 0xc0) >> 6; // bo\n\n  penColor.bgRed = (b & 0x30) >> 4; // br\n\n  penColor.bgGreen = (b & 0x0c) >> 2; // bg\n\n  penColor.bgBlue = b & 0x03; // bb\n\n  b = packetData[++i];\n  penColor.edgeRed = (b & 0x30) >> 4; // er\n\n  penColor.edgeGreen = (b & 0x0c) >> 2; // eg\n\n  penColor.edgeBlue = b & 0x03; // eb\n\n  return i;\n};\n/**\n * Parse and execute the SPL command.\n *\n * Set pen location of the current window.\n *\n * @param  {Integer} i        Current index in the 708 packet\n * @param  {Service} service  The service object to be affected\n * @return {Integer}          New index after parsing\n */\n\n\nCea708Stream.prototype.setPenLocation = function (i, service) {\n  var packetData = this.current708Packet.data;\n  var b = packetData[i];\n  var penLoc = service.currentWindow.penLoc; // Positioning isn't really supported at the moment, so this essentially just inserts a linebreak\n\n  service.currentWindow.pendingNewLine = true;\n  b = packetData[++i];\n  penLoc.row = b & 0x0f; // r\n\n  b = packetData[++i];\n  penLoc.column = b & 0x3f; // c\n\n  return i;\n};\n/**\n * Execute the RST command.\n *\n * Reset service to a clean slate. Re-initialize.\n *\n * @param  {Integer} i        Current index in the 708 packet\n * @param  {Service} service  The service object to be affected\n * @return {Service}          Re-initialized service\n */\n\n\nCea708Stream.prototype.reset = function (i, service) {\n  var pts = this.getPts(i);\n  this.flushDisplayed(pts, service);\n  return this.initService(service.serviceNum, i);\n}; // This hash maps non-ASCII, special, and extended character codes to their\n// proper Unicode equivalent. The first keys that are only a single byte\n// are the non-standard ASCII characters, which simply map the CEA608 byte\n// to the standard ASCII/Unicode. The two-byte keys that follow are the CEA608\n// character codes, but have their MSB bitmasked with 0x03 so that a lookup\n// can be performed regardless of the field and data channel on which the\n// character code was received.\n\n\nvar CHARACTER_TRANSLATION = {\n  0x2a: 0xe1,\n  // á\n  0x5c: 0xe9,\n  // é\n  0x5e: 0xed,\n  // í\n  0x5f: 0xf3,\n  // ó\n  0x60: 0xfa,\n  // ú\n  0x7b: 0xe7,\n  // ç\n  0x7c: 0xf7,\n  // ÷\n  0x7d: 0xd1,\n  // Ñ\n  0x7e: 0xf1,\n  // ñ\n  0x7f: 0x2588,\n  // █\n  0x0130: 0xae,\n  // ®\n  0x0131: 0xb0,\n  // °\n  0x0132: 0xbd,\n  // ½\n  0x0133: 0xbf,\n  // ¿\n  0x0134: 0x2122,\n  // ™\n  0x0135: 0xa2,\n  // ¢\n  0x0136: 0xa3,\n  // £\n  0x0137: 0x266a,\n  // ♪\n  0x0138: 0xe0,\n  // à\n  0x0139: 0xa0,\n  //\n  0x013a: 0xe8,\n  // è\n  0x013b: 0xe2,\n  // â\n  0x013c: 0xea,\n  // ê\n  0x013d: 0xee,\n  // î\n  0x013e: 0xf4,\n  // ô\n  0x013f: 0xfb,\n  // û\n  0x0220: 0xc1,\n  // Á\n  0x0221: 0xc9,\n  // É\n  0x0222: 0xd3,\n  // Ó\n  0x0223: 0xda,\n  // Ú\n  0x0224: 0xdc,\n  // Ü\n  0x0225: 0xfc,\n  // ü\n  0x0226: 0x2018,\n  // ‘\n  0x0227: 0xa1,\n  // ¡\n  0x0228: 0x2a,\n  // *\n  0x0229: 0x27,\n  // '\n  0x022a: 0x2014,\n  // —\n  0x022b: 0xa9,\n  // ©\n  0x022c: 0x2120,\n  // ℠\n  0x022d: 0x2022,\n  // •\n  0x022e: 0x201c,\n  // “\n  0x022f: 0x201d,\n  // ”\n  0x0230: 0xc0,\n  // À\n  0x0231: 0xc2,\n  // Â\n  0x0232: 0xc7,\n  // Ç\n  0x0233: 0xc8,\n  // È\n  0x0234: 0xca,\n  // Ê\n  0x0235: 0xcb,\n  // Ë\n  0x0236: 0xeb,\n  // ë\n  0x0237: 0xce,\n  // Î\n  0x0238: 0xcf,\n  // Ï\n  0x0239: 0xef,\n  // ï\n  0x023a: 0xd4,\n  // Ô\n  0x023b: 0xd9,\n  // Ù\n  0x023c: 0xf9,\n  // ù\n  0x023d: 0xdb,\n  // Û\n  0x023e: 0xab,\n  // «\n  0x023f: 0xbb,\n  // »\n  0x0320: 0xc3,\n  // Ã\n  0x0321: 0xe3,\n  // ã\n  0x0322: 0xcd,\n  // Í\n  0x0323: 0xcc,\n  // Ì\n  0x0324: 0xec,\n  // ì\n  0x0325: 0xd2,\n  // Ò\n  0x0326: 0xf2,\n  // ò\n  0x0327: 0xd5,\n  // Õ\n  0x0328: 0xf5,\n  // õ\n  0x0329: 0x7b,\n  // {\n  0x032a: 0x7d,\n  // }\n  0x032b: 0x5c,\n  // \\\n  0x032c: 0x5e,\n  // ^\n  0x032d: 0x5f,\n  // _\n  0x032e: 0x7c,\n  // |\n  0x032f: 0x7e,\n  // ~\n  0x0330: 0xc4,\n  // Ä\n  0x0331: 0xe4,\n  // ä\n  0x0332: 0xd6,\n  // Ö\n  0x0333: 0xf6,\n  // ö\n  0x0334: 0xdf,\n  // ß\n  0x0335: 0xa5,\n  // ¥\n  0x0336: 0xa4,\n  // ¤\n  0x0337: 0x2502,\n  // │\n  0x0338: 0xc5,\n  // Å\n  0x0339: 0xe5,\n  // å\n  0x033a: 0xd8,\n  // Ø\n  0x033b: 0xf8,\n  // ø\n  0x033c: 0x250c,\n  // ┌\n  0x033d: 0x2510,\n  // ┐\n  0x033e: 0x2514,\n  // └\n  0x033f: 0x2518 // ┘\n\n};\n\nvar getCharFromCode = function getCharFromCode(code) {\n  if (code === null) {\n    return '';\n  }\n\n  code = CHARACTER_TRANSLATION[code] || code;\n  return String.fromCharCode(code);\n}; // the index of the last row in a CEA-608 display buffer\n\n\nvar BOTTOM_ROW = 14; // This array is used for mapping PACs -> row #, since there's no way of\n// getting it through bit logic.\n\nvar ROWS = [0x1100, 0x1120, 0x1200, 0x1220, 0x1500, 0x1520, 0x1600, 0x1620, 0x1700, 0x1720, 0x1000, 0x1300, 0x1320, 0x1400, 0x1420]; // CEA-608 captions are rendered onto a 34x15 matrix of character\n// cells. The \"bottom\" row is the last element in the outer array.\n\nvar createDisplayBuffer = function createDisplayBuffer() {\n  var result = [],\n      i = BOTTOM_ROW + 1;\n\n  while (i--) {\n    result.push('');\n  }\n\n  return result;\n};\n\nvar Cea608Stream = function Cea608Stream(field, dataChannel) {\n  Cea608Stream.prototype.init.call(this);\n  this.field_ = field || 0;\n  this.dataChannel_ = dataChannel || 0;\n  this.name_ = 'CC' + ((this.field_ << 1 | this.dataChannel_) + 1);\n  this.setConstants();\n  this.reset();\n\n  this.push = function (packet) {\n    var data, swap, char0, char1, text; // remove the parity bits\n\n    data = packet.ccData & 0x7f7f; // ignore duplicate control codes; the spec demands they're sent twice\n\n    if (data === this.lastControlCode_) {\n      this.lastControlCode_ = null;\n      return;\n    } // Store control codes\n\n\n    if ((data & 0xf000) === 0x1000) {\n      this.lastControlCode_ = data;\n    } else if (data !== this.PADDING_) {\n      this.lastControlCode_ = null;\n    }\n\n    char0 = data >>> 8;\n    char1 = data & 0xff;\n\n    if (data === this.PADDING_) {\n      return;\n    } else if (data === this.RESUME_CAPTION_LOADING_) {\n      this.mode_ = 'popOn';\n    } else if (data === this.END_OF_CAPTION_) {\n      // If an EOC is received while in paint-on mode, the displayed caption\n      // text should be swapped to non-displayed memory as if it was a pop-on\n      // caption. Because of that, we should explicitly switch back to pop-on\n      // mode\n      this.mode_ = 'popOn';\n      this.clearFormatting(packet.pts); // if a caption was being displayed, it's gone now\n\n      this.flushDisplayed(packet.pts); // flip memory\n\n      swap = this.displayed_;\n      this.displayed_ = this.nonDisplayed_;\n      this.nonDisplayed_ = swap; // start measuring the time to display the caption\n\n      this.startPts_ = packet.pts;\n    } else if (data === this.ROLL_UP_2_ROWS_) {\n      this.rollUpRows_ = 2;\n      this.setRollUp(packet.pts);\n    } else if (data === this.ROLL_UP_3_ROWS_) {\n      this.rollUpRows_ = 3;\n      this.setRollUp(packet.pts);\n    } else if (data === this.ROLL_UP_4_ROWS_) {\n      this.rollUpRows_ = 4;\n      this.setRollUp(packet.pts);\n    } else if (data === this.CARRIAGE_RETURN_) {\n      this.clearFormatting(packet.pts);\n      this.flushDisplayed(packet.pts);\n      this.shiftRowsUp_();\n      this.startPts_ = packet.pts;\n    } else if (data === this.BACKSPACE_) {\n      if (this.mode_ === 'popOn') {\n        this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n      } else {\n        this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n      }\n    } else if (data === this.ERASE_DISPLAYED_MEMORY_) {\n      this.flushDisplayed(packet.pts);\n      this.displayed_ = createDisplayBuffer();\n    } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {\n      this.nonDisplayed_ = createDisplayBuffer();\n    } else if (data === this.RESUME_DIRECT_CAPTIONING_) {\n      if (this.mode_ !== 'paintOn') {\n        // NOTE: This should be removed when proper caption positioning is\n        // implemented\n        this.flushDisplayed(packet.pts);\n        this.displayed_ = createDisplayBuffer();\n      }\n\n      this.mode_ = 'paintOn';\n      this.startPts_ = packet.pts; // Append special characters to caption text\n    } else if (this.isSpecialCharacter(char0, char1)) {\n      // Bitmask char0 so that we can apply character transformations\n      // regardless of field and data channel.\n      // Then byte-shift to the left and OR with char1 so we can pass the\n      // entire character code to `getCharFromCode`.\n      char0 = (char0 & 0x03) << 8;\n      text = getCharFromCode(char0 | char1);\n      this[this.mode_](packet.pts, text);\n      this.column_++; // Append extended characters to caption text\n    } else if (this.isExtCharacter(char0, char1)) {\n      // Extended characters always follow their \"non-extended\" equivalents.\n      // IE if a \"è\" is desired, you'll always receive \"eè\"; non-compliant\n      // decoders are supposed to drop the \"è\", while compliant decoders\n      // backspace the \"e\" and insert \"è\".\n      // Delete the previous character\n      if (this.mode_ === 'popOn') {\n        this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n      } else {\n        this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n      } // Bitmask char0 so that we can apply character transformations\n      // regardless of field and data channel.\n      // Then byte-shift to the left and OR with char1 so we can pass the\n      // entire character code to `getCharFromCode`.\n\n\n      char0 = (char0 & 0x03) << 8;\n      text = getCharFromCode(char0 | char1);\n      this[this.mode_](packet.pts, text);\n      this.column_++; // Process mid-row codes\n    } else if (this.isMidRowCode(char0, char1)) {\n      // Attributes are not additive, so clear all formatting\n      this.clearFormatting(packet.pts); // According to the standard, mid-row codes\n      // should be replaced with spaces, so add one now\n\n      this[this.mode_](packet.pts, ' ');\n      this.column_++;\n\n      if ((char1 & 0xe) === 0xe) {\n        this.addFormatting(packet.pts, ['i']);\n      }\n\n      if ((char1 & 0x1) === 0x1) {\n        this.addFormatting(packet.pts, ['u']);\n      } // Detect offset control codes and adjust cursor\n\n    } else if (this.isOffsetControlCode(char0, char1)) {\n      // Cursor position is set by indent PAC (see below) in 4-column\n      // increments, with an additional offset code of 1-3 to reach any\n      // of the 32 columns specified by CEA-608. So all we need to do\n      // here is increment the column cursor by the given offset.\n      this.column_ += char1 & 0x03; // Detect PACs (Preamble Address Codes)\n    } else if (this.isPAC(char0, char1)) {\n      // There's no logic for PAC -> row mapping, so we have to just\n      // find the row code in an array and use its index :(\n      var row = ROWS.indexOf(data & 0x1f20); // Configure the caption window if we're in roll-up mode\n\n      if (this.mode_ === 'rollUp') {\n        // This implies that the base row is incorrectly set.\n        // As per the recommendation in CEA-608(Base Row Implementation), defer to the number\n        // of roll-up rows set.\n        if (row - this.rollUpRows_ + 1 < 0) {\n          row = this.rollUpRows_ - 1;\n        }\n\n        this.setRollUp(packet.pts, row);\n      }\n\n      if (row !== this.row_) {\n        // formatting is only persistent for current row\n        this.clearFormatting(packet.pts);\n        this.row_ = row;\n      } // All PACs can apply underline, so detect and apply\n      // (All odd-numbered second bytes set underline)\n\n\n      if (char1 & 0x1 && this.formatting_.indexOf('u') === -1) {\n        this.addFormatting(packet.pts, ['u']);\n      }\n\n      if ((data & 0x10) === 0x10) {\n        // We've got an indent level code. Each successive even number\n        // increments the column cursor by 4, so we can get the desired\n        // column position by bit-shifting to the right (to get n/2)\n        // and multiplying by 4.\n        this.column_ = ((data & 0xe) >> 1) * 4;\n      }\n\n      if (this.isColorPAC(char1)) {\n        // it's a color code, though we only support white, which\n        // can be either normal or italicized. white italics can be\n        // either 0x4e or 0x6e depending on the row, so we just\n        // bitwise-and with 0xe to see if italics should be turned on\n        if ((char1 & 0xe) === 0xe) {\n          this.addFormatting(packet.pts, ['i']);\n        }\n      } // We have a normal character in char0, and possibly one in char1\n\n    } else if (this.isNormalChar(char0)) {\n      if (char1 === 0x00) {\n        char1 = null;\n      }\n\n      text = getCharFromCode(char0);\n      text += getCharFromCode(char1);\n      this[this.mode_](packet.pts, text);\n      this.column_ += text.length;\n    } // finish data processing\n\n  };\n};\n\nCea608Stream.prototype = new Stream(); // Trigger a cue point that captures the current state of the\n// display buffer\n\nCea608Stream.prototype.flushDisplayed = function (pts) {\n  var content = this.displayed_ // remove spaces from the start and end of the string\n  .map(function (row, index) {\n    try {\n      return row.trim();\n    } catch (e) {\n      // Ordinarily, this shouldn't happen. However, caption\n      // parsing errors should not throw exceptions and\n      // break playback.\n      this.trigger('log', {\n        level: 'warn',\n        message: 'Skipping a malformed 608 caption at index ' + index + '.'\n      });\n      return '';\n    }\n  }, this) // combine all text rows to display in one cue\n  .join('\\n') // and remove blank rows from the start and end, but not the middle\n  .replace(/^\\n+|\\n+$/g, '');\n\n  if (content.length) {\n    this.trigger('data', {\n      startPts: this.startPts_,\n      endPts: pts,\n      text: content,\n      stream: this.name_\n    });\n  }\n};\n/**\n * Zero out the data, used for startup and on seek\n */\n\n\nCea608Stream.prototype.reset = function () {\n  this.mode_ = 'popOn'; // When in roll-up mode, the index of the last row that will\n  // actually display captions. If a caption is shifted to a row\n  // with a lower index than this, it is cleared from the display\n  // buffer\n\n  this.topRow_ = 0;\n  this.startPts_ = 0;\n  this.displayed_ = createDisplayBuffer();\n  this.nonDisplayed_ = createDisplayBuffer();\n  this.lastControlCode_ = null; // Track row and column for proper line-breaking and spacing\n\n  this.column_ = 0;\n  this.row_ = BOTTOM_ROW;\n  this.rollUpRows_ = 2; // This variable holds currently-applied formatting\n\n  this.formatting_ = [];\n};\n/**\n * Sets up control code and related constants for this instance\n */\n\n\nCea608Stream.prototype.setConstants = function () {\n  // The following attributes have these uses:\n  // ext_ :    char0 for mid-row codes, and the base for extended\n  //           chars (ext_+0, ext_+1, and ext_+2 are char0s for\n  //           extended codes)\n  // control_: char0 for control codes, except byte-shifted to the\n  //           left so that we can do this.control_ | CONTROL_CODE\n  // offset_:  char0 for tab offset codes\n  //\n  // It's also worth noting that control codes, and _only_ control codes,\n  // differ between field 1 and field2. Field 2 control codes are always\n  // their field 1 value plus 1. That's why there's the \"| field\" on the\n  // control value.\n  if (this.dataChannel_ === 0) {\n    this.BASE_ = 0x10;\n    this.EXT_ = 0x11;\n    this.CONTROL_ = (0x14 | this.field_) << 8;\n    this.OFFSET_ = 0x17;\n  } else if (this.dataChannel_ === 1) {\n    this.BASE_ = 0x18;\n    this.EXT_ = 0x19;\n    this.CONTROL_ = (0x1c | this.field_) << 8;\n    this.OFFSET_ = 0x1f;\n  } // Constants for the LSByte command codes recognized by Cea608Stream. This\n  // list is not exhaustive. For a more comprehensive listing and semantics see\n  // http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\n  // Padding\n\n\n  this.PADDING_ = 0x0000; // Pop-on Mode\n\n  this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 0x20;\n  this.END_OF_CAPTION_ = this.CONTROL_ | 0x2f; // Roll-up Mode\n\n  this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 0x25;\n  this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 0x26;\n  this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 0x27;\n  this.CARRIAGE_RETURN_ = this.CONTROL_ | 0x2d; // paint-on mode\n\n  this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 0x29; // Erasure\n\n  this.BACKSPACE_ = this.CONTROL_ | 0x21;\n  this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2c;\n  this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2e;\n};\n/**\n * Detects if the 2-byte packet data is a special character\n *\n * Special characters have a second byte in the range 0x30 to 0x3f,\n * with the first byte being 0x11 (for data channel 1) or 0x19 (for\n * data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an special character\n */\n\n\nCea608Stream.prototype.isSpecialCharacter = function (char0, char1) {\n  return char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f;\n};\n/**\n * Detects if the 2-byte packet data is an extended character\n *\n * Extended characters have a second byte in the range 0x20 to 0x3f,\n * with the first byte being 0x12 or 0x13 (for data channel 1) or\n * 0x1a or 0x1b (for data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an extended character\n */\n\n\nCea608Stream.prototype.isExtCharacter = function (char0, char1) {\n  return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 0x20 && char1 <= 0x3f;\n};\n/**\n * Detects if the 2-byte packet is a mid-row code\n *\n * Mid-row codes have a second byte in the range 0x20 to 0x2f, with\n * the first byte being 0x11 (for data channel 1) or 0x19 (for data\n * channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are a mid-row code\n */\n\n\nCea608Stream.prototype.isMidRowCode = function (char0, char1) {\n  return char0 === this.EXT_ && char1 >= 0x20 && char1 <= 0x2f;\n};\n/**\n * Detects if the 2-byte packet is an offset control code\n *\n * Offset control codes have a second byte in the range 0x21 to 0x23,\n * with the first byte being 0x17 (for data channel 1) or 0x1f (for\n * data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an offset control code\n */\n\n\nCea608Stream.prototype.isOffsetControlCode = function (char0, char1) {\n  return char0 === this.OFFSET_ && char1 >= 0x21 && char1 <= 0x23;\n};\n/**\n * Detects if the 2-byte packet is a Preamble Address Code\n *\n * PACs have a first byte in the range 0x10 to 0x17 (for data channel 1)\n * or 0x18 to 0x1f (for data channel 2), with the second byte in the\n * range 0x40 to 0x7f.\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are a PAC\n */\n\n\nCea608Stream.prototype.isPAC = function (char0, char1) {\n  return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 0x40 && char1 <= 0x7f;\n};\n/**\n * Detects if a packet's second byte is in the range of a PAC color code\n *\n * PAC color codes have the second byte be in the range 0x40 to 0x4f, or\n * 0x60 to 0x6f.\n *\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the byte is a color PAC\n */\n\n\nCea608Stream.prototype.isColorPAC = function (char1) {\n  return char1 >= 0x40 && char1 <= 0x4f || char1 >= 0x60 && char1 <= 0x7f;\n};\n/**\n * Detects if a single byte is in the range of a normal character\n *\n * Normal text bytes are in the range 0x20 to 0x7f.\n *\n * @param  {Integer} char  The byte\n * @return {Boolean}       Whether the byte is a normal character\n */\n\n\nCea608Stream.prototype.isNormalChar = function (char) {\n  return char >= 0x20 && char <= 0x7f;\n};\n/**\n * Configures roll-up\n *\n * @param  {Integer} pts         Current PTS\n * @param  {Integer} newBaseRow  Used by PACs to slide the current window to\n *                               a new position\n */\n\n\nCea608Stream.prototype.setRollUp = function (pts, newBaseRow) {\n  // Reset the base row to the bottom row when switching modes\n  if (this.mode_ !== 'rollUp') {\n    this.row_ = BOTTOM_ROW;\n    this.mode_ = 'rollUp'; // Spec says to wipe memories when switching to roll-up\n\n    this.flushDisplayed(pts);\n    this.nonDisplayed_ = createDisplayBuffer();\n    this.displayed_ = createDisplayBuffer();\n  }\n\n  if (newBaseRow !== undefined && newBaseRow !== this.row_) {\n    // move currently displayed captions (up or down) to the new base row\n    for (var i = 0; i < this.rollUpRows_; i++) {\n      this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];\n      this.displayed_[this.row_ - i] = '';\n    }\n  }\n\n  if (newBaseRow === undefined) {\n    newBaseRow = this.row_;\n  }\n\n  this.topRow_ = newBaseRow - this.rollUpRows_ + 1;\n}; // Adds the opening HTML tag for the passed character to the caption text,\n// and keeps track of it for later closing\n\n\nCea608Stream.prototype.addFormatting = function (pts, format) {\n  this.formatting_ = this.formatting_.concat(format);\n  var text = format.reduce(function (text, format) {\n    return text + '<' + format + '>';\n  }, '');\n  this[this.mode_](pts, text);\n}; // Adds HTML closing tags for current formatting to caption text and\n// clears remembered formatting\n\n\nCea608Stream.prototype.clearFormatting = function (pts) {\n  if (!this.formatting_.length) {\n    return;\n  }\n\n  var text = this.formatting_.reverse().reduce(function (text, format) {\n    return text + '</' + format + '>';\n  }, '');\n  this.formatting_ = [];\n  this[this.mode_](pts, text);\n}; // Mode Implementations\n\n\nCea608Stream.prototype.popOn = function (pts, text) {\n  var baseRow = this.nonDisplayed_[this.row_]; // buffer characters\n\n  baseRow += text;\n  this.nonDisplayed_[this.row_] = baseRow;\n};\n\nCea608Stream.prototype.rollUp = function (pts, text) {\n  var baseRow = this.displayed_[this.row_];\n  baseRow += text;\n  this.displayed_[this.row_] = baseRow;\n};\n\nCea608Stream.prototype.shiftRowsUp_ = function () {\n  var i; // clear out inactive rows\n\n  for (i = 0; i < this.topRow_; i++) {\n    this.displayed_[i] = '';\n  }\n\n  for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) {\n    this.displayed_[i] = '';\n  } // shift displayed rows up\n\n\n  for (i = this.topRow_; i < this.row_; i++) {\n    this.displayed_[i] = this.displayed_[i + 1];\n  } // clear out the bottom row\n\n\n  this.displayed_[this.row_] = '';\n};\n\nCea608Stream.prototype.paintOn = function (pts, text) {\n  var baseRow = this.displayed_[this.row_];\n  baseRow += text;\n  this.displayed_[this.row_] = baseRow;\n}; // exports\n\n\nmodule.exports = {\n  CaptionStream: CaptionStream,\n  Cea608Stream: Cea608Stream,\n  Cea708Stream: Cea708Stream\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nmodule.exports = {\n  H264_STREAM_TYPE: 0x1B,\n  ADTS_STREAM_TYPE: 0x0F,\n  METADATA_STREAM_TYPE: 0x15\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Accepts program elementary stream (PES) data events and corrects\n * decode and presentation time stamps to account for a rollover\n * of the 33 bit value.\n */\n'use strict';\n\nvar Stream = require('../utils/stream');\n\nvar MAX_TS = 8589934592;\nvar RO_THRESH = 4294967296;\nvar TYPE_SHARED = 'shared';\n\nvar handleRollover = function handleRollover(value, reference) {\n  var direction = 1;\n\n  if (value > reference) {\n    // If the current timestamp value is greater than our reference timestamp and we detect a\n    // timestamp rollover, this means the roll over is happening in the opposite direction.\n    // Example scenario: Enter a long stream/video just after a rollover occurred. The reference\n    // point will be set to a small number, e.g. 1. The user then seeks backwards over the\n    // rollover point. In loading this segment, the timestamp values will be very large,\n    // e.g. 2^33 - 1. Since this comes before the data we loaded previously, we want to adjust\n    // the time stamp to be `value - 2^33`.\n    direction = -1;\n  } // Note: A seek forwards or back that is greater than the RO_THRESH (2^32, ~13 hours) will\n  // cause an incorrect adjustment.\n\n\n  while (Math.abs(reference - value) > RO_THRESH) {\n    value += direction * MAX_TS;\n  }\n\n  return value;\n};\n\nvar TimestampRolloverStream = function TimestampRolloverStream(type) {\n  var lastDTS, referenceDTS;\n  TimestampRolloverStream.prototype.init.call(this); // The \"shared\" type is used in cases where a stream will contain muxed\n  // video and audio. We could use `undefined` here, but having a string\n  // makes debugging a little clearer.\n\n  this.type_ = type || TYPE_SHARED;\n\n  this.push = function (data) {\n    // Any \"shared\" rollover streams will accept _all_ data. Otherwise,\n    // streams will only accept data that matches their type.\n    if (this.type_ !== TYPE_SHARED && data.type !== this.type_) {\n      return;\n    }\n\n    if (referenceDTS === undefined) {\n      referenceDTS = data.dts;\n    }\n\n    data.dts = handleRollover(data.dts, referenceDTS);\n    data.pts = handleRollover(data.pts, referenceDTS);\n    lastDTS = data.dts;\n    this.trigger('data', data);\n  };\n\n  this.flush = function () {\n    referenceDTS = lastDTS;\n    this.trigger('done');\n  };\n\n  this.endTimeline = function () {\n    this.flush();\n    this.trigger('endedtimeline');\n  };\n\n  this.discontinuity = function () {\n    referenceDTS = void 0;\n    lastDTS = void 0;\n  };\n\n  this.reset = function () {\n    this.discontinuity();\n    this.trigger('reset');\n  };\n};\n\nTimestampRolloverStream.prototype = new Stream();\nmodule.exports = {\n  TimestampRolloverStream: TimestampRolloverStream,\n  handleRollover: handleRollover\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Accepts program elementary stream (PES) data events and parses out\n * ID3 metadata from them, if present.\n * @see http://id3.org/id3v2.3.0\n */\n'use strict';\n\nvar Stream = require('../utils/stream'),\n    StreamTypes = require('./stream-types'),\n    // return a percent-encoded representation of the specified byte range\n// @see http://en.wikipedia.org/wiki/Percent-encoding\npercentEncode = function percentEncode(bytes, start, end) {\n  var i,\n      result = '';\n\n  for (i = start; i < end; i++) {\n    result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n  }\n\n  return result;\n},\n    // return the string representation of the specified byte range,\n// interpreted as UTf-8.\nparseUtf8 = function parseUtf8(bytes, start, end) {\n  return decodeURIComponent(percentEncode(bytes, start, end));\n},\n    // return the string representation of the specified byte range,\n// interpreted as ISO-8859-1.\nparseIso88591 = function parseIso88591(bytes, start, end) {\n  return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n},\n    parseSyncSafeInteger = function parseSyncSafeInteger(data) {\n  return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\n},\n    tagParsers = {\n  TXXX: function TXXX(tag) {\n    var i;\n\n    if (tag.data[0] !== 3) {\n      // ignore frames with unrecognized character encodings\n      return;\n    }\n\n    for (i = 1; i < tag.data.length; i++) {\n      if (tag.data[i] === 0) {\n        // parse the text fields\n        tag.description = parseUtf8(tag.data, 1, i); // do not include the null terminator in the tag value\n\n        tag.value = parseUtf8(tag.data, i + 1, tag.data.length).replace(/\\0*$/, '');\n        break;\n      }\n    }\n\n    tag.data = tag.value;\n  },\n  WXXX: function WXXX(tag) {\n    var i;\n\n    if (tag.data[0] !== 3) {\n      // ignore frames with unrecognized character encodings\n      return;\n    }\n\n    for (i = 1; i < tag.data.length; i++) {\n      if (tag.data[i] === 0) {\n        // parse the description and URL fields\n        tag.description = parseUtf8(tag.data, 1, i);\n        tag.url = parseUtf8(tag.data, i + 1, tag.data.length);\n        break;\n      }\n    }\n  },\n  PRIV: function PRIV(tag) {\n    var i;\n\n    for (i = 0; i < tag.data.length; i++) {\n      if (tag.data[i] === 0) {\n        // parse the description and URL fields\n        tag.owner = parseIso88591(tag.data, 0, i);\n        break;\n      }\n    }\n\n    tag.privateData = tag.data.subarray(i + 1);\n    tag.data = tag.privateData;\n  }\n},\n    _MetadataStream;\n\n_MetadataStream = function MetadataStream(options) {\n  var settings = {\n    // the bytes of the program-level descriptor field in MP2T\n    // see ISO/IEC 13818-1:2013 (E), section 2.6 \"Program and\n    // program element descriptors\"\n    descriptor: options && options.descriptor\n  },\n      // the total size in bytes of the ID3 tag being parsed\n  tagSize = 0,\n      // tag data that is not complete enough to be parsed\n  buffer = [],\n      // the total number of bytes currently in the buffer\n  bufferSize = 0,\n      i;\n\n  _MetadataStream.prototype.init.call(this); // calculate the text track in-band metadata track dispatch type\n  // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\n\n\n  this.dispatchType = StreamTypes.METADATA_STREAM_TYPE.toString(16);\n\n  if (settings.descriptor) {\n    for (i = 0; i < settings.descriptor.length; i++) {\n      this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\n    }\n  }\n\n  this.push = function (chunk) {\n    var tag, frameStart, frameSize, frame, i, frameHeader;\n\n    if (chunk.type !== 'timed-metadata') {\n      return;\n    } // if data_alignment_indicator is set in the PES header,\n    // we must have the start of a new ID3 tag. Assume anything\n    // remaining in the buffer was malformed and throw it out\n\n\n    if (chunk.dataAlignmentIndicator) {\n      bufferSize = 0;\n      buffer.length = 0;\n    } // ignore events that don't look like ID3 data\n\n\n    if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== 'I'.charCodeAt(0) || chunk.data[1] !== 'D'.charCodeAt(0) || chunk.data[2] !== '3'.charCodeAt(0))) {\n      this.trigger('log', {\n        level: 'warn',\n        message: 'Skipping unrecognized metadata packet'\n      });\n      return;\n    } // add this chunk to the data we've collected so far\n\n\n    buffer.push(chunk);\n    bufferSize += chunk.data.byteLength; // grab the size of the entire frame from the ID3 header\n\n    if (buffer.length === 1) {\n      // the frame size is transmitted as a 28-bit integer in the\n      // last four bytes of the ID3 header.\n      // The most significant bit of each byte is dropped and the\n      // results concatenated to recover the actual value.\n      tagSize = parseSyncSafeInteger(chunk.data.subarray(6, 10)); // ID3 reports the tag size excluding the header but it's more\n      // convenient for our comparisons to include it\n\n      tagSize += 10;\n    } // if the entire frame has not arrived, wait for more data\n\n\n    if (bufferSize < tagSize) {\n      return;\n    } // collect the entire frame so it can be parsed\n\n\n    tag = {\n      data: new Uint8Array(tagSize),\n      frames: [],\n      pts: buffer[0].pts,\n      dts: buffer[0].dts\n    };\n\n    for (i = 0; i < tagSize;) {\n      tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\n      i += buffer[0].data.byteLength;\n      bufferSize -= buffer[0].data.byteLength;\n      buffer.shift();\n    } // find the start of the first frame and the end of the tag\n\n\n    frameStart = 10;\n\n    if (tag.data[5] & 0x40) {\n      // advance the frame start past the extended header\n      frameStart += 4; // header size field\n\n      frameStart += parseSyncSafeInteger(tag.data.subarray(10, 14)); // clip any padding off the end\n\n      tagSize -= parseSyncSafeInteger(tag.data.subarray(16, 20));\n    } // parse one or more ID3 frames\n    // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n\n\n    do {\n      // determine the number of bytes in this frame\n      frameSize = parseSyncSafeInteger(tag.data.subarray(frameStart + 4, frameStart + 8));\n\n      if (frameSize < 1) {\n        this.trigger('log', {\n          level: 'warn',\n          message: 'Malformed ID3 frame encountered. Skipping metadata parsing.'\n        });\n        return;\n      }\n\n      frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);\n      frame = {\n        id: frameHeader,\n        data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\n      };\n      frame.key = frame.id;\n\n      if (tagParsers[frame.id]) {\n        tagParsers[frame.id](frame); // handle the special PRIV frame used to indicate the start\n        // time for raw AAC data\n\n        if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\n          var d = frame.data,\n              size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\n          size *= 4;\n          size += d[7] & 0x03;\n          frame.timeStamp = size; // in raw AAC, all subsequent data will be timestamped based\n          // on the value of this frame\n          // we couldn't have known the appropriate pts and dts before\n          // parsing this ID3 tag so set those values now\n\n          if (tag.pts === undefined && tag.dts === undefined) {\n            tag.pts = frame.timeStamp;\n            tag.dts = frame.timeStamp;\n          }\n\n          this.trigger('timestamp', frame);\n        }\n      }\n\n      tag.frames.push(frame);\n      frameStart += 10; // advance past the frame header\n\n      frameStart += frameSize; // advance past the frame body\n    } while (frameStart < tagSize);\n\n    this.trigger('data', tag);\n  };\n};\n\n_MetadataStream.prototype = new Stream();\nmodule.exports = _MetadataStream;", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * A stream-based mp2t to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js'),\n    CaptionStream = require('./caption-stream'),\n    StreamTypes = require('./stream-types'),\n    TimestampRolloverStream = require('./timestamp-rollover-stream').TimestampRolloverStream; // object types\n\n\nvar _TransportPacketStream, _TransportParseStream, _ElementaryStream; // constants\n\n\nvar MP2T_PACKET_LENGTH = 188,\n    // bytes\nSYNC_BYTE = 0x47;\n/**\n * Splits an incoming stream of binary data into MPEG-2 Transport\n * Stream packets.\n */\n\n_TransportPacketStream = function TransportPacketStream() {\n  var buffer = new Uint8Array(MP2T_PACKET_LENGTH),\n      bytesInBuffer = 0;\n\n  _TransportPacketStream.prototype.init.call(this); // Deliver new bytes to the stream.\n\n  /**\n   * Split a stream of data into M2TS packets\n  **/\n\n\n  this.push = function (bytes) {\n    var startIndex = 0,\n        endIndex = MP2T_PACKET_LENGTH,\n        everything; // If there are bytes remaining from the last segment, prepend them to the\n    // bytes that were pushed in\n\n    if (bytesInBuffer) {\n      everything = new Uint8Array(bytes.byteLength + bytesInBuffer);\n      everything.set(buffer.subarray(0, bytesInBuffer));\n      everything.set(bytes, bytesInBuffer);\n      bytesInBuffer = 0;\n    } else {\n      everything = bytes;\n    } // While we have enough data for a packet\n\n\n    while (endIndex < everything.byteLength) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (everything[startIndex] === SYNC_BYTE && everything[endIndex] === SYNC_BYTE) {\n        // We found a packet so emit it and jump one whole packet forward in\n        // the stream\n        this.trigger('data', everything.subarray(startIndex, endIndex));\n        startIndex += MP2T_PACKET_LENGTH;\n        endIndex += MP2T_PACKET_LENGTH;\n        continue;\n      } // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n\n\n      startIndex++;\n      endIndex++;\n    } // If there was some data left over at the end of the segment that couldn't\n    // possibly be a whole packet, keep it because it might be the start of a packet\n    // that continues in the next segment\n\n\n    if (startIndex < everything.byteLength) {\n      buffer.set(everything.subarray(startIndex), 0);\n      bytesInBuffer = everything.byteLength - startIndex;\n    }\n  };\n  /**\n   * Passes identified M2TS packets to the TransportParseStream to be parsed\n  **/\n\n\n  this.flush = function () {\n    // If the buffer contains a whole packet when we are being flushed, emit it\n    // and empty the buffer. Otherwise hold onto the data because it may be\n    // important for decoding the next segment\n    if (bytesInBuffer === MP2T_PACKET_LENGTH && buffer[0] === SYNC_BYTE) {\n      this.trigger('data', buffer);\n      bytesInBuffer = 0;\n    }\n\n    this.trigger('done');\n  };\n\n  this.endTimeline = function () {\n    this.flush();\n    this.trigger('endedtimeline');\n  };\n\n  this.reset = function () {\n    bytesInBuffer = 0;\n    this.trigger('reset');\n  };\n};\n\n_TransportPacketStream.prototype = new Stream();\n/**\n * Accepts an MP2T TransportPacketStream and emits data events with parsed\n * forms of the individual transport stream packets.\n */\n\n_TransportParseStream = function TransportParseStream() {\n  var parsePsi, parsePat, parsePmt, self;\n\n  _TransportParseStream.prototype.init.call(this);\n\n  self = this;\n  this.packetsWaitingForPmt = [];\n  this.programMapTable = undefined;\n\n  parsePsi = function parsePsi(payload, psi) {\n    var offset = 0; // PSI packets may be split into multiple sections and those\n    // sections may be split into multiple packets. If a PSI\n    // section starts in this packet, the payload_unit_start_indicator\n    // will be true and the first byte of the payload will indicate\n    // the offset from the current position to the start of the\n    // section.\n\n    if (psi.payloadUnitStartIndicator) {\n      offset += payload[offset] + 1;\n    }\n\n    if (psi.type === 'pat') {\n      parsePat(payload.subarray(offset), psi);\n    } else {\n      parsePmt(payload.subarray(offset), psi);\n    }\n  };\n\n  parsePat = function parsePat(payload, pat) {\n    pat.section_number = payload[7]; // eslint-disable-line camelcase\n\n    pat.last_section_number = payload[8]; // eslint-disable-line camelcase\n    // skip the PSI header and parse the first PMT entry\n\n    self.pmtPid = (payload[10] & 0x1F) << 8 | payload[11];\n    pat.pmtPid = self.pmtPid;\n  };\n  /**\n   * Parse out the relevant fields of a Program Map Table (PMT).\n   * @param payload {Uint8Array} the PMT-specific portion of an MP2T\n   * packet. The first byte in this array should be the table_id\n   * field.\n   * @param pmt {object} the object that should be decorated with\n   * fields parsed from the PMT.\n   */\n\n\n  parsePmt = function parsePmt(payload, pmt) {\n    var sectionLength, tableEnd, programInfoLength, offset; // PMTs can be sent ahead of the time when they should actually\n    // take effect. We don't believe this should ever be the case\n    // for HLS but we'll ignore \"forward\" PMT declarations if we see\n    // them. Future PMT declarations have the current_next_indicator\n    // set to zero.\n\n    if (!(payload[5] & 0x01)) {\n      return;\n    } // overwrite any existing program map table\n\n\n    self.programMapTable = {\n      video: null,\n      audio: null,\n      'timed-metadata': {}\n    }; // the mapping table ends at the end of the current section\n\n    sectionLength = (payload[1] & 0x0f) << 8 | payload[2];\n    tableEnd = 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\n    // long the program info descriptors are\n\n    programInfoLength = (payload[10] & 0x0f) << 8 | payload[11]; // advance the offset to the first entry in the mapping table\n\n    offset = 12 + programInfoLength;\n\n    while (offset < tableEnd) {\n      var streamType = payload[offset];\n      var pid = (payload[offset + 1] & 0x1F) << 8 | payload[offset + 2]; // only map a single elementary_pid for audio and video stream types\n      // TODO: should this be done for metadata too? for now maintain behavior of\n      //       multiple metadata streams\n\n      if (streamType === StreamTypes.H264_STREAM_TYPE && self.programMapTable.video === null) {\n        self.programMapTable.video = pid;\n      } else if (streamType === StreamTypes.ADTS_STREAM_TYPE && self.programMapTable.audio === null) {\n        self.programMapTable.audio = pid;\n      } else if (streamType === StreamTypes.METADATA_STREAM_TYPE) {\n        // map pid to stream type for metadata streams\n        self.programMapTable['timed-metadata'][pid] = streamType;\n      } // move to the next table entry\n      // skip past the elementary stream descriptors, if present\n\n\n      offset += ((payload[offset + 3] & 0x0F) << 8 | payload[offset + 4]) + 5;\n    } // record the map on the packet as well\n\n\n    pmt.programMapTable = self.programMapTable;\n  };\n  /**\n   * Deliver a new MP2T packet to the next stream in the pipeline.\n   */\n\n\n  this.push = function (packet) {\n    var result = {},\n        offset = 4;\n    result.payloadUnitStartIndicator = !!(packet[1] & 0x40); // pid is a 13-bit field starting at the last bit of packet[1]\n\n    result.pid = packet[1] & 0x1f;\n    result.pid <<= 8;\n    result.pid |= packet[2]; // if an adaption field is present, its length is specified by the\n    // fifth byte of the TS packet header. The adaptation field is\n    // used to add stuffing to PES packets that don't fill a complete\n    // TS packet, and to specify some forms of timing and control data\n    // that we do not currently use.\n\n    if ((packet[3] & 0x30) >>> 4 > 0x01) {\n      offset += packet[offset] + 1;\n    } // parse the rest of the packet based on the type\n\n\n    if (result.pid === 0) {\n      result.type = 'pat';\n      parsePsi(packet.subarray(offset), result);\n      this.trigger('data', result);\n    } else if (result.pid === this.pmtPid) {\n      result.type = 'pmt';\n      parsePsi(packet.subarray(offset), result);\n      this.trigger('data', result); // if there are any packets waiting for a PMT to be found, process them now\n\n      while (this.packetsWaitingForPmt.length) {\n        this.processPes_.apply(this, this.packetsWaitingForPmt.shift());\n      }\n    } else if (this.programMapTable === undefined) {\n      // When we have not seen a PMT yet, defer further processing of\n      // PES packets until one has been parsed\n      this.packetsWaitingForPmt.push([packet, offset, result]);\n    } else {\n      this.processPes_(packet, offset, result);\n    }\n  };\n\n  this.processPes_ = function (packet, offset, result) {\n    // set the appropriate stream type\n    if (result.pid === this.programMapTable.video) {\n      result.streamType = StreamTypes.H264_STREAM_TYPE;\n    } else if (result.pid === this.programMapTable.audio) {\n      result.streamType = StreamTypes.ADTS_STREAM_TYPE;\n    } else {\n      // if not video or audio, it is timed-metadata or unknown\n      // if unknown, streamType will be undefined\n      result.streamType = this.programMapTable['timed-metadata'][result.pid];\n    }\n\n    result.type = 'pes';\n    result.data = packet.subarray(offset);\n    this.trigger('data', result);\n  };\n};\n\n_TransportParseStream.prototype = new Stream();\n_TransportParseStream.STREAM_TYPES = {\n  h264: 0x1b,\n  adts: 0x0f\n};\n/**\n * Reconsistutes program elementary stream (PES) packets from parsed\n * transport stream packets. That is, if you pipe an\n * mp2t.TransportParseStream into a mp2t.ElementaryStream, the output\n * events will be events which capture the bytes for individual PES\n * packets plus relevant metadata that has been extracted from the\n * container.\n */\n\n_ElementaryStream = function ElementaryStream() {\n  var self = this,\n      segmentHadPmt = false,\n      // PES packet fragments\n  video = {\n    data: [],\n    size: 0\n  },\n      audio = {\n    data: [],\n    size: 0\n  },\n      timedMetadata = {\n    data: [],\n    size: 0\n  },\n      programMapTable,\n      parsePes = function parsePes(payload, pes) {\n    var ptsDtsFlags;\n    var startPrefix = payload[0] << 16 | payload[1] << 8 | payload[2]; // default to an empty array\n\n    pes.data = new Uint8Array(); // In certain live streams, the start of a TS fragment has ts packets\n    // that are frame data that is continuing from the previous fragment. This\n    // is to check that the pes data is the start of a new pes payload\n\n    if (startPrefix !== 1) {\n      return;\n    } // get the packet length, this will be 0 for video\n\n\n    pes.packetLength = 6 + (payload[4] << 8 | payload[5]); // find out if this packets starts a new keyframe\n\n    pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0; // PES packets may be annotated with a PTS value, or a PTS value\n    // and a DTS value. Determine what combination of values is\n    // available to work with.\n\n    ptsDtsFlags = payload[7]; // PTS and DTS are normally stored as a 33-bit number.  Javascript\n    // performs all bitwise operations on 32-bit integers but javascript\n    // supports a much greater range (52-bits) of integer using standard\n    // mathematical operations.\n    // We construct a 31-bit value using bitwise operators over the 31\n    // most significant bits and then multiply by 4 (equal to a left-shift\n    // of 2) before we add the final 2 least significant bits of the\n    // timestamp (equal to an OR.)\n\n    if (ptsDtsFlags & 0xC0) {\n      // the PTS and DTS are not written out directly. For information\n      // on how they are encoded, see\n      // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n      pes.pts = (payload[9] & 0x0E) << 27 | (payload[10] & 0xFF) << 20 | (payload[11] & 0xFE) << 12 | (payload[12] & 0xFF) << 5 | (payload[13] & 0xFE) >>> 3;\n      pes.pts *= 4; // Left shift by 2\n\n      pes.pts += (payload[13] & 0x06) >>> 1; // OR by the two LSBs\n\n      pes.dts = pes.pts;\n\n      if (ptsDtsFlags & 0x40) {\n        pes.dts = (payload[14] & 0x0E) << 27 | (payload[15] & 0xFF) << 20 | (payload[16] & 0xFE) << 12 | (payload[17] & 0xFF) << 5 | (payload[18] & 0xFE) >>> 3;\n        pes.dts *= 4; // Left shift by 2\n\n        pes.dts += (payload[18] & 0x06) >>> 1; // OR by the two LSBs\n      }\n    } // the data section starts immediately after the PES header.\n    // pes_header_data_length specifies the number of header bytes\n    // that follow the last byte of the field.\n\n\n    pes.data = payload.subarray(9 + payload[8]);\n  },\n\n  /**\n    * Pass completely parsed PES packets to the next stream in the pipeline\n   **/\n  flushStream = function flushStream(stream, type, forceFlush) {\n    var packetData = new Uint8Array(stream.size),\n        event = {\n      type: type\n    },\n        i = 0,\n        offset = 0,\n        packetFlushable = false,\n        fragment; // do nothing if there is not enough buffered data for a complete\n    // PES header\n\n    if (!stream.data.length || stream.size < 9) {\n      return;\n    }\n\n    event.trackId = stream.data[0].pid; // reassemble the packet\n\n    for (i = 0; i < stream.data.length; i++) {\n      fragment = stream.data[i];\n      packetData.set(fragment.data, offset);\n      offset += fragment.data.byteLength;\n    } // parse assembled packet's PES header\n\n\n    parsePes(packetData, event); // non-video PES packets MUST have a non-zero PES_packet_length\n    // check that there is enough stream data to fill the packet\n\n    packetFlushable = type === 'video' || event.packetLength <= stream.size; // flush pending packets if the conditions are right\n\n    if (forceFlush || packetFlushable) {\n      stream.size = 0;\n      stream.data.length = 0;\n    } // only emit packets that are complete. this is to avoid assembling\n    // incomplete PES packets due to poor segmentation\n\n\n    if (packetFlushable) {\n      self.trigger('data', event);\n    }\n  };\n\n  _ElementaryStream.prototype.init.call(this);\n  /**\n   * Identifies M2TS packet types and parses PES packets using metadata\n   * parsed from the PMT\n   **/\n\n\n  this.push = function (data) {\n    ({\n      pat: function pat() {// we have to wait for the PMT to arrive as well before we\n        // have any meaningful metadata\n      },\n      pes: function pes() {\n        var stream, streamType;\n\n        switch (data.streamType) {\n          case StreamTypes.H264_STREAM_TYPE:\n            stream = video;\n            streamType = 'video';\n            break;\n\n          case StreamTypes.ADTS_STREAM_TYPE:\n            stream = audio;\n            streamType = 'audio';\n            break;\n\n          case StreamTypes.METADATA_STREAM_TYPE:\n            stream = timedMetadata;\n            streamType = 'timed-metadata';\n            break;\n\n          default:\n            // ignore unknown stream types\n            return;\n        } // if a new packet is starting, we can flush the completed\n        // packet\n\n\n        if (data.payloadUnitStartIndicator) {\n          flushStream(stream, streamType, true);\n        } // buffer this fragment until we are sure we've received the\n        // complete payload\n\n\n        stream.data.push(data);\n        stream.size += data.data.byteLength;\n      },\n      pmt: function pmt() {\n        var event = {\n          type: 'metadata',\n          tracks: []\n        };\n        programMapTable = data.programMapTable; // translate audio and video streams to tracks\n\n        if (programMapTable.video !== null) {\n          event.tracks.push({\n            timelineStartInfo: {\n              baseMediaDecodeTime: 0\n            },\n            id: +programMapTable.video,\n            codec: 'avc',\n            type: 'video'\n          });\n        }\n\n        if (programMapTable.audio !== null) {\n          event.tracks.push({\n            timelineStartInfo: {\n              baseMediaDecodeTime: 0\n            },\n            id: +programMapTable.audio,\n            codec: 'adts',\n            type: 'audio'\n          });\n        }\n\n        segmentHadPmt = true;\n        self.trigger('data', event);\n      }\n    })[data.type]();\n  };\n\n  this.reset = function () {\n    video.size = 0;\n    video.data.length = 0;\n    audio.size = 0;\n    audio.data.length = 0;\n    this.trigger('reset');\n  };\n  /**\n   * Flush any remaining input. Video PES packets may be of variable\n   * length. Normally, the start of a new video packet can trigger the\n   * finalization of the previous packet. That is not possible if no\n   * more video is forthcoming, however. In that case, some other\n   * mechanism (like the end of the file) has to be employed. When it is\n   * clear that no additional data is forthcoming, calling this method\n   * will flush the buffered packets.\n   */\n\n\n  this.flushStreams_ = function () {\n    // !!THIS ORDER IS IMPORTANT!!\n    // video first then audio\n    flushStream(video, 'video');\n    flushStream(audio, 'audio');\n    flushStream(timedMetadata, 'timed-metadata');\n  };\n\n  this.flush = function () {\n    // if on flush we haven't had a pmt emitted\n    // and we have a pmt to emit. emit the pmt\n    // so that we trigger a trackinfo downstream.\n    if (!segmentHadPmt && programMapTable) {\n      var pmt = {\n        type: 'metadata',\n        tracks: []\n      }; // translate audio and video streams to tracks\n\n      if (programMapTable.video !== null) {\n        pmt.tracks.push({\n          timelineStartInfo: {\n            baseMediaDecodeTime: 0\n          },\n          id: +programMapTable.video,\n          codec: 'avc',\n          type: 'video'\n        });\n      }\n\n      if (programMapTable.audio !== null) {\n        pmt.tracks.push({\n          timelineStartInfo: {\n            baseMediaDecodeTime: 0\n          },\n          id: +programMapTable.audio,\n          codec: 'adts',\n          type: 'audio'\n        });\n      }\n\n      self.trigger('data', pmt);\n    }\n\n    segmentHadPmt = false;\n    this.flushStreams_();\n    this.trigger('done');\n  };\n};\n\n_ElementaryStream.prototype = new Stream();\nvar m2ts = {\n  PAT_PID: 0x0000,\n  MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH,\n  TransportPacketStream: _TransportPacketStream,\n  TransportParseStream: _TransportParseStream,\n  ElementaryStream: _ElementaryStream,\n  TimestampRolloverStream: TimestampRolloverStream,\n  CaptionStream: CaptionStream.CaptionStream,\n  Cea608Stream: CaptionStream.Cea608Stream,\n  Cea708Stream: CaptionStream.Cea708Stream,\n  MetadataStream: require('./metadata-stream')\n};\n\nfor (var type in StreamTypes) {\n  if (StreamTypes.hasOwnProperty(type)) {\n    m2ts[type] = StreamTypes[type];\n  }\n}\n\nmodule.exports = m2ts;", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Utilities to detect basic properties and metadata about Aac data.\n */\n'use strict';\n\nvar ADTS_SAMPLING_FREQUENCIES = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n\nvar parseId3TagSize = function parseId3TagSize(header, byteIndex) {\n  var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9],\n      flags = header[byteIndex + 5],\n      footerPresent = (flags & 16) >> 4; // if we get a negative returnSize clamp it to 0\n\n  returnSize = returnSize >= 0 ? returnSize : 0;\n\n  if (footerPresent) {\n    return returnSize + 20;\n  }\n\n  return returnSize + 10;\n};\n\nvar getId3Offset = function getId3Offset(data, offset) {\n  if (data.length - offset < 10 || data[offset] !== 'I'.charCodeAt(0) || data[offset + 1] !== 'D'.charCodeAt(0) || data[offset + 2] !== '3'.charCodeAt(0)) {\n    return offset;\n  }\n\n  offset += parseId3TagSize(data, offset);\n  return getId3Offset(data, offset);\n}; // TODO: use vhs-utils\n\n\nvar isLikelyAacData = function isLikelyAacData(data) {\n  var offset = getId3Offset(data, 0);\n  return data.length >= offset + 2 && (data[offset] & 0xFF) === 0xFF && (data[offset + 1] & 0xF0) === 0xF0 && // verify that the 2 layer bits are 0, aka this\n  // is not mp3 data but aac data.\n  (data[offset + 1] & 0x16) === 0x10;\n};\n\nvar parseSyncSafeInteger = function parseSyncSafeInteger(data) {\n  return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\n}; // return a percent-encoded representation of the specified byte range\n// @see http://en.wikipedia.org/wiki/Percent-encoding\n\n\nvar percentEncode = function percentEncode(bytes, start, end) {\n  var i,\n      result = '';\n\n  for (i = start; i < end; i++) {\n    result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n  }\n\n  return result;\n}; // return the string representation of the specified byte range,\n// interpreted as ISO-8859-1.\n\n\nvar parseIso88591 = function parseIso88591(bytes, start, end) {\n  return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n};\n\nvar parseAdtsSize = function parseAdtsSize(header, byteIndex) {\n  var lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\n      middle = header[byteIndex + 4] << 3,\n      highTwo = header[byteIndex + 3] & 0x3 << 11;\n  return highTwo | middle | lowThree;\n};\n\nvar parseType = function parseType(header, byteIndex) {\n  if (header[byteIndex] === 'I'.charCodeAt(0) && header[byteIndex + 1] === 'D'.charCodeAt(0) && header[byteIndex + 2] === '3'.charCodeAt(0)) {\n    return 'timed-metadata';\n  } else if (header[byteIndex] & 0xff === 0xff && (header[byteIndex + 1] & 0xf0) === 0xf0) {\n    return 'audio';\n  }\n\n  return null;\n};\n\nvar parseSampleRate = function parseSampleRate(packet) {\n  var i = 0;\n\n  while (i + 5 < packet.length) {\n    if (packet[i] !== 0xFF || (packet[i + 1] & 0xF6) !== 0xF0) {\n      // If a valid header was not found,  jump one forward and attempt to\n      // find a valid ADTS header starting at the next byte\n      i++;\n      continue;\n    }\n\n    return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 0x3c) >>> 2];\n  }\n\n  return null;\n};\n\nvar parseAacTimestamp = function parseAacTimestamp(packet) {\n  var frameStart, frameSize, frame, frameHeader; // find the start of the first frame and the end of the tag\n\n  frameStart = 10;\n\n  if (packet[5] & 0x40) {\n    // advance the frame start past the extended header\n    frameStart += 4; // header size field\n\n    frameStart += parseSyncSafeInteger(packet.subarray(10, 14));\n  } // parse one or more ID3 frames\n  // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n\n\n  do {\n    // determine the number of bytes in this frame\n    frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));\n\n    if (frameSize < 1) {\n      return null;\n    }\n\n    frameHeader = String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3]);\n\n    if (frameHeader === 'PRIV') {\n      frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);\n\n      for (var i = 0; i < frame.byteLength; i++) {\n        if (frame[i] === 0) {\n          var owner = parseIso88591(frame, 0, i);\n\n          if (owner === 'com.apple.streaming.transportStreamTimestamp') {\n            var d = frame.subarray(i + 1);\n            var size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\n            size *= 4;\n            size += d[7] & 0x03;\n            return size;\n          }\n\n          break;\n        }\n      }\n    }\n\n    frameStart += 10; // advance past the frame header\n\n    frameStart += frameSize; // advance past the frame body\n  } while (frameStart < packet.byteLength);\n\n  return null;\n};\n\nmodule.exports = {\n  isLikelyAacData: isLikelyAacData,\n  parseId3TagSize: parseId3TagSize,\n  parseAdtsSize: parseAdtsSize,\n  parseType: parseType,\n  parseSampleRate: parseSampleRate,\n  parseAacTimestamp: parseAacTimestamp\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * A stream-based aac to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js');\n\nvar aacUtils = require('./utils'); // Constants\n\n\nvar _AacStream;\n/**\n * Splits an incoming stream of binary data into ADTS and ID3 Frames.\n */\n\n\n_AacStream = function AacStream() {\n  var everything = new Uint8Array(),\n      timeStamp = 0;\n\n  _AacStream.prototype.init.call(this);\n\n  this.setTimestamp = function (timestamp) {\n    timeStamp = timestamp;\n  };\n\n  this.push = function (bytes) {\n    var frameSize = 0,\n        byteIndex = 0,\n        bytesLeft,\n        chunk,\n        packet,\n        tempLength; // If there are bytes remaining from the last segment, prepend them to the\n    // bytes that were pushed in\n\n    if (everything.length) {\n      tempLength = everything.length;\n      everything = new Uint8Array(bytes.byteLength + tempLength);\n      everything.set(everything.subarray(0, tempLength));\n      everything.set(bytes, tempLength);\n    } else {\n      everything = bytes;\n    }\n\n    while (everything.length - byteIndex >= 3) {\n      if (everything[byteIndex] === 'I'.charCodeAt(0) && everything[byteIndex + 1] === 'D'.charCodeAt(0) && everything[byteIndex + 2] === '3'.charCodeAt(0)) {\n        // Exit early because we don't have enough to parse\n        // the ID3 tag header\n        if (everything.length - byteIndex < 10) {\n          break;\n        } // check framesize\n\n\n        frameSize = aacUtils.parseId3TagSize(everything, byteIndex); // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        // Add to byteIndex to support multiple ID3 tags in sequence\n\n        if (byteIndex + frameSize > everything.length) {\n          break;\n        }\n\n        chunk = {\n          type: 'timed-metadata',\n          data: everything.subarray(byteIndex, byteIndex + frameSize)\n        };\n        this.trigger('data', chunk);\n        byteIndex += frameSize;\n        continue;\n      } else if ((everything[byteIndex] & 0xff) === 0xff && (everything[byteIndex + 1] & 0xf0) === 0xf0) {\n        // Exit early because we don't have enough to parse\n        // the ADTS frame header\n        if (everything.length - byteIndex < 7) {\n          break;\n        }\n\n        frameSize = aacUtils.parseAdtsSize(everything, byteIndex); // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n\n        if (byteIndex + frameSize > everything.length) {\n          break;\n        }\n\n        packet = {\n          type: 'audio',\n          data: everything.subarray(byteIndex, byteIndex + frameSize),\n          pts: timeStamp,\n          dts: timeStamp\n        };\n        this.trigger('data', packet);\n        byteIndex += frameSize;\n        continue;\n      }\n\n      byteIndex++;\n    }\n\n    bytesLeft = everything.length - byteIndex;\n\n    if (bytesLeft > 0) {\n      everything = everything.subarray(byteIndex);\n    } else {\n      everything = new Uint8Array();\n    }\n  };\n\n  this.reset = function () {\n    everything = new Uint8Array();\n    this.trigger('reset');\n  };\n\n  this.endTimeline = function () {\n    everything = new Uint8Array();\n    this.trigger('endedtimeline');\n  };\n};\n\n_AacStream.prototype = new Stream();\nmodule.exports = _AacStream;", "// constants\nvar AUDIO_PROPERTIES = ['audioobjecttype', 'channelcount', 'samplerate', 'samplingfrequencyindex', 'samplesize'];\nmodule.exports = AUDIO_PROPERTIES;", "var VIDEO_PROPERTIES = ['width', 'height', 'profileIdc', 'levelIdc', 'profileCompatibility', 'sarRatio'];\nmodule.exports = VIDEO_PROPERTIES;", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * A stream-based mp2t to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js');\n\nvar mp4 = require('./mp4-generator.js');\n\nvar frameUtils = require('./frame-utils');\n\nvar audioFrameUtils = require('./audio-frame-utils');\n\nvar trackDecodeInfo = require('./track-decode-info');\n\nvar m2ts = require('../m2ts/m2ts.js');\n\nvar clock = require('../utils/clock');\n\nvar AdtsStream = require('../codecs/adts.js');\n\nvar H264Stream = require('../codecs/h264').H264Stream;\n\nvar AacStream = require('../aac');\n\nvar isLikelyAacData = require('../aac/utils').isLikelyAacData;\n\nvar ONE_SECOND_IN_TS = require('../utils/clock').ONE_SECOND_IN_TS;\n\nvar AUDIO_PROPERTIES = require('../constants/audio-properties.js');\n\nvar VIDEO_PROPERTIES = require('../constants/video-properties.js'); // object types\n\n\nvar _VideoSegmentStream, _AudioSegmentStream, _Transmuxer, _CoalesceStream;\n\nvar retriggerForStream = function retriggerForStream(key, event) {\n  event.stream = key;\n  this.trigger('log', event);\n};\n\nvar addPipelineLogRetriggers = function addPipelineLogRetriggers(transmuxer, pipeline) {\n  var keys = Object.keys(pipeline);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i]; // skip non-stream keys and headOfPipeline\n    // which is just a duplicate\n\n    if (key === 'headOfPipeline' || !pipeline[key].on) {\n      continue;\n    }\n\n    pipeline[key].on('log', retriggerForStream.bind(transmuxer, key));\n  }\n};\n/**\n * Compare two arrays (even typed) for same-ness\n */\n\n\nvar arrayEquals = function arrayEquals(a, b) {\n  var i;\n\n  if (a.length !== b.length) {\n    return false;\n  } // compare the value of each element in the array\n\n\n  for (i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar generateSegmentTimingInfo = function generateSegmentTimingInfo(baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {\n  var ptsOffsetFromDts = startPts - startDts,\n      decodeDuration = endDts - startDts,\n      presentationDuration = endPts - startPts; // The PTS and DTS values are based on the actual stream times from the segment,\n  // however, the player time values will reflect a start from the baseMediaDecodeTime.\n  // In order to provide relevant values for the player times, base timing info on the\n  // baseMediaDecodeTime and the DTS and PTS durations of the segment.\n\n  return {\n    start: {\n      dts: baseMediaDecodeTime,\n      pts: baseMediaDecodeTime + ptsOffsetFromDts\n    },\n    end: {\n      dts: baseMediaDecodeTime + decodeDuration,\n      pts: baseMediaDecodeTime + presentationDuration\n    },\n    prependedContentDuration: prependedContentDuration,\n    baseMediaDecodeTime: baseMediaDecodeTime\n  };\n};\n/**\n * Constructs a single-track, ISO BMFF media segment from AAC data\n * events. The output of this stream can be fed to a SourceBuffer\n * configured with a suitable initialization segment.\n * @param track {object} track metadata configuration\n * @param options {object} transmuxer options object\n * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n *        in the source; false to adjust the first segment to start at 0.\n */\n\n\n_AudioSegmentStream = function AudioSegmentStream(track, options) {\n  var adtsFrames = [],\n      sequenceNumber,\n      earliestAllowedDts = 0,\n      audioAppendStartTs = 0,\n      videoBaseMediaDecodeTime = Infinity;\n  options = options || {};\n  sequenceNumber = options.firstSequenceNumber || 0;\n\n  _AudioSegmentStream.prototype.init.call(this);\n\n  this.push = function (data) {\n    trackDecodeInfo.collectDtsInfo(track, data);\n\n    if (track) {\n      AUDIO_PROPERTIES.forEach(function (prop) {\n        track[prop] = data[prop];\n      });\n    } // buffer audio data until end() is called\n\n\n    adtsFrames.push(data);\n  };\n\n  this.setEarliestDts = function (earliestDts) {\n    earliestAllowedDts = earliestDts;\n  };\n\n  this.setVideoBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n    videoBaseMediaDecodeTime = baseMediaDecodeTime;\n  };\n\n  this.setAudioAppendStart = function (timestamp) {\n    audioAppendStartTs = timestamp;\n  };\n\n  this.flush = function () {\n    var frames, moof, mdat, boxes, frameDuration, segmentDuration, videoClockCyclesOfSilencePrefixed; // return early if no audio data has been observed\n\n    if (adtsFrames.length === 0) {\n      this.trigger('done', 'AudioSegmentStream');\n      return;\n    }\n\n    frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);\n    track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps); // amount of audio filled but the value is in video clock rather than audio clock\n\n    videoClockCyclesOfSilencePrefixed = audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime); // we have to build the index from byte locations to\n    // samples (that is, adts frames) in the audio data\n\n    track.samples = audioFrameUtils.generateSampleTable(frames); // concatenate the audio data to constuct the mdat\n\n    mdat = mp4.mdat(audioFrameUtils.concatenateFrameData(frames));\n    adtsFrames = [];\n    moof = mp4.moof(sequenceNumber, [track]);\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength); // bump the sequence number for next time\n\n    sequenceNumber++;\n    boxes.set(moof);\n    boxes.set(mdat, moof.byteLength);\n    trackDecodeInfo.clearDtsInfo(track);\n    frameDuration = Math.ceil(ONE_SECOND_IN_TS * 1024 / track.samplerate); // TODO this check was added to maintain backwards compatibility (particularly with\n    // tests) on adding the timingInfo event. However, it seems unlikely that there's a\n    // valid use-case where an init segment/data should be triggered without associated\n    // frames. Leaving for now, but should be looked into.\n\n    if (frames.length) {\n      segmentDuration = frames.length * frameDuration;\n      this.trigger('segmentTimingInfo', generateSegmentTimingInfo( // The audio track's baseMediaDecodeTime is in audio clock cycles, but the\n      // frame info is in video clock cycles. Convert to match expectation of\n      // listeners (that all timestamps will be based on video clock cycles).\n      clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate), // frame times are already in video clock, as is segment duration\n      frames[0].dts, frames[0].pts, frames[0].dts + segmentDuration, frames[0].pts + segmentDuration, videoClockCyclesOfSilencePrefixed || 0));\n      this.trigger('timingInfo', {\n        start: frames[0].pts,\n        end: frames[0].pts + segmentDuration\n      });\n    }\n\n    this.trigger('data', {\n      track: track,\n      boxes: boxes\n    });\n    this.trigger('done', 'AudioSegmentStream');\n  };\n\n  this.reset = function () {\n    trackDecodeInfo.clearDtsInfo(track);\n    adtsFrames = [];\n    this.trigger('reset');\n  };\n};\n\n_AudioSegmentStream.prototype = new Stream();\n/**\n * Constructs a single-track, ISO BMFF media segment from H264 data\n * events. The output of this stream can be fed to a SourceBuffer\n * configured with a suitable initialization segment.\n * @param track {object} track metadata configuration\n * @param options {object} transmuxer options object\n * @param options.alignGopsAtEnd {boolean} If true, start from the end of the\n *        gopsToAlignWith list when attempting to align gop pts\n * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n *        in the source; false to adjust the first segment to start at 0.\n */\n\n_VideoSegmentStream = function VideoSegmentStream(track, options) {\n  var sequenceNumber,\n      nalUnits = [],\n      gopsToAlignWith = [],\n      config,\n      pps;\n  options = options || {};\n  sequenceNumber = options.firstSequenceNumber || 0;\n\n  _VideoSegmentStream.prototype.init.call(this);\n\n  delete track.minPTS;\n  this.gopCache_ = [];\n  /**\n    * Constructs a ISO BMFF segment given H264 nalUnits\n    * @param {Object} nalUnit A data event representing a nalUnit\n    * @param {String} nalUnit.nalUnitType\n    * @param {Object} nalUnit.config Properties for a mp4 track\n    * @param {Uint8Array} nalUnit.data The nalUnit bytes\n    * @see lib/codecs/h264.js\n   **/\n\n  this.push = function (nalUnit) {\n    trackDecodeInfo.collectDtsInfo(track, nalUnit); // record the track config\n\n    if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n      config = nalUnit.config;\n      track.sps = [nalUnit.data];\n      VIDEO_PROPERTIES.forEach(function (prop) {\n        track[prop] = config[prop];\n      }, this);\n    }\n\n    if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' && !pps) {\n      pps = nalUnit.data;\n      track.pps = [nalUnit.data];\n    } // buffer video until flush() is called\n\n\n    nalUnits.push(nalUnit);\n  };\n  /**\n    * Pass constructed ISO BMFF track and boxes on to the\n    * next stream in the pipeline\n   **/\n\n\n  this.flush = function () {\n    var frames,\n        gopForFusion,\n        gops,\n        moof,\n        mdat,\n        boxes,\n        prependedContentDuration = 0,\n        firstGop,\n        lastGop; // Throw away nalUnits at the start of the byte stream until\n    // we find the first AUD\n\n    while (nalUnits.length) {\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n        break;\n      }\n\n      nalUnits.shift();\n    } // Return early if no video data has been observed\n\n\n    if (nalUnits.length === 0) {\n      this.resetStream_();\n      this.trigger('done', 'VideoSegmentStream');\n      return;\n    } // Organize the raw nal-units into arrays that represent\n    // higher-level constructs such as frames and gops\n    // (group-of-pictures)\n\n\n    frames = frameUtils.groupNalsIntoFrames(nalUnits);\n    gops = frameUtils.groupFramesIntoGops(frames); // If the first frame of this fragment is not a keyframe we have\n    // a problem since MSE (on Chrome) requires a leading keyframe.\n    //\n    // We have two approaches to repairing this situation:\n    // 1) GOP-FUSION:\n    //    This is where we keep track of the GOPS (group-of-pictures)\n    //    from previous fragments and attempt to find one that we can\n    //    prepend to the current fragment in order to create a valid\n    //    fragment.\n    // 2) KEYFRAME-PULLING:\n    //    Here we search for the first keyframe in the fragment and\n    //    throw away all the frames between the start of the fragment\n    //    and that keyframe. We then extend the duration and pull the\n    //    PTS of the keyframe forward so that it covers the time range\n    //    of the frames that were disposed of.\n    //\n    // #1 is far prefereable over #2 which can cause \"stuttering\" but\n    // requires more things to be just right.\n\n    if (!gops[0][0].keyFrame) {\n      // Search for a gop for fusion from our gopCache\n      gopForFusion = this.getGopForFusion_(nalUnits[0], track);\n\n      if (gopForFusion) {\n        // in order to provide more accurate timing information about the segment, save\n        // the number of seconds prepended to the original segment due to GOP fusion\n        prependedContentDuration = gopForFusion.duration;\n        gops.unshift(gopForFusion); // Adjust Gops' metadata to account for the inclusion of the\n        // new gop at the beginning\n\n        gops.byteLength += gopForFusion.byteLength;\n        gops.nalCount += gopForFusion.nalCount;\n        gops.pts = gopForFusion.pts;\n        gops.dts = gopForFusion.dts;\n        gops.duration += gopForFusion.duration;\n      } else {\n        // If we didn't find a candidate gop fall back to keyframe-pulling\n        gops = frameUtils.extendFirstKeyFrame(gops);\n      }\n    } // Trim gops to align with gopsToAlignWith\n\n\n    if (gopsToAlignWith.length) {\n      var alignedGops;\n\n      if (options.alignGopsAtEnd) {\n        alignedGops = this.alignGopsAtEnd_(gops);\n      } else {\n        alignedGops = this.alignGopsAtStart_(gops);\n      }\n\n      if (!alignedGops) {\n        // save all the nals in the last GOP into the gop cache\n        this.gopCache_.unshift({\n          gop: gops.pop(),\n          pps: track.pps,\n          sps: track.sps\n        }); // Keep a maximum of 6 GOPs in the cache\n\n        this.gopCache_.length = Math.min(6, this.gopCache_.length); // Clear nalUnits\n\n        nalUnits = []; // return early no gops can be aligned with desired gopsToAlignWith\n\n        this.resetStream_();\n        this.trigger('done', 'VideoSegmentStream');\n        return;\n      } // Some gops were trimmed. clear dts info so minSegmentDts and pts are correct\n      // when recalculated before sending off to CoalesceStream\n\n\n      trackDecodeInfo.clearDtsInfo(track);\n      gops = alignedGops;\n    }\n\n    trackDecodeInfo.collectDtsInfo(track, gops); // First, we have to build the index from byte locations to\n    // samples (that is, frames) in the video data\n\n    track.samples = frameUtils.generateSampleTable(gops); // Concatenate the video data and construct the mdat\n\n    mdat = mp4.mdat(frameUtils.concatenateNalData(gops));\n    track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n    this.trigger('processedGopsInfo', gops.map(function (gop) {\n      return {\n        pts: gop.pts,\n        dts: gop.dts,\n        byteLength: gop.byteLength\n      };\n    }));\n    firstGop = gops[0];\n    lastGop = gops[gops.length - 1];\n    this.trigger('segmentTimingInfo', generateSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration));\n    this.trigger('timingInfo', {\n      start: gops[0].pts,\n      end: gops[gops.length - 1].pts + gops[gops.length - 1].duration\n    }); // save all the nals in the last GOP into the gop cache\n\n    this.gopCache_.unshift({\n      gop: gops.pop(),\n      pps: track.pps,\n      sps: track.sps\n    }); // Keep a maximum of 6 GOPs in the cache\n\n    this.gopCache_.length = Math.min(6, this.gopCache_.length); // Clear nalUnits\n\n    nalUnits = [];\n    this.trigger('baseMediaDecodeTime', track.baseMediaDecodeTime);\n    this.trigger('timelineStartInfo', track.timelineStartInfo);\n    moof = mp4.moof(sequenceNumber, [track]); // it would be great to allocate this array up front instead of\n    // throwing away hundreds of media segment fragments\n\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength); // Bump the sequence number for next time\n\n    sequenceNumber++;\n    boxes.set(moof);\n    boxes.set(mdat, moof.byteLength);\n    this.trigger('data', {\n      track: track,\n      boxes: boxes\n    });\n    this.resetStream_(); // Continue with the flush process now\n\n    this.trigger('done', 'VideoSegmentStream');\n  };\n\n  this.reset = function () {\n    this.resetStream_();\n    nalUnits = [];\n    this.gopCache_.length = 0;\n    gopsToAlignWith.length = 0;\n    this.trigger('reset');\n  };\n\n  this.resetStream_ = function () {\n    trackDecodeInfo.clearDtsInfo(track); // reset config and pps because they may differ across segments\n    // for instance, when we are rendition switching\n\n    config = undefined;\n    pps = undefined;\n  }; // Search for a candidate Gop for gop-fusion from the gop cache and\n  // return it or return null if no good candidate was found\n\n\n  this.getGopForFusion_ = function (nalUnit) {\n    var halfSecond = 45000,\n        // Half-a-second in a 90khz clock\n    allowableOverlap = 10000,\n        // About 3 frames @ 30fps\n    nearestDistance = Infinity,\n        dtsDistance,\n        nearestGopObj,\n        currentGop,\n        currentGopObj,\n        i; // Search for the GOP nearest to the beginning of this nal unit\n\n    for (i = 0; i < this.gopCache_.length; i++) {\n      currentGopObj = this.gopCache_[i];\n      currentGop = currentGopObj.gop; // Reject Gops with different SPS or PPS\n\n      if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\n        continue;\n      } // Reject Gops that would require a negative baseMediaDecodeTime\n\n\n      if (currentGop.dts < track.timelineStartInfo.dts) {\n        continue;\n      } // The distance between the end of the gop and the start of the nalUnit\n\n\n      dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration; // Only consider GOPS that start before the nal unit and end within\n      // a half-second of the nal unit\n\n      if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) {\n        // Always use the closest GOP we found if there is more than\n        // one candidate\n        if (!nearestGopObj || nearestDistance > dtsDistance) {\n          nearestGopObj = currentGopObj;\n          nearestDistance = dtsDistance;\n        }\n      }\n    }\n\n    if (nearestGopObj) {\n      return nearestGopObj.gop;\n    }\n\n    return null;\n  }; // trim gop list to the first gop found that has a matching pts with a gop in the list\n  // of gopsToAlignWith starting from the START of the list\n\n\n  this.alignGopsAtStart_ = function (gops) {\n    var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;\n    byteLength = gops.byteLength;\n    nalCount = gops.nalCount;\n    duration = gops.duration;\n    alignIndex = gopIndex = 0;\n\n    while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {\n      align = gopsToAlignWith[alignIndex];\n      gop = gops[gopIndex];\n\n      if (align.pts === gop.pts) {\n        break;\n      }\n\n      if (gop.pts > align.pts) {\n        // this current gop starts after the current gop we want to align on, so increment\n        // align index\n        alignIndex++;\n        continue;\n      } // current gop starts before the current gop we want to align on. so increment gop\n      // index\n\n\n      gopIndex++;\n      byteLength -= gop.byteLength;\n      nalCount -= gop.nalCount;\n      duration -= gop.duration;\n    }\n\n    if (gopIndex === 0) {\n      // no gops to trim\n      return gops;\n    }\n\n    if (gopIndex === gops.length) {\n      // all gops trimmed, skip appending all gops\n      return null;\n    }\n\n    alignedGops = gops.slice(gopIndex);\n    alignedGops.byteLength = byteLength;\n    alignedGops.duration = duration;\n    alignedGops.nalCount = nalCount;\n    alignedGops.pts = alignedGops[0].pts;\n    alignedGops.dts = alignedGops[0].dts;\n    return alignedGops;\n  }; // trim gop list to the first gop found that has a matching pts with a gop in the list\n  // of gopsToAlignWith starting from the END of the list\n\n\n  this.alignGopsAtEnd_ = function (gops) {\n    var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;\n    alignIndex = gopsToAlignWith.length - 1;\n    gopIndex = gops.length - 1;\n    alignEndIndex = null;\n    matchFound = false;\n\n    while (alignIndex >= 0 && gopIndex >= 0) {\n      align = gopsToAlignWith[alignIndex];\n      gop = gops[gopIndex];\n\n      if (align.pts === gop.pts) {\n        matchFound = true;\n        break;\n      }\n\n      if (align.pts > gop.pts) {\n        alignIndex--;\n        continue;\n      }\n\n      if (alignIndex === gopsToAlignWith.length - 1) {\n        // gop.pts is greater than the last alignment candidate. If no match is found\n        // by the end of this loop, we still want to append gops that come after this\n        // point\n        alignEndIndex = gopIndex;\n      }\n\n      gopIndex--;\n    }\n\n    if (!matchFound && alignEndIndex === null) {\n      return null;\n    }\n\n    var trimIndex;\n\n    if (matchFound) {\n      trimIndex = gopIndex;\n    } else {\n      trimIndex = alignEndIndex;\n    }\n\n    if (trimIndex === 0) {\n      return gops;\n    }\n\n    var alignedGops = gops.slice(trimIndex);\n    var metadata = alignedGops.reduce(function (total, gop) {\n      total.byteLength += gop.byteLength;\n      total.duration += gop.duration;\n      total.nalCount += gop.nalCount;\n      return total;\n    }, {\n      byteLength: 0,\n      duration: 0,\n      nalCount: 0\n    });\n    alignedGops.byteLength = metadata.byteLength;\n    alignedGops.duration = metadata.duration;\n    alignedGops.nalCount = metadata.nalCount;\n    alignedGops.pts = alignedGops[0].pts;\n    alignedGops.dts = alignedGops[0].dts;\n    return alignedGops;\n  };\n\n  this.alignGopsWith = function (newGopsToAlignWith) {\n    gopsToAlignWith = newGopsToAlignWith;\n  };\n};\n\n_VideoSegmentStream.prototype = new Stream();\n/**\n * A Stream that can combine multiple streams (ie. audio & video)\n * into a single output segment for MSE. Also supports audio-only\n * and video-only streams.\n * @param options {object} transmuxer options object\n * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n *        in the source; false to adjust the first segment to start at media timeline start.\n */\n\n_CoalesceStream = function CoalesceStream(options, metadataStream) {\n  // Number of Tracks per output segment\n  // If greater than 1, we combine multiple\n  // tracks into a single segment\n  this.numberOfTracks = 0;\n  this.metadataStream = metadataStream;\n  options = options || {};\n\n  if (typeof options.remux !== 'undefined') {\n    this.remuxTracks = !!options.remux;\n  } else {\n    this.remuxTracks = true;\n  }\n\n  if (typeof options.keepOriginalTimestamps === 'boolean') {\n    this.keepOriginalTimestamps = options.keepOriginalTimestamps;\n  } else {\n    this.keepOriginalTimestamps = false;\n  }\n\n  this.pendingTracks = [];\n  this.videoTrack = null;\n  this.pendingBoxes = [];\n  this.pendingCaptions = [];\n  this.pendingMetadata = [];\n  this.pendingBytes = 0;\n  this.emittedTracks = 0;\n\n  _CoalesceStream.prototype.init.call(this); // Take output from multiple\n\n\n  this.push = function (output) {\n    // buffer incoming captions until the associated video segment\n    // finishes\n    if (output.text) {\n      return this.pendingCaptions.push(output);\n    } // buffer incoming id3 tags until the final flush\n\n\n    if (output.frames) {\n      return this.pendingMetadata.push(output);\n    } // Add this track to the list of pending tracks and store\n    // important information required for the construction of\n    // the final segment\n\n\n    this.pendingTracks.push(output.track);\n    this.pendingBytes += output.boxes.byteLength; // TODO: is there an issue for this against chrome?\n    // We unshift audio and push video because\n    // as of Chrome 75 when switching from\n    // one init segment to another if the video\n    // mdat does not appear after the audio mdat\n    // only audio will play for the duration of our transmux.\n\n    if (output.track.type === 'video') {\n      this.videoTrack = output.track;\n      this.pendingBoxes.push(output.boxes);\n    }\n\n    if (output.track.type === 'audio') {\n      this.audioTrack = output.track;\n      this.pendingBoxes.unshift(output.boxes);\n    }\n  };\n};\n\n_CoalesceStream.prototype = new Stream();\n\n_CoalesceStream.prototype.flush = function (flushSource) {\n  var offset = 0,\n      event = {\n    captions: [],\n    captionStreams: {},\n    metadata: [],\n    info: {}\n  },\n      caption,\n      id3,\n      initSegment,\n      timelineStartPts = 0,\n      i;\n\n  if (this.pendingTracks.length < this.numberOfTracks) {\n    if (flushSource !== 'VideoSegmentStream' && flushSource !== 'AudioSegmentStream') {\n      // Return because we haven't received a flush from a data-generating\n      // portion of the segment (meaning that we have only recieved meta-data\n      // or captions.)\n      return;\n    } else if (this.remuxTracks) {\n      // Return until we have enough tracks from the pipeline to remux (if we\n      // are remuxing audio and video into a single MP4)\n      return;\n    } else if (this.pendingTracks.length === 0) {\n      // In the case where we receive a flush without any data having been\n      // received we consider it an emitted track for the purposes of coalescing\n      // `done` events.\n      // We do this for the case where there is an audio and video track in the\n      // segment but no audio data. (seen in several playlists with alternate\n      // audio tracks and no audio present in the main TS segments.)\n      this.emittedTracks++;\n\n      if (this.emittedTracks >= this.numberOfTracks) {\n        this.trigger('done');\n        this.emittedTracks = 0;\n      }\n\n      return;\n    }\n  }\n\n  if (this.videoTrack) {\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n    VIDEO_PROPERTIES.forEach(function (prop) {\n      event.info[prop] = this.videoTrack[prop];\n    }, this);\n  } else if (this.audioTrack) {\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n    AUDIO_PROPERTIES.forEach(function (prop) {\n      event.info[prop] = this.audioTrack[prop];\n    }, this);\n  }\n\n  if (this.videoTrack || this.audioTrack) {\n    if (this.pendingTracks.length === 1) {\n      event.type = this.pendingTracks[0].type;\n    } else {\n      event.type = 'combined';\n    }\n\n    this.emittedTracks += this.pendingTracks.length;\n    initSegment = mp4.initSegment(this.pendingTracks); // Create a new typed array to hold the init segment\n\n    event.initSegment = new Uint8Array(initSegment.byteLength); // Create an init segment containing a moov\n    // and track definitions\n\n    event.initSegment.set(initSegment); // Create a new typed array to hold the moof+mdats\n\n    event.data = new Uint8Array(this.pendingBytes); // Append each moof+mdat (one per track) together\n\n    for (i = 0; i < this.pendingBoxes.length; i++) {\n      event.data.set(this.pendingBoxes[i], offset);\n      offset += this.pendingBoxes[i].byteLength;\n    } // Translate caption PTS times into second offsets to match the\n    // video timeline for the segment, and add track info\n\n\n    for (i = 0; i < this.pendingCaptions.length; i++) {\n      caption = this.pendingCaptions[i];\n      caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps);\n      caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps);\n      event.captionStreams[caption.stream] = true;\n      event.captions.push(caption);\n    } // Translate ID3 frame PTS times into second offsets to match the\n    // video timeline for the segment\n\n\n    for (i = 0; i < this.pendingMetadata.length; i++) {\n      id3 = this.pendingMetadata[i];\n      id3.cueTime = clock.metadataTsToSeconds(id3.pts, timelineStartPts, this.keepOriginalTimestamps);\n      event.metadata.push(id3);\n    } // We add this to every single emitted segment even though we only need\n    // it for the first\n\n\n    event.metadata.dispatchType = this.metadataStream.dispatchType; // Reset stream state\n\n    this.pendingTracks.length = 0;\n    this.videoTrack = null;\n    this.pendingBoxes.length = 0;\n    this.pendingCaptions.length = 0;\n    this.pendingBytes = 0;\n    this.pendingMetadata.length = 0; // Emit the built segment\n    // We include captions and ID3 tags for backwards compatibility,\n    // ideally we should send only video and audio in the data event\n\n    this.trigger('data', event); // Emit each caption to the outside world\n    // Ideally, this would happen immediately on parsing captions,\n    // but we need to ensure that video data is sent back first\n    // so that caption timing can be adjusted to match video timing\n\n    for (i = 0; i < event.captions.length; i++) {\n      caption = event.captions[i];\n      this.trigger('caption', caption);\n    } // Emit each id3 tag to the outside world\n    // Ideally, this would happen immediately on parsing the tag,\n    // but we need to ensure that video data is sent back first\n    // so that ID3 frame timing can be adjusted to match video timing\n\n\n    for (i = 0; i < event.metadata.length; i++) {\n      id3 = event.metadata[i];\n      this.trigger('id3Frame', id3);\n    }\n  } // Only emit `done` if all tracks have been flushed and emitted\n\n\n  if (this.emittedTracks >= this.numberOfTracks) {\n    this.trigger('done');\n    this.emittedTracks = 0;\n  }\n};\n\n_CoalesceStream.prototype.setRemux = function (val) {\n  this.remuxTracks = val;\n};\n/**\n * A Stream that expects MP2T binary data as input and produces\n * corresponding media segments, suitable for use with Media Source\n * Extension (MSE) implementations that support the ISO BMFF byte\n * stream format, like Chrome.\n */\n\n\n_Transmuxer = function Transmuxer(options) {\n  var self = this,\n      hasFlushed = true,\n      videoTrack,\n      audioTrack;\n\n  _Transmuxer.prototype.init.call(this);\n\n  options = options || {};\n  this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n  this.transmuxPipeline_ = {};\n\n  this.setupAacPipeline = function () {\n    var pipeline = {};\n    this.transmuxPipeline_ = pipeline;\n    pipeline.type = 'aac';\n    pipeline.metadataStream = new m2ts.MetadataStream(); // set up the parsing pipeline\n\n    pipeline.aacStream = new AacStream();\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n    pipeline.adtsStream = new AdtsStream();\n    pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);\n    pipeline.headOfPipeline = pipeline.aacStream;\n    pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);\n    pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);\n    pipeline.metadataStream.on('timestamp', function (frame) {\n      pipeline.aacStream.setTimestamp(frame.timeStamp);\n    });\n    pipeline.aacStream.on('data', function (data) {\n      if (data.type !== 'timed-metadata' && data.type !== 'audio' || pipeline.audioSegmentStream) {\n        return;\n      }\n\n      audioTrack = audioTrack || {\n        timelineStartInfo: {\n          baseMediaDecodeTime: self.baseMediaDecodeTime\n        },\n        codec: 'adts',\n        type: 'audio'\n      }; // hook up the audio segment stream to the first track with aac data\n\n      pipeline.coalesceStream.numberOfTracks++;\n      pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options);\n      pipeline.audioSegmentStream.on('log', self.getLogTrigger_('audioSegmentStream'));\n      pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo')); // Set up the final part of the audio pipeline\n\n      pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream); // emit pmt info\n\n      self.trigger('trackinfo', {\n        hasAudio: !!audioTrack,\n        hasVideo: !!videoTrack\n      });\n    }); // Re-emit any data coming from the coalesce stream to the outside world\n\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data')); // Let the consumer know we have finished flushing the entire pipeline\n\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n    addPipelineLogRetriggers(this, pipeline);\n  };\n\n  this.setupTsPipeline = function () {\n    var pipeline = {};\n    this.transmuxPipeline_ = pipeline;\n    pipeline.type = 'ts';\n    pipeline.metadataStream = new m2ts.MetadataStream(); // set up the parsing pipeline\n\n    pipeline.packetStream = new m2ts.TransportPacketStream();\n    pipeline.parseStream = new m2ts.TransportParseStream();\n    pipeline.elementaryStream = new m2ts.ElementaryStream();\n    pipeline.timestampRolloverStream = new m2ts.TimestampRolloverStream();\n    pipeline.adtsStream = new AdtsStream();\n    pipeline.h264Stream = new H264Stream();\n    pipeline.captionStream = new m2ts.CaptionStream(options);\n    pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);\n    pipeline.headOfPipeline = pipeline.packetStream; // disassemble MPEG2-TS packets into elementary streams\n\n    pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream); // !!THIS ORDER IS IMPORTANT!!\n    // demux the streams\n\n    pipeline.timestampRolloverStream.pipe(pipeline.h264Stream);\n    pipeline.timestampRolloverStream.pipe(pipeline.adtsStream);\n    pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream); // Hook up CEA-608/708 caption stream\n\n    pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);\n    pipeline.elementaryStream.on('data', function (data) {\n      var i;\n\n      if (data.type === 'metadata') {\n        i = data.tracks.length; // scan the tracks listed in the metadata\n\n        while (i--) {\n          if (!videoTrack && data.tracks[i].type === 'video') {\n            videoTrack = data.tracks[i];\n            videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n          } else if (!audioTrack && data.tracks[i].type === 'audio') {\n            audioTrack = data.tracks[i];\n            audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n          }\n        } // hook up the video segment stream to the first track with h264 data\n\n\n        if (videoTrack && !pipeline.videoSegmentStream) {\n          pipeline.coalesceStream.numberOfTracks++;\n          pipeline.videoSegmentStream = new _VideoSegmentStream(videoTrack, options);\n          pipeline.videoSegmentStream.on('log', self.getLogTrigger_('videoSegmentStream'));\n          pipeline.videoSegmentStream.on('timelineStartInfo', function (timelineStartInfo) {\n            // When video emits timelineStartInfo data after a flush, we forward that\n            // info to the AudioSegmentStream, if it exists, because video timeline\n            // data takes precedence.  Do not do this if keepOriginalTimestamps is set,\n            // because this is a particularly subtle form of timestamp alteration.\n            if (audioTrack && !options.keepOriginalTimestamps) {\n              audioTrack.timelineStartInfo = timelineStartInfo; // On the first segment we trim AAC frames that exist before the\n              // very earliest DTS we have seen in video because Chrome will\n              // interpret any video track with a baseMediaDecodeTime that is\n              // non-zero as a gap.\n\n              pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self.baseMediaDecodeTime);\n            }\n          });\n          pipeline.videoSegmentStream.on('processedGopsInfo', self.trigger.bind(self, 'gopInfo'));\n          pipeline.videoSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'videoSegmentTimingInfo'));\n          pipeline.videoSegmentStream.on('baseMediaDecodeTime', function (baseMediaDecodeTime) {\n            if (audioTrack) {\n              pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);\n            }\n          });\n          pipeline.videoSegmentStream.on('timingInfo', self.trigger.bind(self, 'videoTimingInfo')); // Set up the final part of the video pipeline\n\n          pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);\n        }\n\n        if (audioTrack && !pipeline.audioSegmentStream) {\n          // hook up the audio segment stream to the first track with aac data\n          pipeline.coalesceStream.numberOfTracks++;\n          pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options);\n          pipeline.audioSegmentStream.on('log', self.getLogTrigger_('audioSegmentStream'));\n          pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo'));\n          pipeline.audioSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'audioSegmentTimingInfo')); // Set up the final part of the audio pipeline\n\n          pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);\n        } // emit pmt info\n\n\n        self.trigger('trackinfo', {\n          hasAudio: !!audioTrack,\n          hasVideo: !!videoTrack\n        });\n      }\n    }); // Re-emit any data coming from the coalesce stream to the outside world\n\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n    pipeline.coalesceStream.on('id3Frame', function (id3Frame) {\n      id3Frame.dispatchType = pipeline.metadataStream.dispatchType;\n      self.trigger('id3Frame', id3Frame);\n    });\n    pipeline.coalesceStream.on('caption', this.trigger.bind(this, 'caption')); // Let the consumer know we have finished flushing the entire pipeline\n\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n    addPipelineLogRetriggers(this, pipeline);\n  }; // hook up the segment streams once track metadata is delivered\n\n\n  this.setBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n    var pipeline = this.transmuxPipeline_;\n\n    if (!options.keepOriginalTimestamps) {\n      this.baseMediaDecodeTime = baseMediaDecodeTime;\n    }\n\n    if (audioTrack) {\n      audioTrack.timelineStartInfo.dts = undefined;\n      audioTrack.timelineStartInfo.pts = undefined;\n      trackDecodeInfo.clearDtsInfo(audioTrack);\n\n      if (pipeline.audioTimestampRolloverStream) {\n        pipeline.audioTimestampRolloverStream.discontinuity();\n      }\n    }\n\n    if (videoTrack) {\n      if (pipeline.videoSegmentStream) {\n        pipeline.videoSegmentStream.gopCache_ = [];\n      }\n\n      videoTrack.timelineStartInfo.dts = undefined;\n      videoTrack.timelineStartInfo.pts = undefined;\n      trackDecodeInfo.clearDtsInfo(videoTrack);\n      pipeline.captionStream.reset();\n    }\n\n    if (pipeline.timestampRolloverStream) {\n      pipeline.timestampRolloverStream.discontinuity();\n    }\n  };\n\n  this.setAudioAppendStart = function (timestamp) {\n    if (audioTrack) {\n      this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);\n    }\n  };\n\n  this.setRemux = function (val) {\n    var pipeline = this.transmuxPipeline_;\n    options.remux = val;\n\n    if (pipeline && pipeline.coalesceStream) {\n      pipeline.coalesceStream.setRemux(val);\n    }\n  };\n\n  this.alignGopsWith = function (gopsToAlignWith) {\n    if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {\n      this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);\n    }\n  };\n\n  this.getLogTrigger_ = function (key) {\n    var self = this;\n    return function (event) {\n      event.stream = key;\n      self.trigger('log', event);\n    };\n  }; // feed incoming data to the front of the parsing pipeline\n\n\n  this.push = function (data) {\n    if (hasFlushed) {\n      var isAac = isLikelyAacData(data);\n\n      if (isAac && this.transmuxPipeline_.type !== 'aac') {\n        this.setupAacPipeline();\n      } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\n        this.setupTsPipeline();\n      }\n\n      hasFlushed = false;\n    }\n\n    this.transmuxPipeline_.headOfPipeline.push(data);\n  }; // flush any buffered data\n\n\n  this.flush = function () {\n    hasFlushed = true; // Start at the top of the pipeline and flush all pending work\n\n    this.transmuxPipeline_.headOfPipeline.flush();\n  };\n\n  this.endTimeline = function () {\n    this.transmuxPipeline_.headOfPipeline.endTimeline();\n  };\n\n  this.reset = function () {\n    if (this.transmuxPipeline_.headOfPipeline) {\n      this.transmuxPipeline_.headOfPipeline.reset();\n    }\n  }; // Caption data has to be reset when seeking outside buffered range\n\n\n  this.resetCaptions = function () {\n    if (this.transmuxPipeline_.captionStream) {\n      this.transmuxPipeline_.captionStream.reset();\n    }\n  };\n};\n\n_Transmuxer.prototype = new Stream();\nmodule.exports = {\n  Transmuxer: _Transmuxer,\n  VideoSegmentStream: _VideoSegmentStream,\n  AudioSegmentStream: _AudioSegmentStream,\n  AUDIO_PROPERTIES: AUDIO_PROPERTIES,\n  VIDEO_PROPERTIES: VIDEO_PROPERTIES,\n  // exported for testing\n  generateSegmentTimingInfo: generateSegmentTimingInfo\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Reads in-band CEA-708 captions out of FMP4 segments.\n * @see https://en.wikipedia.org/wiki/CEA-708\n */\n'use strict';\n\nvar discardEmulationPreventionBytes = require('../tools/caption-packet-parser').discardEmulationPreventionBytes;\n\nvar CaptionStream = require('../m2ts/caption-stream').CaptionStream;\n\nvar findBox = require('../mp4/find-box.js');\n\nvar parseTfdt = require('../tools/parse-tfdt.js');\n\nvar parseTrun = require('../tools/parse-trun.js');\n\nvar parseTfhd = require('../tools/parse-tfhd.js');\n/**\n  * Maps an offset in the mdat to a sample based on the the size of the samples.\n  * Assumes that `parseSamples` has been called first.\n  *\n  * @param {Number} offset - The offset into the mdat\n  * @param {Object[]} samples - An array of samples, parsed using `parseSamples`\n  * @return {?Object} The matching sample, or null if no match was found.\n  *\n  * @see ISO-BMFF-12/2015, Section 8.8.8\n **/\n\n\nvar mapToSample = function mapToSample(offset, samples) {\n  var approximateOffset = offset;\n\n  for (var i = 0; i < samples.length; i++) {\n    var sample = samples[i];\n\n    if (approximateOffset < sample.size) {\n      return sample;\n    }\n\n    approximateOffset -= sample.size;\n  }\n\n  return null;\n};\n/**\n  * Finds SEI nal units contained in a Media Data Box.\n  * Assumes that `parseSamples` has been called first.\n  *\n  * @param {Uint8Array} avcStream - The bytes of the mdat\n  * @param {Object[]} samples - The samples parsed out by `parseSamples`\n  * @param {Number} trackId - The trackId of this video track\n  * @return {Object[]} seiNals - the parsed SEI NALUs found.\n  *   The contents of the seiNal should match what is expected by\n  *   CaptionStream.push (nalUnitType, size, data, escapedRBSP, pts, dts)\n  *\n  * @see ISO-BMFF-12/2015, Section 8.1.1\n  * @see Rec. ITU-T H.264, 7.3.2.3.1\n **/\n\n\nvar findSeiNals = function findSeiNals(avcStream, samples, trackId) {\n  var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n      result = {\n    logs: [],\n    seiNals: []\n  },\n      seiNal,\n      i,\n      length,\n      lastMatchedSample;\n\n  for (i = 0; i + 4 < avcStream.length; i += length) {\n    length = avcView.getUint32(i);\n    i += 4; // Bail if this doesn't appear to be an H264 stream\n\n    if (length <= 0) {\n      continue;\n    }\n\n    switch (avcStream[i] & 0x1F) {\n      case 0x06:\n        var data = avcStream.subarray(i + 1, i + 1 + length);\n        var matchingSample = mapToSample(i, samples);\n        seiNal = {\n          nalUnitType: 'sei_rbsp',\n          size: length,\n          data: data,\n          escapedRBSP: discardEmulationPreventionBytes(data),\n          trackId: trackId\n        };\n\n        if (matchingSample) {\n          seiNal.pts = matchingSample.pts;\n          seiNal.dts = matchingSample.dts;\n          lastMatchedSample = matchingSample;\n        } else if (lastMatchedSample) {\n          // If a matching sample cannot be found, use the last\n          // sample's values as they should be as close as possible\n          seiNal.pts = lastMatchedSample.pts;\n          seiNal.dts = lastMatchedSample.dts;\n        } else {\n          result.logs.push({\n            level: 'warn',\n            message: 'We\\'ve encountered a nal unit without data at ' + i + ' for trackId ' + trackId + '. See mux.js#223.'\n          });\n          break;\n        }\n\n        result.seiNals.push(seiNal);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  return result;\n};\n/**\n  * Parses sample information out of Track Run Boxes and calculates\n  * the absolute presentation and decode timestamps of each sample.\n  *\n  * @param {Array<Uint8Array>} truns - The Trun Run boxes to be parsed\n  * @param {Number} baseMediaDecodeTime - base media decode time from tfdt\n      @see ISO-BMFF-12/2015, Section 8.8.12\n  * @param {Object} tfhd - The parsed Track Fragment Header\n  *   @see inspect.parseTfhd\n  * @return {Object[]} the parsed samples\n  *\n  * @see ISO-BMFF-12/2015, Section 8.8.8\n **/\n\n\nvar parseSamples = function parseSamples(truns, baseMediaDecodeTime, tfhd) {\n  var currentDts = baseMediaDecodeTime;\n  var defaultSampleDuration = tfhd.defaultSampleDuration || 0;\n  var defaultSampleSize = tfhd.defaultSampleSize || 0;\n  var trackId = tfhd.trackId;\n  var allSamples = [];\n  truns.forEach(function (trun) {\n    // Note: We currently do not parse the sample table as well\n    // as the trun. It's possible some sources will require this.\n    // moov > trak > mdia > minf > stbl\n    var trackRun = parseTrun(trun);\n    var samples = trackRun.samples;\n    samples.forEach(function (sample) {\n      if (sample.duration === undefined) {\n        sample.duration = defaultSampleDuration;\n      }\n\n      if (sample.size === undefined) {\n        sample.size = defaultSampleSize;\n      }\n\n      sample.trackId = trackId;\n      sample.dts = currentDts;\n\n      if (sample.compositionTimeOffset === undefined) {\n        sample.compositionTimeOffset = 0;\n      }\n\n      sample.pts = currentDts + sample.compositionTimeOffset;\n      currentDts += sample.duration;\n    });\n    allSamples = allSamples.concat(samples);\n  });\n  return allSamples;\n};\n/**\n  * Parses out caption nals from an FMP4 segment's video tracks.\n  *\n  * @param {Uint8Array} segment - The bytes of a single segment\n  * @param {Number} videoTrackId - The trackId of a video track in the segment\n  * @return {Object.<Number, Object[]>} A mapping of video trackId to\n  *   a list of seiNals found in that track\n **/\n\n\nvar parseCaptionNals = function parseCaptionNals(segment, videoTrackId) {\n  // To get the samples\n  var trafs = findBox(segment, ['moof', 'traf']); // To get SEI NAL units\n\n  var mdats = findBox(segment, ['mdat']);\n  var captionNals = {};\n  var mdatTrafPairs = []; // Pair up each traf with a mdat as moofs and mdats are in pairs\n\n  mdats.forEach(function (mdat, index) {\n    var matchingTraf = trafs[index];\n    mdatTrafPairs.push({\n      mdat: mdat,\n      traf: matchingTraf\n    });\n  });\n  mdatTrafPairs.forEach(function (pair) {\n    var mdat = pair.mdat;\n    var traf = pair.traf;\n    var tfhd = findBox(traf, ['tfhd']); // Exactly 1 tfhd per traf\n\n    var headerInfo = parseTfhd(tfhd[0]);\n    var trackId = headerInfo.trackId;\n    var tfdt = findBox(traf, ['tfdt']); // Either 0 or 1 tfdt per traf\n\n    var baseMediaDecodeTime = tfdt.length > 0 ? parseTfdt(tfdt[0]).baseMediaDecodeTime : 0;\n    var truns = findBox(traf, ['trun']);\n    var samples;\n    var result; // Only parse video data for the chosen video track\n\n    if (videoTrackId === trackId && truns.length > 0) {\n      samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);\n      result = findSeiNals(mdat, samples, trackId);\n\n      if (!captionNals[trackId]) {\n        captionNals[trackId] = {\n          seiNals: [],\n          logs: []\n        };\n      }\n\n      captionNals[trackId].seiNals = captionNals[trackId].seiNals.concat(result.seiNals);\n      captionNals[trackId].logs = captionNals[trackId].logs.concat(result.logs);\n    }\n  });\n  return captionNals;\n};\n/**\n  * Parses out inband captions from an MP4 container and returns\n  * caption objects that can be used by WebVTT and the TextTrack API.\n  * @see https://developer.mozilla.org/en-US/docs/Web/API/VTTCue\n  * @see https://developer.mozilla.org/en-US/docs/Web/API/TextTrack\n  * Assumes that `probe.getVideoTrackIds` and `probe.timescale` have been called first\n  *\n  * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n  * @param {Number} trackId - The id of the video track to parse\n  * @param {Number} timescale - The timescale for the video track from the init segment\n  *\n  * @return {?Object[]} parsedCaptions - A list of captions or null if no video tracks\n  * @return {Number} parsedCaptions[].startTime - The time to show the caption in seconds\n  * @return {Number} parsedCaptions[].endTime - The time to stop showing the caption in seconds\n  * @return {String} parsedCaptions[].text - The visible content of the caption\n **/\n\n\nvar parseEmbeddedCaptions = function parseEmbeddedCaptions(segment, trackId, timescale) {\n  var captionNals; // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n\n  if (trackId === null) {\n    return null;\n  }\n\n  captionNals = parseCaptionNals(segment, trackId);\n  var trackNals = captionNals[trackId] || {};\n  return {\n    seiNals: trackNals.seiNals,\n    logs: trackNals.logs,\n    timescale: timescale\n  };\n};\n/**\n  * Converts SEI NALUs into captions that can be used by video.js\n **/\n\n\nvar CaptionParser = function CaptionParser() {\n  var isInitialized = false;\n  var captionStream; // Stores segments seen before trackId and timescale are set\n\n  var segmentCache; // Stores video track ID of the track being parsed\n\n  var trackId; // Stores the timescale of the track being parsed\n\n  var timescale; // Stores captions parsed so far\n\n  var parsedCaptions; // Stores whether we are receiving partial data or not\n\n  var parsingPartial;\n  /**\n    * A method to indicate whether a CaptionParser has been initalized\n    * @returns {Boolean}\n   **/\n\n  this.isInitialized = function () {\n    return isInitialized;\n  };\n  /**\n    * Initializes the underlying CaptionStream, SEI NAL parsing\n    * and management, and caption collection\n   **/\n\n\n  this.init = function (options) {\n    captionStream = new CaptionStream();\n    isInitialized = true;\n    parsingPartial = options ? options.isPartial : false; // Collect dispatched captions\n\n    captionStream.on('data', function (event) {\n      // Convert to seconds in the source's timescale\n      event.startTime = event.startPts / timescale;\n      event.endTime = event.endPts / timescale;\n      parsedCaptions.captions.push(event);\n      parsedCaptions.captionStreams[event.stream] = true;\n    });\n    captionStream.on('log', function (log) {\n      parsedCaptions.logs.push(log);\n    });\n  };\n  /**\n    * Determines if a new video track will be selected\n    * or if the timescale changed\n    * @return {Boolean}\n   **/\n\n\n  this.isNewInit = function (videoTrackIds, timescales) {\n    if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === 'object' && Object.keys(timescales).length === 0) {\n      return false;\n    }\n\n    return trackId !== videoTrackIds[0] || timescale !== timescales[trackId];\n  };\n  /**\n    * Parses out SEI captions and interacts with underlying\n    * CaptionStream to return dispatched captions\n    *\n    * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n    * @param {Number[]} videoTrackIds - A list of video tracks found in the init segment\n    * @param {Object.<Number, Number>} timescales - The timescales found in the init segment\n    * @see parseEmbeddedCaptions\n    * @see m2ts/caption-stream.js\n   **/\n\n\n  this.parse = function (segment, videoTrackIds, timescales) {\n    var parsedData;\n\n    if (!this.isInitialized()) {\n      return null; // This is not likely to be a video segment\n    } else if (!videoTrackIds || !timescales) {\n      return null;\n    } else if (this.isNewInit(videoTrackIds, timescales)) {\n      // Use the first video track only as there is no\n      // mechanism to switch to other video tracks\n      trackId = videoTrackIds[0];\n      timescale = timescales[trackId]; // If an init segment has not been seen yet, hold onto segment\n      // data until we have one.\n      // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n    } else if (trackId === null || !timescale) {\n      segmentCache.push(segment);\n      return null;\n    } // Now that a timescale and trackId is set, parse cached segments\n\n\n    while (segmentCache.length > 0) {\n      var cachedSegment = segmentCache.shift();\n      this.parse(cachedSegment, videoTrackIds, timescales);\n    }\n\n    parsedData = parseEmbeddedCaptions(segment, trackId, timescale);\n\n    if (parsedData && parsedData.logs) {\n      parsedCaptions.logs = parsedCaptions.logs.concat(parsedData.logs);\n    }\n\n    if (parsedData === null || !parsedData.seiNals) {\n      if (parsedCaptions.logs.length) {\n        return {\n          logs: parsedCaptions.logs,\n          captions: [],\n          captionStreams: []\n        };\n      }\n\n      return null;\n    }\n\n    this.pushNals(parsedData.seiNals); // Force the parsed captions to be dispatched\n\n    this.flushStream();\n    return parsedCaptions;\n  };\n  /**\n    * Pushes SEI NALUs onto CaptionStream\n    * @param {Object[]} nals - A list of SEI nals parsed using `parseCaptionNals`\n    * Assumes that `parseCaptionNals` has been called first\n    * @see m2ts/caption-stream.js\n    **/\n\n\n  this.pushNals = function (nals) {\n    if (!this.isInitialized() || !nals || nals.length === 0) {\n      return null;\n    }\n\n    nals.forEach(function (nal) {\n      captionStream.push(nal);\n    });\n  };\n  /**\n    * Flushes underlying CaptionStream to dispatch processed, displayable captions\n    * @see m2ts/caption-stream.js\n   **/\n\n\n  this.flushStream = function () {\n    if (!this.isInitialized()) {\n      return null;\n    }\n\n    if (!parsingPartial) {\n      captionStream.flush();\n    } else {\n      captionStream.partialFlush();\n    }\n  };\n  /**\n    * Reset caption buckets for new data\n   **/\n\n\n  this.clearParsedCaptions = function () {\n    parsedCaptions.captions = [];\n    parsedCaptions.captionStreams = {};\n    parsedCaptions.logs = [];\n  };\n  /**\n    * Resets underlying CaptionStream\n    * @see m2ts/caption-stream.js\n   **/\n\n\n  this.resetCaptionStream = function () {\n    if (!this.isInitialized()) {\n      return null;\n    }\n\n    captionStream.reset();\n  };\n  /**\n    * Convenience method to clear all captions flushed from the\n    * CaptionStream and still being parsed\n    * @see m2ts/caption-stream.js\n   **/\n\n\n  this.clearAllCaptions = function () {\n    this.clearParsedCaptions();\n    this.resetCaptionStream();\n  };\n  /**\n    * Reset caption parser\n   **/\n\n\n  this.reset = function () {\n    segmentCache = [];\n    trackId = null;\n    timescale = null;\n\n    if (!parsedCaptions) {\n      parsedCaptions = {\n        captions: [],\n        // CC1, CC2, CC3, CC4\n        captionStreams: {},\n        logs: []\n      };\n    } else {\n      this.clearParsedCaptions();\n    }\n\n    this.resetCaptionStream();\n  };\n\n  this.reset();\n};\n\nmodule.exports = CaptionParser;", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\nmodule.exports = {\n  generator: require('./mp4-generator'),\n  probe: require('./probe'),\n  Transmuxer: require('./transmuxer').Transmuxer,\n  AudioSegmentStream: require('./transmuxer').AudioSegmentStream,\n  VideoSegmentStream: require('./transmuxer').VideoSegmentStream,\n  CaptionParser: require('./caption-parser')\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * An object that stores the bytes of an FLV tag and methods for\n * querying and manipulating that data.\n * @see http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf\n */\n'use strict';\n\nvar _FlvTag; // (type:uint, extraData:Boolean = false) extends ByteArray\n\n\n_FlvTag = function FlvTag(type, extraData) {\n  var // Counter if this is a metadata tag, nal start marker if this is a video\n  // tag. unused if this is an audio tag\n  adHoc = 0,\n      // :uint\n  // The default size is 16kb but this is not enough to hold iframe\n  // data and the resizing algorithm costs a bit so we create a larger\n  // starting buffer for video tags\n  bufferStartSize = 16384,\n      // checks whether the FLV tag has enough capacity to accept the proposed\n  // write and re-allocates the internal buffers if necessary\n  prepareWrite = function prepareWrite(flv, count) {\n    var bytes,\n        minLength = flv.position + count;\n\n    if (minLength < flv.bytes.byteLength) {\n      // there's enough capacity so do nothing\n      return;\n    } // allocate a new buffer and copy over the data that will not be modified\n\n\n    bytes = new Uint8Array(minLength * 2);\n    bytes.set(flv.bytes.subarray(0, flv.position), 0);\n    flv.bytes = bytes;\n    flv.view = new DataView(flv.bytes.buffer);\n  },\n      // commonly used metadata properties\n  widthBytes = _FlvTag.widthBytes || new Uint8Array('width'.length),\n      heightBytes = _FlvTag.heightBytes || new Uint8Array('height'.length),\n      videocodecidBytes = _FlvTag.videocodecidBytes || new Uint8Array('videocodecid'.length),\n      i;\n\n  if (!_FlvTag.widthBytes) {\n    // calculating the bytes of common metadata names ahead of time makes the\n    // corresponding writes faster because we don't have to loop over the\n    // characters\n    // re-test with test/perf.html if you're planning on changing this\n    for (i = 0; i < 'width'.length; i++) {\n      widthBytes[i] = 'width'.charCodeAt(i);\n    }\n\n    for (i = 0; i < 'height'.length; i++) {\n      heightBytes[i] = 'height'.charCodeAt(i);\n    }\n\n    for (i = 0; i < 'videocodecid'.length; i++) {\n      videocodecidBytes[i] = 'videocodecid'.charCodeAt(i);\n    }\n\n    _FlvTag.widthBytes = widthBytes;\n    _FlvTag.heightBytes = heightBytes;\n    _FlvTag.videocodecidBytes = videocodecidBytes;\n  }\n\n  this.keyFrame = false; // :Boolean\n\n  switch (type) {\n    case _FlvTag.VIDEO_TAG:\n      this.length = 16; // Start the buffer at 256k\n\n      bufferStartSize *= 6;\n      break;\n\n    case _FlvTag.AUDIO_TAG:\n      this.length = 13;\n      this.keyFrame = true;\n      break;\n\n    case _FlvTag.METADATA_TAG:\n      this.length = 29;\n      this.keyFrame = true;\n      break;\n\n    default:\n      throw new Error('Unknown FLV tag type');\n  }\n\n  this.bytes = new Uint8Array(bufferStartSize);\n  this.view = new DataView(this.bytes.buffer);\n  this.bytes[0] = type;\n  this.position = this.length;\n  this.keyFrame = extraData; // Defaults to false\n  // presentation timestamp\n\n  this.pts = 0; // decoder timestamp\n\n  this.dts = 0; // ByteArray#writeBytes(bytes:ByteArray, offset:uint = 0, length:uint = 0)\n\n  this.writeBytes = function (bytes, offset, length) {\n    var start = offset || 0,\n        end;\n    length = length || bytes.byteLength;\n    end = start + length;\n    prepareWrite(this, length);\n    this.bytes.set(bytes.subarray(start, end), this.position);\n    this.position += length;\n    this.length = Math.max(this.length, this.position);\n  }; // ByteArray#writeByte(value:int):void\n\n\n  this.writeByte = function (byte) {\n    prepareWrite(this, 1);\n    this.bytes[this.position] = byte;\n    this.position++;\n    this.length = Math.max(this.length, this.position);\n  }; // ByteArray#writeShort(value:int):void\n\n\n  this.writeShort = function (short) {\n    prepareWrite(this, 2);\n    this.view.setUint16(this.position, short);\n    this.position += 2;\n    this.length = Math.max(this.length, this.position);\n  }; // Negative index into array\n  // (pos:uint):int\n\n\n  this.negIndex = function (pos) {\n    return this.bytes[this.length - pos];\n  }; // The functions below ONLY work when this[0] == VIDEO_TAG.\n  // We are not going to check for that because we dont want the overhead\n  // (nal:ByteArray = null):int\n\n\n  this.nalUnitSize = function () {\n    if (adHoc === 0) {\n      return 0;\n    }\n\n    return this.length - (adHoc + 4);\n  };\n\n  this.startNalUnit = function () {\n    // remember position and add 4 bytes\n    if (adHoc > 0) {\n      throw new Error('Attempted to create new NAL wihout closing the old one');\n    } // reserve 4 bytes for nal unit size\n\n\n    adHoc = this.length;\n    this.length += 4;\n    this.position = this.length;\n  }; // (nal:ByteArray = null):void\n\n\n  this.endNalUnit = function (nalContainer) {\n    var nalStart, // :uint\n    nalLength; // :uint\n    // Rewind to the marker and write the size\n\n    if (this.length === adHoc + 4) {\n      // we started a nal unit, but didnt write one, so roll back the 4 byte size value\n      this.length -= 4;\n    } else if (adHoc > 0) {\n      nalStart = adHoc + 4;\n      nalLength = this.length - nalStart;\n      this.position = adHoc;\n      this.view.setUint32(this.position, nalLength);\n      this.position = this.length;\n\n      if (nalContainer) {\n        // Add the tag to the NAL unit\n        nalContainer.push(this.bytes.subarray(nalStart, nalStart + nalLength));\n      }\n    }\n\n    adHoc = 0;\n  };\n  /**\n   * Write out a 64-bit floating point valued metadata property. This method is\n   * called frequently during a typical parse and needs to be fast.\n   */\n  // (key:String, val:Number):void\n\n\n  this.writeMetaDataDouble = function (key, val) {\n    var i;\n    prepareWrite(this, 2 + key.length + 9); // write size of property name\n\n    this.view.setUint16(this.position, key.length);\n    this.position += 2; // this next part looks terrible but it improves parser throughput by\n    // 10kB/s in my testing\n    // write property name\n\n    if (key === 'width') {\n      this.bytes.set(widthBytes, this.position);\n      this.position += 5;\n    } else if (key === 'height') {\n      this.bytes.set(heightBytes, this.position);\n      this.position += 6;\n    } else if (key === 'videocodecid') {\n      this.bytes.set(videocodecidBytes, this.position);\n      this.position += 12;\n    } else {\n      for (i = 0; i < key.length; i++) {\n        this.bytes[this.position] = key.charCodeAt(i);\n        this.position++;\n      }\n    } // skip null byte\n\n\n    this.position++; // write property value\n\n    this.view.setFloat64(this.position, val);\n    this.position += 8; // update flv tag length\n\n    this.length = Math.max(this.length, this.position);\n    ++adHoc;\n  }; // (key:String, val:Boolean):void\n\n\n  this.writeMetaDataBoolean = function (key, val) {\n    var i;\n    prepareWrite(this, 2);\n    this.view.setUint16(this.position, key.length);\n    this.position += 2;\n\n    for (i = 0; i < key.length; i++) {\n      // if key.charCodeAt(i) >= 255, handle error\n      prepareWrite(this, 1);\n      this.bytes[this.position] = key.charCodeAt(i);\n      this.position++;\n    }\n\n    prepareWrite(this, 2);\n    this.view.setUint8(this.position, 0x01);\n    this.position++;\n    this.view.setUint8(this.position, val ? 0x01 : 0x00);\n    this.position++;\n    this.length = Math.max(this.length, this.position);\n    ++adHoc;\n  }; // ():ByteArray\n\n\n  this.finalize = function () {\n    var dtsDelta, // :int\n    len; // :int\n\n    switch (this.bytes[0]) {\n      // Video Data\n      case _FlvTag.VIDEO_TAG:\n        // We only support AVC, 1 = key frame (for AVC, a seekable\n        // frame), 2 = inter frame (for AVC, a non-seekable frame)\n        this.bytes[11] = (this.keyFrame || extraData ? 0x10 : 0x20) | 0x07;\n        this.bytes[12] = extraData ? 0x00 : 0x01;\n        dtsDelta = this.pts - this.dts;\n        this.bytes[13] = (dtsDelta & 0x00FF0000) >>> 16;\n        this.bytes[14] = (dtsDelta & 0x0000FF00) >>> 8;\n        this.bytes[15] = (dtsDelta & 0x000000FF) >>> 0;\n        break;\n\n      case _FlvTag.AUDIO_TAG:\n        this.bytes[11] = 0xAF; // 44 kHz, 16-bit stereo\n\n        this.bytes[12] = extraData ? 0x00 : 0x01;\n        break;\n\n      case _FlvTag.METADATA_TAG:\n        this.position = 11;\n        this.view.setUint8(this.position, 0x02); // String type\n\n        this.position++;\n        this.view.setUint16(this.position, 0x0A); // 10 Bytes\n\n        this.position += 2; // set \"onMetaData\"\n\n        this.bytes.set([0x6f, 0x6e, 0x4d, 0x65, 0x74, 0x61, 0x44, 0x61, 0x74, 0x61], this.position);\n        this.position += 10;\n        this.bytes[this.position] = 0x08; // Array type\n\n        this.position++;\n        this.view.setUint32(this.position, adHoc);\n        this.position = this.length;\n        this.bytes.set([0, 0, 9], this.position);\n        this.position += 3; // End Data Tag\n\n        this.length = this.position;\n        break;\n    }\n\n    len = this.length - 11; // write the DataSize field\n\n    this.bytes[1] = (len & 0x00FF0000) >>> 16;\n    this.bytes[2] = (len & 0x0000FF00) >>> 8;\n    this.bytes[3] = (len & 0x000000FF) >>> 0; // write the Timestamp\n\n    this.bytes[4] = (this.dts & 0x00FF0000) >>> 16;\n    this.bytes[5] = (this.dts & 0x0000FF00) >>> 8;\n    this.bytes[6] = (this.dts & 0x000000FF) >>> 0;\n    this.bytes[7] = (this.dts & 0xFF000000) >>> 24; // write the StreamID\n\n    this.bytes[8] = 0;\n    this.bytes[9] = 0;\n    this.bytes[10] = 0; // Sometimes we're at the end of the view and have one slot to write a\n    // uint32, so, prepareWrite of count 4, since, view is uint8\n\n    prepareWrite(this, 4);\n    this.view.setUint32(this.length, this.length);\n    this.length += 4;\n    this.position += 4; // trim down the byte buffer to what is actually being used\n\n    this.bytes = this.bytes.subarray(0, this.length);\n    this.frameTime = _FlvTag.frameTime(this.bytes); // if bytes.bytelength isn't equal to this.length, handle error\n\n    return this;\n  };\n};\n\n_FlvTag.AUDIO_TAG = 0x08; // == 8, :uint\n\n_FlvTag.VIDEO_TAG = 0x09; // == 9, :uint\n\n_FlvTag.METADATA_TAG = 0x12; // == 18, :uint\n// (tag:ByteArray):Boolean {\n\n_FlvTag.isAudioFrame = function (tag) {\n  return _FlvTag.AUDIO_TAG === tag[0];\n}; // (tag:ByteArray):Boolean {\n\n\n_FlvTag.isVideoFrame = function (tag) {\n  return _FlvTag.VIDEO_TAG === tag[0];\n}; // (tag:ByteArray):Boolean {\n\n\n_FlvTag.isMetaData = function (tag) {\n  return _FlvTag.METADATA_TAG === tag[0];\n}; // (tag:ByteArray):Boolean {\n\n\n_FlvTag.isKeyFrame = function (tag) {\n  if (_FlvTag.isVideoFrame(tag)) {\n    return tag[11] === 0x17;\n  }\n\n  if (_FlvTag.isAudioFrame(tag)) {\n    return true;\n  }\n\n  if (_FlvTag.isMetaData(tag)) {\n    return true;\n  }\n\n  return false;\n}; // (tag:ByteArray):uint {\n\n\n_FlvTag.frameTime = function (tag) {\n  var pts = tag[4] << 16; // :uint\n\n  pts |= tag[5] << 8;\n  pts |= tag[6] << 0;\n  pts |= tag[7] << 24;\n  return pts;\n};\n\nmodule.exports = _FlvTag;", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js');\n/**\n * The final stage of the transmuxer that emits the flv tags\n * for audio, video, and metadata. Also tranlates in time and\n * outputs caption data and id3 cues.\n */\n\n\nvar CoalesceStream = function CoalesceStream(options) {\n  // Number of Tracks per output segment\n  // If greater than 1, we combine multiple\n  // tracks into a single segment\n  this.numberOfTracks = 0;\n  this.metadataStream = options.metadataStream;\n  this.videoTags = [];\n  this.audioTags = [];\n  this.videoTrack = null;\n  this.audioTrack = null;\n  this.pendingCaptions = [];\n  this.pendingMetadata = [];\n  this.pendingTracks = 0;\n  this.processedTracks = 0;\n  CoalesceStream.prototype.init.call(this); // Take output from multiple\n\n  this.push = function (output) {\n    // buffer incoming captions until the associated video segment\n    // finishes\n    if (output.text) {\n      return this.pendingCaptions.push(output);\n    } // buffer incoming id3 tags until the final flush\n\n\n    if (output.frames) {\n      return this.pendingMetadata.push(output);\n    }\n\n    if (output.track.type === 'video') {\n      this.videoTrack = output.track;\n      this.videoTags = output.tags;\n      this.pendingTracks++;\n    }\n\n    if (output.track.type === 'audio') {\n      this.audioTrack = output.track;\n      this.audioTags = output.tags;\n      this.pendingTracks++;\n    }\n  };\n};\n\nCoalesceStream.prototype = new Stream();\n\nCoalesceStream.prototype.flush = function (flushSource) {\n  var id3,\n      caption,\n      i,\n      timelineStartPts,\n      event = {\n    tags: {},\n    captions: [],\n    captionStreams: {},\n    metadata: []\n  };\n\n  if (this.pendingTracks < this.numberOfTracks) {\n    if (flushSource !== 'VideoSegmentStream' && flushSource !== 'AudioSegmentStream') {\n      // Return because we haven't received a flush from a data-generating\n      // portion of the segment (meaning that we have only recieved meta-data\n      // or captions.)\n      return;\n    } else if (this.pendingTracks === 0) {\n      // In the case where we receive a flush without any data having been\n      // received we consider it an emitted track for the purposes of coalescing\n      // `done` events.\n      // We do this for the case where there is an audio and video track in the\n      // segment but no audio data. (seen in several playlists with alternate\n      // audio tracks and no audio present in the main TS segments.)\n      this.processedTracks++;\n\n      if (this.processedTracks < this.numberOfTracks) {\n        return;\n      }\n    }\n  }\n\n  this.processedTracks += this.pendingTracks;\n  this.pendingTracks = 0;\n\n  if (this.processedTracks < this.numberOfTracks) {\n    return;\n  }\n\n  if (this.videoTrack) {\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n  } else if (this.audioTrack) {\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n  }\n\n  event.tags.videoTags = this.videoTags;\n  event.tags.audioTags = this.audioTags; // Translate caption PTS times into second offsets into the\n  // video timeline for the segment, and add track info\n\n  for (i = 0; i < this.pendingCaptions.length; i++) {\n    caption = this.pendingCaptions[i];\n    caption.startTime = caption.startPts - timelineStartPts;\n    caption.startTime /= 90e3;\n    caption.endTime = caption.endPts - timelineStartPts;\n    caption.endTime /= 90e3;\n    event.captionStreams[caption.stream] = true;\n    event.captions.push(caption);\n  } // Translate ID3 frame PTS times into second offsets into the\n  // video timeline for the segment\n\n\n  for (i = 0; i < this.pendingMetadata.length; i++) {\n    id3 = this.pendingMetadata[i];\n    id3.cueTime = id3.pts - timelineStartPts;\n    id3.cueTime /= 90e3;\n    event.metadata.push(id3);\n  } // We add this to every single emitted segment even though we only need\n  // it for the first\n\n\n  event.metadata.dispatchType = this.metadataStream.dispatchType; // Reset stream state\n\n  this.videoTrack = null;\n  this.audioTrack = null;\n  this.videoTags = [];\n  this.audioTags = [];\n  this.pendingCaptions.length = 0;\n  this.pendingMetadata.length = 0;\n  this.pendingTracks = 0;\n  this.processedTracks = 0; // Emit the final segment\n\n  this.trigger('data', event);\n  this.trigger('done');\n};\n\nmodule.exports = CoalesceStream;", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nvar TagList = function TagList() {\n  var self = this;\n  this.list = [];\n\n  this.push = function (tag) {\n    this.list.push({\n      bytes: tag.bytes,\n      dts: tag.dts,\n      pts: tag.pts,\n      keyFrame: tag.keyFrame,\n      metaDataTag: tag.metaDataTag\n    });\n  };\n\n  Object.defineProperty(this, 'length', {\n    get: function get() {\n      return self.list.length;\n    }\n  });\n};\n\nmodule.exports = TagList;", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js');\n\nvar FlvTag = require('./flv-tag.js');\n\nvar m2ts = require('../m2ts/m2ts.js');\n\nvar AdtsStream = require('../codecs/adts.js');\n\nvar H264Stream = require('../codecs/h264').H264Stream;\n\nvar CoalesceStream = require('./coalesce-stream.js');\n\nvar TagList = require('./tag-list.js');\n\nvar _Transmuxer, _VideoSegmentStream, _AudioSegmentStream, collectTimelineInfo, metaDataTag, extraDataTag;\n/**\n * Store information about the start and end of the tracka and the\n * duration for each frame/sample we process in order to calculate\n * the baseMediaDecodeTime\n */\n\n\ncollectTimelineInfo = function collectTimelineInfo(track, data) {\n  if (typeof data.pts === 'number') {\n    if (track.timelineStartInfo.pts === undefined) {\n      track.timelineStartInfo.pts = data.pts;\n    } else {\n      track.timelineStartInfo.pts = Math.min(track.timelineStartInfo.pts, data.pts);\n    }\n  }\n\n  if (typeof data.dts === 'number') {\n    if (track.timelineStartInfo.dts === undefined) {\n      track.timelineStartInfo.dts = data.dts;\n    } else {\n      track.timelineStartInfo.dts = Math.min(track.timelineStartInfo.dts, data.dts);\n    }\n  }\n};\n\nmetaDataTag = function metaDataTag(track, pts) {\n  var tag = new FlvTag(FlvTag.METADATA_TAG); // :FlvTag\n\n  tag.dts = pts;\n  tag.pts = pts;\n  tag.writeMetaDataDouble('videocodecid', 7);\n  tag.writeMetaDataDouble('width', track.width);\n  tag.writeMetaDataDouble('height', track.height);\n  return tag;\n};\n\nextraDataTag = function extraDataTag(track, pts) {\n  var i,\n      tag = new FlvTag(FlvTag.VIDEO_TAG, true);\n  tag.dts = pts;\n  tag.pts = pts;\n  tag.writeByte(0x01); // version\n\n  tag.writeByte(track.profileIdc); // profile\n\n  tag.writeByte(track.profileCompatibility); // compatibility\n\n  tag.writeByte(track.levelIdc); // level\n\n  tag.writeByte(0xFC | 0x03); // reserved (6 bits), NULA length size - 1 (2 bits)\n\n  tag.writeByte(0xE0 | 0x01); // reserved (3 bits), num of SPS (5 bits)\n\n  tag.writeShort(track.sps[0].length); // data of SPS\n\n  tag.writeBytes(track.sps[0]); // SPS\n\n  tag.writeByte(track.pps.length); // num of PPS (will there ever be more that 1 PPS?)\n\n  for (i = 0; i < track.pps.length; ++i) {\n    tag.writeShort(track.pps[i].length); // 2 bytes for length of PPS\n\n    tag.writeBytes(track.pps[i]); // data of PPS\n  }\n\n  return tag;\n};\n/**\n * Constructs a single-track, media segment from AAC data\n * events. The output of this stream can be fed to flash.\n */\n\n\n_AudioSegmentStream = function AudioSegmentStream(track) {\n  var adtsFrames = [],\n      videoKeyFrames = [],\n      oldExtraData;\n\n  _AudioSegmentStream.prototype.init.call(this);\n\n  this.push = function (data) {\n    collectTimelineInfo(track, data);\n\n    if (track) {\n      track.audioobjecttype = data.audioobjecttype;\n      track.channelcount = data.channelcount;\n      track.samplerate = data.samplerate;\n      track.samplingfrequencyindex = data.samplingfrequencyindex;\n      track.samplesize = data.samplesize;\n      track.extraData = track.audioobjecttype << 11 | track.samplingfrequencyindex << 7 | track.channelcount << 3;\n    }\n\n    data.pts = Math.round(data.pts / 90);\n    data.dts = Math.round(data.dts / 90); // buffer audio data until end() is called\n\n    adtsFrames.push(data);\n  };\n\n  this.flush = function () {\n    var currentFrame,\n        adtsFrame,\n        lastMetaPts,\n        tags = new TagList(); // return early if no audio data has been observed\n\n    if (adtsFrames.length === 0) {\n      this.trigger('done', 'AudioSegmentStream');\n      return;\n    }\n\n    lastMetaPts = -Infinity;\n\n    while (adtsFrames.length) {\n      currentFrame = adtsFrames.shift(); // write out a metadata frame at every video key frame\n\n      if (videoKeyFrames.length && currentFrame.pts >= videoKeyFrames[0]) {\n        lastMetaPts = videoKeyFrames.shift();\n        this.writeMetaDataTags(tags, lastMetaPts);\n      } // also write out metadata tags every 1 second so that the decoder\n      // is re-initialized quickly after seeking into a different\n      // audio configuration.\n\n\n      if (track.extraData !== oldExtraData || currentFrame.pts - lastMetaPts >= 1000) {\n        this.writeMetaDataTags(tags, currentFrame.pts);\n        oldExtraData = track.extraData;\n        lastMetaPts = currentFrame.pts;\n      }\n\n      adtsFrame = new FlvTag(FlvTag.AUDIO_TAG);\n      adtsFrame.pts = currentFrame.pts;\n      adtsFrame.dts = currentFrame.dts;\n      adtsFrame.writeBytes(currentFrame.data);\n      tags.push(adtsFrame.finalize());\n    }\n\n    videoKeyFrames.length = 0;\n    oldExtraData = null;\n    this.trigger('data', {\n      track: track,\n      tags: tags.list\n    });\n    this.trigger('done', 'AudioSegmentStream');\n  };\n\n  this.writeMetaDataTags = function (tags, pts) {\n    var adtsFrame;\n    adtsFrame = new FlvTag(FlvTag.METADATA_TAG); // For audio, DTS is always the same as PTS. We want to set the DTS\n    // however so we can compare with video DTS to determine approximate\n    // packet order\n\n    adtsFrame.pts = pts;\n    adtsFrame.dts = pts; // AAC is always 10\n\n    adtsFrame.writeMetaDataDouble('audiocodecid', 10);\n    adtsFrame.writeMetaDataBoolean('stereo', track.channelcount === 2);\n    adtsFrame.writeMetaDataDouble('audiosamplerate', track.samplerate); // Is AAC always 16 bit?\n\n    adtsFrame.writeMetaDataDouble('audiosamplesize', 16);\n    tags.push(adtsFrame.finalize());\n    adtsFrame = new FlvTag(FlvTag.AUDIO_TAG, true); // For audio, DTS is always the same as PTS. We want to set the DTS\n    // however so we can compare with video DTS to determine approximate\n    // packet order\n\n    adtsFrame.pts = pts;\n    adtsFrame.dts = pts;\n    adtsFrame.view.setUint16(adtsFrame.position, track.extraData);\n    adtsFrame.position += 2;\n    adtsFrame.length = Math.max(adtsFrame.length, adtsFrame.position);\n    tags.push(adtsFrame.finalize());\n  };\n\n  this.onVideoKeyFrame = function (pts) {\n    videoKeyFrames.push(pts);\n  };\n};\n\n_AudioSegmentStream.prototype = new Stream();\n/**\n * Store FlvTags for the h264 stream\n * @param track {object} track metadata configuration\n */\n\n_VideoSegmentStream = function VideoSegmentStream(track) {\n  var nalUnits = [],\n      config,\n      h264Frame;\n\n  _VideoSegmentStream.prototype.init.call(this);\n\n  this.finishFrame = function (tags, frame) {\n    if (!frame) {\n      return;\n    } // Check if keyframe and the length of tags.\n    // This makes sure we write metadata on the first frame of a segment.\n\n\n    if (config && track && track.newMetadata && (frame.keyFrame || tags.length === 0)) {\n      // Push extra data on every IDR frame in case we did a stream change + seek\n      var metaTag = metaDataTag(config, frame.dts).finalize();\n      var extraTag = extraDataTag(track, frame.dts).finalize();\n      metaTag.metaDataTag = extraTag.metaDataTag = true;\n      tags.push(metaTag);\n      tags.push(extraTag);\n      track.newMetadata = false;\n      this.trigger('keyframe', frame.dts);\n    }\n\n    frame.endNalUnit();\n    tags.push(frame.finalize());\n    h264Frame = null;\n  };\n\n  this.push = function (data) {\n    collectTimelineInfo(track, data);\n    data.pts = Math.round(data.pts / 90);\n    data.dts = Math.round(data.dts / 90); // buffer video until flush() is called\n\n    nalUnits.push(data);\n  };\n\n  this.flush = function () {\n    var currentNal,\n        tags = new TagList(); // Throw away nalUnits at the start of the byte stream until we find\n    // the first AUD\n\n    while (nalUnits.length) {\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n        break;\n      }\n\n      nalUnits.shift();\n    } // return early if no video data has been observed\n\n\n    if (nalUnits.length === 0) {\n      this.trigger('done', 'VideoSegmentStream');\n      return;\n    }\n\n    while (nalUnits.length) {\n      currentNal = nalUnits.shift(); // record the track config\n\n      if (currentNal.nalUnitType === 'seq_parameter_set_rbsp') {\n        track.newMetadata = true;\n        config = currentNal.config;\n        track.width = config.width;\n        track.height = config.height;\n        track.sps = [currentNal.data];\n        track.profileIdc = config.profileIdc;\n        track.levelIdc = config.levelIdc;\n        track.profileCompatibility = config.profileCompatibility;\n        h264Frame.endNalUnit();\n      } else if (currentNal.nalUnitType === 'pic_parameter_set_rbsp') {\n        track.newMetadata = true;\n        track.pps = [currentNal.data];\n        h264Frame.endNalUnit();\n      } else if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n        if (h264Frame) {\n          this.finishFrame(tags, h264Frame);\n        }\n\n        h264Frame = new FlvTag(FlvTag.VIDEO_TAG);\n        h264Frame.pts = currentNal.pts;\n        h264Frame.dts = currentNal.dts;\n      } else {\n        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n          // the current sample is a key frame\n          h264Frame.keyFrame = true;\n        }\n\n        h264Frame.endNalUnit();\n      }\n\n      h264Frame.startNalUnit();\n      h264Frame.writeBytes(currentNal.data);\n    }\n\n    if (h264Frame) {\n      this.finishFrame(tags, h264Frame);\n    }\n\n    this.trigger('data', {\n      track: track,\n      tags: tags.list\n    }); // Continue with the flush process now\n\n    this.trigger('done', 'VideoSegmentStream');\n  };\n};\n\n_VideoSegmentStream.prototype = new Stream();\n/**\n * An object that incrementally transmuxes MPEG2 Trasport Stream\n * chunks into an FLV.\n */\n\n_Transmuxer = function Transmuxer(options) {\n  var self = this,\n      packetStream,\n      parseStream,\n      elementaryStream,\n      videoTimestampRolloverStream,\n      audioTimestampRolloverStream,\n      timedMetadataTimestampRolloverStream,\n      adtsStream,\n      h264Stream,\n      videoSegmentStream,\n      audioSegmentStream,\n      captionStream,\n      coalesceStream;\n\n  _Transmuxer.prototype.init.call(this);\n\n  options = options || {}; // expose the metadata stream\n\n  this.metadataStream = new m2ts.MetadataStream();\n  options.metadataStream = this.metadataStream; // set up the parsing pipeline\n\n  packetStream = new m2ts.TransportPacketStream();\n  parseStream = new m2ts.TransportParseStream();\n  elementaryStream = new m2ts.ElementaryStream();\n  videoTimestampRolloverStream = new m2ts.TimestampRolloverStream('video');\n  audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n  timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n  adtsStream = new AdtsStream();\n  h264Stream = new H264Stream();\n  coalesceStream = new CoalesceStream(options); // disassemble MPEG2-TS packets into elementary streams\n\n  packetStream.pipe(parseStream).pipe(elementaryStream); // !!THIS ORDER IS IMPORTANT!!\n  // demux the streams\n\n  elementaryStream.pipe(videoTimestampRolloverStream).pipe(h264Stream);\n  elementaryStream.pipe(audioTimestampRolloverStream).pipe(adtsStream);\n  elementaryStream.pipe(timedMetadataTimestampRolloverStream).pipe(this.metadataStream).pipe(coalesceStream); // if CEA-708 parsing is available, hook up a caption stream\n\n  captionStream = new m2ts.CaptionStream(options);\n  h264Stream.pipe(captionStream).pipe(coalesceStream); // hook up the segment streams once track metadata is delivered\n\n  elementaryStream.on('data', function (data) {\n    var i, videoTrack, audioTrack;\n\n    if (data.type === 'metadata') {\n      i = data.tracks.length; // scan the tracks listed in the metadata\n\n      while (i--) {\n        if (data.tracks[i].type === 'video') {\n          videoTrack = data.tracks[i];\n        } else if (data.tracks[i].type === 'audio') {\n          audioTrack = data.tracks[i];\n        }\n      } // hook up the video segment stream to the first track with h264 data\n\n\n      if (videoTrack && !videoSegmentStream) {\n        coalesceStream.numberOfTracks++;\n        videoSegmentStream = new _VideoSegmentStream(videoTrack); // Set up the final part of the video pipeline\n\n        h264Stream.pipe(videoSegmentStream).pipe(coalesceStream);\n      }\n\n      if (audioTrack && !audioSegmentStream) {\n        // hook up the audio segment stream to the first track with aac data\n        coalesceStream.numberOfTracks++;\n        audioSegmentStream = new _AudioSegmentStream(audioTrack); // Set up the final part of the audio pipeline\n\n        adtsStream.pipe(audioSegmentStream).pipe(coalesceStream);\n\n        if (videoSegmentStream) {\n          videoSegmentStream.on('keyframe', audioSegmentStream.onVideoKeyFrame);\n        }\n      }\n    }\n  }); // feed incoming data to the front of the parsing pipeline\n\n  this.push = function (data) {\n    packetStream.push(data);\n  }; // flush any buffered data\n\n\n  this.flush = function () {\n    // Start at the top of the pipeline and flush all pending work\n    packetStream.flush();\n  }; // Caption data has to be reset when seeking outside buffered range\n\n\n  this.resetCaptions = function () {\n    captionStream.reset();\n  }; // Re-emit any data coming from the coalesce stream to the outside world\n\n\n  coalesceStream.on('data', function (event) {\n    self.trigger('data', event);\n  }); // Let the consumer know we have finished flushing the entire pipeline\n\n  coalesceStream.on('done', function () {\n    self.trigger('done');\n  });\n};\n\n_Transmuxer.prototype = new Stream(); // forward compatibility\n\nmodule.exports = _Transmuxer;", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nvar FlvTag = require('./flv-tag.js'); // For information on the FLV format, see\n// http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf.\n// Technically, this function returns the header and a metadata FLV tag\n// if duration is greater than zero\n// duration in seconds\n// @return {object} the bytes of the FLV header as a Uint8Array\n\n\nvar getFlvHeader = function getFlvHeader(duration, audio, video) {\n  // :ByteArray {\n  var headBytes = new Uint8Array(3 + 1 + 1 + 4),\n      head = new DataView(headBytes.buffer),\n      metadata,\n      result,\n      metadataLength; // default arguments\n\n  duration = duration || 0;\n  audio = audio === undefined ? true : audio;\n  video = video === undefined ? true : video; // signature\n\n  head.setUint8(0, 0x46); // 'F'\n\n  head.setUint8(1, 0x4c); // 'L'\n\n  head.setUint8(2, 0x56); // 'V'\n  // version\n\n  head.setUint8(3, 0x01); // flags\n\n  head.setUint8(4, (audio ? 0x04 : 0x00) | (video ? 0x01 : 0x00)); // data offset, should be 9 for FLV v1\n\n  head.setUint32(5, headBytes.byteLength); // init the first FLV tag\n\n  if (duration <= 0) {\n    // no duration available so just write the first field of the first\n    // FLV tag\n    result = new Uint8Array(headBytes.byteLength + 4);\n    result.set(headBytes);\n    result.set([0, 0, 0, 0], headBytes.byteLength);\n    return result;\n  } // write out the duration metadata tag\n\n\n  metadata = new FlvTag(FlvTag.METADATA_TAG);\n  metadata.pts = metadata.dts = 0;\n  metadata.writeMetaDataDouble('duration', duration);\n  metadataLength = metadata.finalize().length;\n  result = new Uint8Array(headBytes.byteLength + metadataLength);\n  result.set(headBytes);\n  result.set(head.byteLength, metadataLength);\n  return result;\n};\n\nmodule.exports = getFlvHeader;", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\nmodule.exports = {\n  tag: require('./flv-tag'),\n  Transmuxer: require('./transmuxer'),\n  getFlvHeader: require('./flv-header')\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\nmodule.exports = require('./m2ts');", "'use strict';\n\nvar Stream = require('../utils/stream.js');\n\nvar mp4 = require('../mp4/mp4-generator.js');\n\nvar audioFrameUtils = require('../mp4/audio-frame-utils');\n\nvar trackInfo = require('../mp4/track-decode-info.js');\n\nvar ONE_SECOND_IN_TS = require('../utils/clock').ONE_SECOND_IN_TS;\n\nvar AUDIO_PROPERTIES = require('../constants/audio-properties.js');\n/**\n * Constructs a single-track, ISO BMFF media segment from AAC data\n * events. The output of this stream can be fed to a SourceBuffer\n * configured with a suitable initialization segment.\n */\n\n\nvar AudioSegmentStream = function AudioSegmentStream(track, options) {\n  var adtsFrames = [],\n      sequenceNumber = 0,\n      earliestAllowedDts = 0,\n      audioAppendStartTs = 0,\n      videoBaseMediaDecodeTime = Infinity,\n      segmentStartPts = null,\n      segmentEndPts = null;\n  options = options || {};\n  AudioSegmentStream.prototype.init.call(this);\n\n  this.push = function (data) {\n    trackInfo.collectDtsInfo(track, data);\n\n    if (track) {\n      AUDIO_PROPERTIES.forEach(function (prop) {\n        track[prop] = data[prop];\n      });\n    } // buffer audio data until end() is called\n\n\n    adtsFrames.push(data);\n  };\n\n  this.setEarliestDts = function (earliestDts) {\n    earliestAllowedDts = earliestDts;\n  };\n\n  this.setVideoBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n    videoBaseMediaDecodeTime = baseMediaDecodeTime;\n  };\n\n  this.setAudioAppendStart = function (timestamp) {\n    audioAppendStartTs = timestamp;\n  };\n\n  this.processFrames_ = function () {\n    var frames, moof, mdat, boxes, timingInfo; // return early if no audio data has been observed\n\n    if (adtsFrames.length === 0) {\n      return;\n    }\n\n    frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);\n\n    if (frames.length === 0) {\n      // return early if the frames are all after the earliest allowed DTS\n      // TODO should we clear the adtsFrames?\n      return;\n    }\n\n    track.baseMediaDecodeTime = trackInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n    audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime); // we have to build the index from byte locations to\n    // samples (that is, adts frames) in the audio data\n\n    track.samples = audioFrameUtils.generateSampleTable(frames); // concatenate the audio data to constuct the mdat\n\n    mdat = mp4.mdat(audioFrameUtils.concatenateFrameData(frames));\n    adtsFrames = [];\n    moof = mp4.moof(sequenceNumber, [track]); // bump the sequence number for next time\n\n    sequenceNumber++;\n    track.initSegment = mp4.initSegment([track]); // it would be great to allocate this array up front instead of\n    // throwing away hundreds of media segment fragments\n\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n    boxes.set(moof);\n    boxes.set(mdat, moof.byteLength);\n    trackInfo.clearDtsInfo(track);\n\n    if (segmentStartPts === null) {\n      segmentEndPts = segmentStartPts = frames[0].pts;\n    }\n\n    segmentEndPts += frames.length * (ONE_SECOND_IN_TS * 1024 / track.samplerate);\n    timingInfo = {\n      start: segmentStartPts\n    };\n    this.trigger('timingInfo', timingInfo);\n    this.trigger('data', {\n      track: track,\n      boxes: boxes\n    });\n  };\n\n  this.flush = function () {\n    this.processFrames_(); // trigger final timing info\n\n    this.trigger('timingInfo', {\n      start: segmentStartPts,\n      end: segmentEndPts\n    });\n    this.resetTiming_();\n    this.trigger('done', 'AudioSegmentStream');\n  };\n\n  this.partialFlush = function () {\n    this.processFrames_();\n    this.trigger('partialdone', 'AudioSegmentStream');\n  };\n\n  this.endTimeline = function () {\n    this.flush();\n    this.trigger('endedtimeline', 'AudioSegmentStream');\n  };\n\n  this.resetTiming_ = function () {\n    trackInfo.clearDtsInfo(track);\n    segmentStartPts = null;\n    segmentEndPts = null;\n  };\n\n  this.reset = function () {\n    this.resetTiming_();\n    adtsFrames = [];\n    this.trigger('reset');\n  };\n};\n\nAudioSegmentStream.prototype = new Stream();\nmodule.exports = AudioSegmentStream;", "/**\n * Constructs a single-track, ISO BMFF media segment from H264 data\n * events. The output of this stream can be fed to a SourceBuffer\n * configured with a suitable initialization segment.\n * @param track {object} track metadata configuration\n * @param options {object} transmuxer options object\n * @param options.alignGopsAtEnd {boolean} If true, start from the end of the\n *        gopsToAlignWith list when attempting to align gop pts\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js');\n\nvar mp4 = require('../mp4/mp4-generator.js');\n\nvar trackInfo = require('../mp4/track-decode-info.js');\n\nvar frameUtils = require('../mp4/frame-utils');\n\nvar VIDEO_PROPERTIES = require('../constants/video-properties.js');\n\nvar VideoSegmentStream = function VideoSegmentStream(track, options) {\n  var sequenceNumber = 0,\n      nalUnits = [],\n      frameCache = [],\n      // gopsToAlignWith = [],\n  config,\n      pps,\n      segmentStartPts = null,\n      segmentEndPts = null,\n      gops,\n      ensureNextFrameIsKeyFrame = true;\n  options = options || {};\n  VideoSegmentStream.prototype.init.call(this);\n\n  this.push = function (nalUnit) {\n    trackInfo.collectDtsInfo(track, nalUnit);\n\n    if (typeof track.timelineStartInfo.dts === 'undefined') {\n      track.timelineStartInfo.dts = nalUnit.dts;\n    } // record the track config\n\n\n    if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n      config = nalUnit.config;\n      track.sps = [nalUnit.data];\n      VIDEO_PROPERTIES.forEach(function (prop) {\n        track[prop] = config[prop];\n      }, this);\n    }\n\n    if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' && !pps) {\n      pps = nalUnit.data;\n      track.pps = [nalUnit.data];\n    } // buffer video until flush() is called\n\n\n    nalUnits.push(nalUnit);\n  };\n\n  this.processNals_ = function (cacheLastFrame) {\n    var i;\n    nalUnits = frameCache.concat(nalUnits); // Throw away nalUnits at the start of the byte stream until\n    // we find the first AUD\n\n    while (nalUnits.length) {\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n        break;\n      }\n\n      nalUnits.shift();\n    } // Return early if no video data has been observed\n\n\n    if (nalUnits.length === 0) {\n      return;\n    }\n\n    var frames = frameUtils.groupNalsIntoFrames(nalUnits);\n\n    if (!frames.length) {\n      return;\n    } // note that the frame cache may also protect us from cases where we haven't\n    // pushed data for the entire first or last frame yet\n\n\n    frameCache = frames[frames.length - 1];\n\n    if (cacheLastFrame) {\n      frames.pop();\n      frames.duration -= frameCache.duration;\n      frames.nalCount -= frameCache.length;\n      frames.byteLength -= frameCache.byteLength;\n    }\n\n    if (!frames.length) {\n      nalUnits = [];\n      return;\n    }\n\n    this.trigger('timelineStartInfo', track.timelineStartInfo);\n\n    if (ensureNextFrameIsKeyFrame) {\n      gops = frameUtils.groupFramesIntoGops(frames);\n\n      if (!gops[0][0].keyFrame) {\n        gops = frameUtils.extendFirstKeyFrame(gops);\n\n        if (!gops[0][0].keyFrame) {\n          // we haven't yet gotten a key frame, so reset nal units to wait for more nal\n          // units\n          nalUnits = [].concat.apply([], frames).concat(frameCache);\n          frameCache = [];\n          return;\n        }\n\n        frames = [].concat.apply([], gops);\n        frames.duration = gops.duration;\n      }\n\n      ensureNextFrameIsKeyFrame = false;\n    }\n\n    if (segmentStartPts === null) {\n      segmentStartPts = frames[0].pts;\n      segmentEndPts = segmentStartPts;\n    }\n\n    segmentEndPts += frames.duration;\n    this.trigger('timingInfo', {\n      start: segmentStartPts,\n      end: segmentEndPts\n    });\n\n    for (i = 0; i < frames.length; i++) {\n      var frame = frames[i];\n      track.samples = frameUtils.generateSampleTableForFrame(frame);\n      var mdat = mp4.mdat(frameUtils.concatenateNalDataForFrame(frame));\n      trackInfo.clearDtsInfo(track);\n      trackInfo.collectDtsInfo(track, frame);\n      track.baseMediaDecodeTime = trackInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n      var moof = mp4.moof(sequenceNumber, [track]);\n      sequenceNumber++;\n      track.initSegment = mp4.initSegment([track]);\n      var boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n      boxes.set(moof);\n      boxes.set(mdat, moof.byteLength);\n      this.trigger('data', {\n        track: track,\n        boxes: boxes,\n        sequence: sequenceNumber,\n        videoFrameDts: frame.dts,\n        videoFramePts: frame.pts\n      });\n    }\n\n    nalUnits = [];\n  };\n\n  this.resetTimingAndConfig_ = function () {\n    config = undefined;\n    pps = undefined;\n    segmentStartPts = null;\n    segmentEndPts = null;\n  };\n\n  this.partialFlush = function () {\n    this.processNals_(true);\n    this.trigger('partialdone', 'VideoSegmentStream');\n  };\n\n  this.flush = function () {\n    this.processNals_(false); // reset config and pps because they may differ across segments\n    // for instance, when we are rendition switching\n\n    this.resetTimingAndConfig_();\n    this.trigger('done', 'VideoSegmentStream');\n  };\n\n  this.endTimeline = function () {\n    this.flush();\n    this.trigger('endedtimeline', 'VideoSegmentStream');\n  };\n\n  this.reset = function () {\n    this.resetTimingAndConfig_();\n    frameCache = [];\n    nalUnits = [];\n    ensureNextFrameIsKeyFrame = true;\n    this.trigger('reset');\n  };\n};\n\nVideoSegmentStream.prototype = new Stream();\nmodule.exports = VideoSegmentStream;", "var Stream = require('../utils/stream.js');\n\nvar m2ts = require('../m2ts/m2ts.js');\n\nvar codecs = require('../codecs/index.js');\n\nvar AudioSegmentStream = require('./audio-segment-stream.js');\n\nvar VideoSegmentStream = require('./video-segment-stream.js');\n\nvar trackInfo = require('../mp4/track-decode-info.js');\n\nvar isLikelyAacData = require('../aac/utils').isLikelyAacData;\n\nvar AdtsStream = require('../codecs/adts');\n\nvar AacStream = require('../aac/index');\n\nvar clock = require('../utils/clock');\n\nvar createPipeline = function createPipeline(object) {\n  object.prototype = new Stream();\n  object.prototype.init.call(object);\n  return object;\n};\n\nvar tsPipeline = function tsPipeline(options) {\n  var pipeline = {\n    type: 'ts',\n    tracks: {\n      audio: null,\n      video: null\n    },\n    packet: new m2ts.TransportPacketStream(),\n    parse: new m2ts.TransportParseStream(),\n    elementary: new m2ts.ElementaryStream(),\n    timestampRollover: new m2ts.TimestampRolloverStream(),\n    adts: new codecs.Adts(),\n    h264: new codecs.h264.H264Stream(),\n    captionStream: new m2ts.CaptionStream(options),\n    metadataStream: new m2ts.MetadataStream()\n  };\n  pipeline.headOfPipeline = pipeline.packet; // Transport Stream\n\n  pipeline.packet.pipe(pipeline.parse).pipe(pipeline.elementary).pipe(pipeline.timestampRollover); // H264\n\n  pipeline.timestampRollover.pipe(pipeline.h264); // Hook up CEA-608/708 caption stream\n\n  pipeline.h264.pipe(pipeline.captionStream);\n  pipeline.timestampRollover.pipe(pipeline.metadataStream); // ADTS\n\n  pipeline.timestampRollover.pipe(pipeline.adts);\n  pipeline.elementary.on('data', function (data) {\n    if (data.type !== 'metadata') {\n      return;\n    }\n\n    for (var i = 0; i < data.tracks.length; i++) {\n      if (!pipeline.tracks[data.tracks[i].type]) {\n        pipeline.tracks[data.tracks[i].type] = data.tracks[i];\n        pipeline.tracks[data.tracks[i].type].timelineStartInfo.baseMediaDecodeTime = options.baseMediaDecodeTime;\n      }\n    }\n\n    if (pipeline.tracks.video && !pipeline.videoSegmentStream) {\n      pipeline.videoSegmentStream = new VideoSegmentStream(pipeline.tracks.video, options);\n      pipeline.videoSegmentStream.on('timelineStartInfo', function (timelineStartInfo) {\n        if (pipeline.tracks.audio && !options.keepOriginalTimestamps) {\n          pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - options.baseMediaDecodeTime);\n        }\n      });\n      pipeline.videoSegmentStream.on('timingInfo', pipeline.trigger.bind(pipeline, 'videoTimingInfo'));\n      pipeline.videoSegmentStream.on('data', function (data) {\n        pipeline.trigger('data', {\n          type: 'video',\n          data: data\n        });\n      });\n      pipeline.videoSegmentStream.on('done', pipeline.trigger.bind(pipeline, 'done'));\n      pipeline.videoSegmentStream.on('partialdone', pipeline.trigger.bind(pipeline, 'partialdone'));\n      pipeline.videoSegmentStream.on('endedtimeline', pipeline.trigger.bind(pipeline, 'endedtimeline'));\n      pipeline.h264.pipe(pipeline.videoSegmentStream);\n    }\n\n    if (pipeline.tracks.audio && !pipeline.audioSegmentStream) {\n      pipeline.audioSegmentStream = new AudioSegmentStream(pipeline.tracks.audio, options);\n      pipeline.audioSegmentStream.on('data', function (data) {\n        pipeline.trigger('data', {\n          type: 'audio',\n          data: data\n        });\n      });\n      pipeline.audioSegmentStream.on('done', pipeline.trigger.bind(pipeline, 'done'));\n      pipeline.audioSegmentStream.on('partialdone', pipeline.trigger.bind(pipeline, 'partialdone'));\n      pipeline.audioSegmentStream.on('endedtimeline', pipeline.trigger.bind(pipeline, 'endedtimeline'));\n      pipeline.audioSegmentStream.on('timingInfo', pipeline.trigger.bind(pipeline, 'audioTimingInfo'));\n      pipeline.adts.pipe(pipeline.audioSegmentStream);\n    } // emit pmt info\n\n\n    pipeline.trigger('trackinfo', {\n      hasAudio: !!pipeline.tracks.audio,\n      hasVideo: !!pipeline.tracks.video\n    });\n  });\n  pipeline.captionStream.on('data', function (caption) {\n    var timelineStartPts;\n\n    if (pipeline.tracks.video) {\n      timelineStartPts = pipeline.tracks.video.timelineStartInfo.pts || 0;\n    } else {\n      // This will only happen if we encounter caption packets before\n      // video data in a segment. This is an unusual/unlikely scenario,\n      // so we assume the timeline starts at zero for now.\n      timelineStartPts = 0;\n    } // Translate caption PTS times into second offsets into the\n    // video timeline for the segment\n\n\n    caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, options.keepOriginalTimestamps);\n    caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, options.keepOriginalTimestamps);\n    pipeline.trigger('caption', caption);\n  });\n  pipeline = createPipeline(pipeline);\n  pipeline.metadataStream.on('data', pipeline.trigger.bind(pipeline, 'id3Frame'));\n  return pipeline;\n};\n\nvar aacPipeline = function aacPipeline(options) {\n  var pipeline = {\n    type: 'aac',\n    tracks: {\n      audio: null\n    },\n    metadataStream: new m2ts.MetadataStream(),\n    aacStream: new AacStream(),\n    audioRollover: new m2ts.TimestampRolloverStream('audio'),\n    timedMetadataRollover: new m2ts.TimestampRolloverStream('timed-metadata'),\n    adtsStream: new AdtsStream(true)\n  }; // set up the parsing pipeline\n\n  pipeline.headOfPipeline = pipeline.aacStream;\n  pipeline.aacStream.pipe(pipeline.audioRollover).pipe(pipeline.adtsStream);\n  pipeline.aacStream.pipe(pipeline.timedMetadataRollover).pipe(pipeline.metadataStream);\n  pipeline.metadataStream.on('timestamp', function (frame) {\n    pipeline.aacStream.setTimestamp(frame.timeStamp);\n  });\n  pipeline.aacStream.on('data', function (data) {\n    if (data.type !== 'timed-metadata' && data.type !== 'audio' || pipeline.audioSegmentStream) {\n      return;\n    }\n\n    pipeline.tracks.audio = pipeline.tracks.audio || {\n      timelineStartInfo: {\n        baseMediaDecodeTime: options.baseMediaDecodeTime\n      },\n      codec: 'adts',\n      type: 'audio'\n    }; // hook up the audio segment stream to the first track with aac data\n\n    pipeline.audioSegmentStream = new AudioSegmentStream(pipeline.tracks.audio, options);\n    pipeline.audioSegmentStream.on('data', function (data) {\n      pipeline.trigger('data', {\n        type: 'audio',\n        data: data\n      });\n    });\n    pipeline.audioSegmentStream.on('partialdone', pipeline.trigger.bind(pipeline, 'partialdone'));\n    pipeline.audioSegmentStream.on('done', pipeline.trigger.bind(pipeline, 'done'));\n    pipeline.audioSegmentStream.on('endedtimeline', pipeline.trigger.bind(pipeline, 'endedtimeline'));\n    pipeline.audioSegmentStream.on('timingInfo', pipeline.trigger.bind(pipeline, 'audioTimingInfo')); // Set up the final part of the audio pipeline\n\n    pipeline.adtsStream.pipe(pipeline.audioSegmentStream);\n    pipeline.trigger('trackinfo', {\n      hasAudio: !!pipeline.tracks.audio,\n      hasVideo: !!pipeline.tracks.video\n    });\n  }); // set the pipeline up as a stream before binding to get access to the trigger function\n\n  pipeline = createPipeline(pipeline);\n  pipeline.metadataStream.on('data', pipeline.trigger.bind(pipeline, 'id3Frame'));\n  return pipeline;\n};\n\nvar setupPipelineListeners = function setupPipelineListeners(pipeline, transmuxer) {\n  pipeline.on('data', transmuxer.trigger.bind(transmuxer, 'data'));\n  pipeline.on('done', transmuxer.trigger.bind(transmuxer, 'done'));\n  pipeline.on('partialdone', transmuxer.trigger.bind(transmuxer, 'partialdone'));\n  pipeline.on('endedtimeline', transmuxer.trigger.bind(transmuxer, 'endedtimeline'));\n  pipeline.on('audioTimingInfo', transmuxer.trigger.bind(transmuxer, 'audioTimingInfo'));\n  pipeline.on('videoTimingInfo', transmuxer.trigger.bind(transmuxer, 'videoTimingInfo'));\n  pipeline.on('trackinfo', transmuxer.trigger.bind(transmuxer, 'trackinfo'));\n  pipeline.on('id3Frame', function (event) {\n    // add this to every single emitted segment even though it's only needed for the first\n    event.dispatchType = pipeline.metadataStream.dispatchType; // keep original time, can be adjusted if needed at a higher level\n\n    event.cueTime = clock.videoTsToSeconds(event.pts);\n    transmuxer.trigger('id3Frame', event);\n  });\n  pipeline.on('caption', function (event) {\n    transmuxer.trigger('caption', event);\n  });\n};\n\nvar Transmuxer = function Transmuxer(options) {\n  var pipeline = null,\n      hasFlushed = true;\n  options = options || {};\n  Transmuxer.prototype.init.call(this);\n  options.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n\n  this.push = function (bytes) {\n    if (hasFlushed) {\n      var isAac = isLikelyAacData(bytes);\n\n      if (isAac && (!pipeline || pipeline.type !== 'aac')) {\n        pipeline = aacPipeline(options);\n        setupPipelineListeners(pipeline, this);\n      } else if (!isAac && (!pipeline || pipeline.type !== 'ts')) {\n        pipeline = tsPipeline(options);\n        setupPipelineListeners(pipeline, this);\n      }\n\n      hasFlushed = false;\n    }\n\n    pipeline.headOfPipeline.push(bytes);\n  };\n\n  this.flush = function () {\n    if (!pipeline) {\n      return;\n    }\n\n    hasFlushed = true;\n    pipeline.headOfPipeline.flush();\n  };\n\n  this.partialFlush = function () {\n    if (!pipeline) {\n      return;\n    }\n\n    pipeline.headOfPipeline.partialFlush();\n  };\n\n  this.endTimeline = function () {\n    if (!pipeline) {\n      return;\n    }\n\n    pipeline.headOfPipeline.endTimeline();\n  };\n\n  this.reset = function () {\n    if (!pipeline) {\n      return;\n    }\n\n    pipeline.headOfPipeline.reset();\n  };\n\n  this.setBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n    if (!options.keepOriginalTimestamps) {\n      options.baseMediaDecodeTime = baseMediaDecodeTime;\n    }\n\n    if (!pipeline) {\n      return;\n    }\n\n    if (pipeline.tracks.audio) {\n      pipeline.tracks.audio.timelineStartInfo.dts = undefined;\n      pipeline.tracks.audio.timelineStartInfo.pts = undefined;\n      trackInfo.clearDtsInfo(pipeline.tracks.audio);\n\n      if (pipeline.audioRollover) {\n        pipeline.audioRollover.discontinuity();\n      }\n    }\n\n    if (pipeline.tracks.video) {\n      if (pipeline.videoSegmentStream) {\n        pipeline.videoSegmentStream.gopCache_ = [];\n      }\n\n      pipeline.tracks.video.timelineStartInfo.dts = undefined;\n      pipeline.tracks.video.timelineStartInfo.pts = undefined;\n      trackInfo.clearDtsInfo(pipeline.tracks.video); // pipeline.captionStream.reset();\n    }\n\n    if (pipeline.timestampRollover) {\n      pipeline.timestampRollover.discontinuity();\n    }\n  };\n\n  this.setRemux = function (val) {\n    options.remux = val;\n\n    if (pipeline && pipeline.coalesceStream) {\n      pipeline.coalesceStream.setRemux(val);\n    }\n  };\n\n  this.setAudioAppendStart = function (audioAppendStart) {\n    if (!pipeline || !pipeline.tracks.audio || !pipeline.audioSegmentStream) {\n      return;\n    }\n\n    pipeline.audioSegmentStream.setAudioAppendStart(audioAppendStart);\n  }; // TODO GOP alignment support\n  // Support may be a bit trickier than with full segment appends, as GOPs may be split\n  // and processed in a more granular fashion\n\n\n  this.alignGopsWith = function (gopsToAlignWith) {\n    return;\n  };\n};\n\nTransmuxer.prototype = new Stream();\nmodule.exports = Transmuxer;", "module.exports = {\n  Transmuxer: require('./transmuxer')\n};", "var MAX_UINT32 = Math.pow(2, 32);\n\nvar parseSidx = function parseSidx(data) {\n  var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n      result = {\n    version: data[0],\n    flags: new Uint8Array(data.subarray(1, 4)),\n    references: [],\n    referenceId: view.getUint32(4),\n    timescale: view.getUint32(8)\n  },\n      i = 12;\n\n  if (result.version === 0) {\n    result.earliestPresentationTime = view.getUint32(i);\n    result.firstOffset = view.getUint32(i + 4);\n    i += 8;\n  } else {\n    // read 64 bits\n    result.earliestPresentationTime = view.getUint32(i) * MAX_UINT32 + view.getUint32(i + 4);\n    result.firstOffset = view.getUint32(i + 8) * MAX_UINT32 + view.getUint32(i + 12);\n    i += 16;\n  }\n\n  i += 2; // reserved\n\n  var referenceCount = view.getUint16(i);\n  i += 2; // start of references\n\n  for (; referenceCount > 0; i += 12, referenceCount--) {\n    result.references.push({\n      referenceType: (data[i] & 0x80) >>> 7,\n      referencedSize: view.getUint32(i) & 0x7FFFFFFF,\n      subsegmentDuration: view.getUint32(i + 4),\n      startsWithSap: !!(data[i + 8] & 0x80),\n      sapType: (data[i + 8] & 0x70) >>> 4,\n      sapDeltaTime: view.getUint32(i + 8) & 0x0FFFFFFF\n    });\n  }\n\n  return result;\n};\n\nmodule.exports = parseSidx;", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Parse the internal MP4 structure into an equivalent javascript\n * object.\n */\n'use strict';\n\nvar MAX_UINT32 = Math.pow(2, 32);\n\nvar inspectMp4,\n    _textifyMp,\n    parseMp4Date = function parseMp4Date(seconds) {\n  return new Date(seconds * 1000 - 2082844800000);\n},\n    parseType = require('../mp4/parse-type'),\n    findBox = require('../mp4/find-box'),\n    nalParse = function nalParse(avcStream) {\n  var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n      result = [],\n      i,\n      length;\n\n  for (i = 0; i + 4 < avcStream.length; i += length) {\n    length = avcView.getUint32(i);\n    i += 4; // bail if this doesn't appear to be an H264 stream\n\n    if (length <= 0) {\n      result.push('<span style=\\'color:red;\\'>MALFORMED DATA</span>');\n      continue;\n    }\n\n    switch (avcStream[i] & 0x1F) {\n      case 0x01:\n        result.push('slice_layer_without_partitioning_rbsp');\n        break;\n\n      case 0x05:\n        result.push('slice_layer_without_partitioning_rbsp_idr');\n        break;\n\n      case 0x06:\n        result.push('sei_rbsp');\n        break;\n\n      case 0x07:\n        result.push('seq_parameter_set_rbsp');\n        break;\n\n      case 0x08:\n        result.push('pic_parameter_set_rbsp');\n        break;\n\n      case 0x09:\n        result.push('access_unit_delimiter_rbsp');\n        break;\n\n      default:\n        result.push('UNKNOWN NAL - ' + avcStream[i] & 0x1F);\n        break;\n    }\n  }\n\n  return result;\n},\n    // registry of handlers for individual mp4 box types\nparse = {\n  // codingname, not a first-class box type. stsd entries share the\n  // same format as real boxes so the parsing infrastructure can be\n  // shared\n  avc1: function avc1(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    return {\n      dataReferenceIndex: view.getUint16(6),\n      width: view.getUint16(24),\n      height: view.getUint16(26),\n      horizresolution: view.getUint16(28) + view.getUint16(30) / 16,\n      vertresolution: view.getUint16(32) + view.getUint16(34) / 16,\n      frameCount: view.getUint16(40),\n      depth: view.getUint16(74),\n      config: inspectMp4(data.subarray(78, data.byteLength))\n    };\n  },\n  avcC: function avcC(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      configurationVersion: data[0],\n      avcProfileIndication: data[1],\n      profileCompatibility: data[2],\n      avcLevelIndication: data[3],\n      lengthSizeMinusOne: data[4] & 0x03,\n      sps: [],\n      pps: []\n    },\n        numOfSequenceParameterSets = data[5] & 0x1f,\n        numOfPictureParameterSets,\n        nalSize,\n        offset,\n        i; // iterate past any SPSs\n\n    offset = 6;\n\n    for (i = 0; i < numOfSequenceParameterSets; i++) {\n      nalSize = view.getUint16(offset);\n      offset += 2;\n      result.sps.push(new Uint8Array(data.subarray(offset, offset + nalSize)));\n      offset += nalSize;\n    } // iterate past any PPSs\n\n\n    numOfPictureParameterSets = data[offset];\n    offset++;\n\n    for (i = 0; i < numOfPictureParameterSets; i++) {\n      nalSize = view.getUint16(offset);\n      offset += 2;\n      result.pps.push(new Uint8Array(data.subarray(offset, offset + nalSize)));\n      offset += nalSize;\n    }\n\n    return result;\n  },\n  btrt: function btrt(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    return {\n      bufferSizeDB: view.getUint32(0),\n      maxBitrate: view.getUint32(4),\n      avgBitrate: view.getUint32(8)\n    };\n  },\n  edts: function edts(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  elst: function elst(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: view.getUint8(0),\n      flags: new Uint8Array(data.subarray(1, 4)),\n      edits: []\n    },\n        entryCount = view.getUint32(4),\n        i;\n\n    for (i = 8; entryCount; entryCount--) {\n      if (result.version === 0) {\n        result.edits.push({\n          segmentDuration: view.getUint32(i),\n          mediaTime: view.getInt32(i + 4),\n          mediaRate: view.getUint16(i + 8) + view.getUint16(i + 10) / (256 * 256)\n        });\n        i += 12;\n      } else {\n        result.edits.push({\n          segmentDuration: view.getUint32(i) * MAX_UINT32 + view.getUint32(i + 4),\n          mediaTime: view.getUint32(i + 8) * MAX_UINT32 + view.getUint32(i + 12),\n          mediaRate: view.getUint16(i + 16) + view.getUint16(i + 18) / (256 * 256)\n        });\n        i += 20;\n      }\n    }\n\n    return result;\n  },\n  esds: function esds(data) {\n    return {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      esId: data[6] << 8 | data[7],\n      streamPriority: data[8] & 0x1f,\n      decoderConfig: {\n        objectProfileIndication: data[11],\n        streamType: data[12] >>> 2 & 0x3f,\n        bufferSize: data[13] << 16 | data[14] << 8 | data[15],\n        maxBitrate: data[16] << 24 | data[17] << 16 | data[18] << 8 | data[19],\n        avgBitrate: data[20] << 24 | data[21] << 16 | data[22] << 8 | data[23],\n        decoderConfigDescriptor: {\n          tag: data[24],\n          length: data[25],\n          audioObjectType: data[26] >>> 3 & 0x1f,\n          samplingFrequencyIndex: (data[26] & 0x07) << 1 | data[27] >>> 7 & 0x01,\n          channelConfiguration: data[27] >>> 3 & 0x0f\n        }\n      }\n    };\n  },\n  ftyp: function ftyp(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      majorBrand: parseType(data.subarray(0, 4)),\n      minorVersion: view.getUint32(4),\n      compatibleBrands: []\n    },\n        i = 8;\n\n    while (i < data.byteLength) {\n      result.compatibleBrands.push(parseType(data.subarray(i, i + 4)));\n      i += 4;\n    }\n\n    return result;\n  },\n  dinf: function dinf(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  dref: function dref(data) {\n    return {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      dataReferences: inspectMp4(data.subarray(8))\n    };\n  },\n  hdlr: function hdlr(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: view.getUint8(0),\n      flags: new Uint8Array(data.subarray(1, 4)),\n      handlerType: parseType(data.subarray(8, 12)),\n      name: ''\n    },\n        i = 8; // parse out the name field\n\n    for (i = 24; i < data.byteLength; i++) {\n      if (data[i] === 0x00) {\n        // the name field is null-terminated\n        i++;\n        break;\n      }\n\n      result.name += String.fromCharCode(data[i]);\n    } // decode UTF-8 to javascript's internal representation\n    // see http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\n\n\n    result.name = decodeURIComponent(escape(result.name));\n    return result;\n  },\n  mdat: function mdat(data) {\n    return {\n      byteLength: data.byteLength,\n      nals: nalParse(data)\n    };\n  },\n  mdhd: function mdhd(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        i = 4,\n        language,\n        result = {\n      version: view.getUint8(0),\n      flags: new Uint8Array(data.subarray(1, 4)),\n      language: ''\n    };\n\n    if (result.version === 1) {\n      i += 4;\n      result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n      i += 8;\n      result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n      i += 4;\n      result.timescale = view.getUint32(i);\n      i += 8;\n      result.duration = view.getUint32(i); // truncating top 4 bytes\n    } else {\n      result.creationTime = parseMp4Date(view.getUint32(i));\n      i += 4;\n      result.modificationTime = parseMp4Date(view.getUint32(i));\n      i += 4;\n      result.timescale = view.getUint32(i);\n      i += 4;\n      result.duration = view.getUint32(i);\n    }\n\n    i += 4; // language is stored as an ISO-639-2/T code in an array of three 5-bit fields\n    // each field is the packed difference between its ASCII value and 0x60\n\n    language = view.getUint16(i);\n    result.language += String.fromCharCode((language >> 10) + 0x60);\n    result.language += String.fromCharCode(((language & 0x03e0) >> 5) + 0x60);\n    result.language += String.fromCharCode((language & 0x1f) + 0x60);\n    return result;\n  },\n  mdia: function mdia(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  mfhd: function mfhd(data) {\n    return {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      sequenceNumber: data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]\n    };\n  },\n  minf: function minf(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  // codingname, not a first-class box type. stsd entries share the\n  // same format as real boxes so the parsing infrastructure can be\n  // shared\n  mp4a: function mp4a(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      // 6 bytes reserved\n      dataReferenceIndex: view.getUint16(6),\n      // 4 + 4 bytes reserved\n      channelcount: view.getUint16(16),\n      samplesize: view.getUint16(18),\n      // 2 bytes pre_defined\n      // 2 bytes reserved\n      samplerate: view.getUint16(24) + view.getUint16(26) / 65536\n    }; // if there are more bytes to process, assume this is an ISO/IEC\n    // 14496-14 MP4AudioSampleEntry and parse the ESDBox\n\n    if (data.byteLength > 28) {\n      result.streamDescriptor = inspectMp4(data.subarray(28))[0];\n    }\n\n    return result;\n  },\n  moof: function moof(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  moov: function moov(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  mvex: function mvex(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  mvhd: function mvhd(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        i = 4,\n        result = {\n      version: view.getUint8(0),\n      flags: new Uint8Array(data.subarray(1, 4))\n    };\n\n    if (result.version === 1) {\n      i += 4;\n      result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n      i += 8;\n      result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n      i += 4;\n      result.timescale = view.getUint32(i);\n      i += 8;\n      result.duration = view.getUint32(i); // truncating top 4 bytes\n    } else {\n      result.creationTime = parseMp4Date(view.getUint32(i));\n      i += 4;\n      result.modificationTime = parseMp4Date(view.getUint32(i));\n      i += 4;\n      result.timescale = view.getUint32(i);\n      i += 4;\n      result.duration = view.getUint32(i);\n    }\n\n    i += 4; // convert fixed-point, base 16 back to a number\n\n    result.rate = view.getUint16(i) + view.getUint16(i + 2) / 16;\n    i += 4;\n    result.volume = view.getUint8(i) + view.getUint8(i + 1) / 8;\n    i += 2;\n    i += 2;\n    i += 2 * 4;\n    result.matrix = new Uint32Array(data.subarray(i, i + 9 * 4));\n    i += 9 * 4;\n    i += 6 * 4;\n    result.nextTrackId = view.getUint32(i);\n    return result;\n  },\n  pdin: function pdin(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    return {\n      version: view.getUint8(0),\n      flags: new Uint8Array(data.subarray(1, 4)),\n      rate: view.getUint32(4),\n      initialDelay: view.getUint32(8)\n    };\n  },\n  sdtp: function sdtp(data) {\n    var result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      samples: []\n    },\n        i;\n\n    for (i = 4; i < data.byteLength; i++) {\n      result.samples.push({\n        dependsOn: (data[i] & 0x30) >> 4,\n        isDependedOn: (data[i] & 0x0c) >> 2,\n        hasRedundancy: data[i] & 0x03\n      });\n    }\n\n    return result;\n  },\n  sidx: require('./parse-sidx.js'),\n  smhd: function smhd(data) {\n    return {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      balance: data[4] + data[5] / 256\n    };\n  },\n  stbl: function stbl(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  ctts: function ctts(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: view.getUint8(0),\n      flags: new Uint8Array(data.subarray(1, 4)),\n      compositionOffsets: []\n    },\n        entryCount = view.getUint32(4),\n        i;\n\n    for (i = 8; entryCount; i += 8, entryCount--) {\n      result.compositionOffsets.push({\n        sampleCount: view.getUint32(i),\n        sampleOffset: view[result.version === 0 ? 'getUint32' : 'getInt32'](i + 4)\n      });\n    }\n\n    return result;\n  },\n  stss: function stss(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: view.getUint8(0),\n      flags: new Uint8Array(data.subarray(1, 4)),\n      syncSamples: []\n    },\n        entryCount = view.getUint32(4),\n        i;\n\n    for (i = 8; entryCount; i += 4, entryCount--) {\n      result.syncSamples.push(view.getUint32(i));\n    }\n\n    return result;\n  },\n  stco: function stco(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      chunkOffsets: []\n    },\n        entryCount = view.getUint32(4),\n        i;\n\n    for (i = 8; entryCount; i += 4, entryCount--) {\n      result.chunkOffsets.push(view.getUint32(i));\n    }\n\n    return result;\n  },\n  stsc: function stsc(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        entryCount = view.getUint32(4),\n        result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      sampleToChunks: []\n    },\n        i;\n\n    for (i = 8; entryCount; i += 12, entryCount--) {\n      result.sampleToChunks.push({\n        firstChunk: view.getUint32(i),\n        samplesPerChunk: view.getUint32(i + 4),\n        sampleDescriptionIndex: view.getUint32(i + 8)\n      });\n    }\n\n    return result;\n  },\n  stsd: function stsd(data) {\n    return {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      sampleDescriptions: inspectMp4(data.subarray(8))\n    };\n  },\n  stsz: function stsz(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      sampleSize: view.getUint32(4),\n      entries: []\n    },\n        i;\n\n    for (i = 12; i < data.byteLength; i += 4) {\n      result.entries.push(view.getUint32(i));\n    }\n\n    return result;\n  },\n  stts: function stts(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      timeToSamples: []\n    },\n        entryCount = view.getUint32(4),\n        i;\n\n    for (i = 8; entryCount; i += 8, entryCount--) {\n      result.timeToSamples.push({\n        sampleCount: view.getUint32(i),\n        sampleDelta: view.getUint32(i + 4)\n      });\n    }\n\n    return result;\n  },\n  styp: function styp(data) {\n    return parse.ftyp(data);\n  },\n  tfdt: require('./parse-tfdt.js'),\n  tfhd: require('./parse-tfhd.js'),\n  tkhd: function tkhd(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        i = 4,\n        result = {\n      version: view.getUint8(0),\n      flags: new Uint8Array(data.subarray(1, 4))\n    };\n\n    if (result.version === 1) {\n      i += 4;\n      result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n      i += 8;\n      result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n      i += 4;\n      result.trackId = view.getUint32(i);\n      i += 4;\n      i += 8;\n      result.duration = view.getUint32(i); // truncating top 4 bytes\n    } else {\n      result.creationTime = parseMp4Date(view.getUint32(i));\n      i += 4;\n      result.modificationTime = parseMp4Date(view.getUint32(i));\n      i += 4;\n      result.trackId = view.getUint32(i);\n      i += 4;\n      i += 4;\n      result.duration = view.getUint32(i);\n    }\n\n    i += 4;\n    i += 2 * 4;\n    result.layer = view.getUint16(i);\n    i += 2;\n    result.alternateGroup = view.getUint16(i);\n    i += 2; // convert fixed-point, base 16 back to a number\n\n    result.volume = view.getUint8(i) + view.getUint8(i + 1) / 8;\n    i += 2;\n    i += 2;\n    result.matrix = new Uint32Array(data.subarray(i, i + 9 * 4));\n    i += 9 * 4;\n    result.width = view.getUint16(i) + view.getUint16(i + 2) / 65536;\n    i += 4;\n    result.height = view.getUint16(i) + view.getUint16(i + 2) / 65536;\n    return result;\n  },\n  traf: function traf(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  trak: function trak(data) {\n    return {\n      boxes: inspectMp4(data)\n    };\n  },\n  trex: function trex(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    return {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      trackId: view.getUint32(4),\n      defaultSampleDescriptionIndex: view.getUint32(8),\n      defaultSampleDuration: view.getUint32(12),\n      defaultSampleSize: view.getUint32(16),\n      sampleDependsOn: data[20] & 0x03,\n      sampleIsDependedOn: (data[21] & 0xc0) >> 6,\n      sampleHasRedundancy: (data[21] & 0x30) >> 4,\n      samplePaddingValue: (data[21] & 0x0e) >> 1,\n      sampleIsDifferenceSample: !!(data[21] & 0x01),\n      sampleDegradationPriority: view.getUint16(22)\n    };\n  },\n  trun: require('./parse-trun.js'),\n  'url ': function url(data) {\n    return {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4))\n    };\n  },\n  vmhd: function vmhd(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    return {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      graphicsmode: view.getUint16(4),\n      opcolor: new Uint16Array([view.getUint16(6), view.getUint16(8), view.getUint16(10)])\n    };\n  }\n};\n/**\n * Return a javascript array of box objects parsed from an ISO base\n * media file.\n * @param data {Uint8Array} the binary data of the media to be inspected\n * @return {array} a javascript array of potentially nested box objects\n */\n\n\ninspectMp4 = function inspectMp4(data) {\n  var i = 0,\n      result = [],\n      view,\n      size,\n      type,\n      end,\n      box; // Convert data from Uint8Array to ArrayBuffer, to follow Dataview API\n\n  var ab = new ArrayBuffer(data.length);\n  var v = new Uint8Array(ab);\n\n  for (var z = 0; z < data.length; ++z) {\n    v[z] = data[z];\n  }\n\n  view = new DataView(ab);\n\n  while (i < data.byteLength) {\n    // parse box data\n    size = view.getUint32(i);\n    type = parseType(data.subarray(i + 4, i + 8));\n    end = size > 1 ? i + size : data.byteLength; // parse type-specific data\n\n    box = (parse[type] || function (data) {\n      return {\n        data: data\n      };\n    })(data.subarray(i + 8, end));\n\n    box.size = size;\n    box.type = type; // store this box and move to the next\n\n    result.push(box);\n    i = end;\n  }\n\n  return result;\n};\n/**\n * Returns a textual representation of the javascript represtentation\n * of an MP4 file. You can use it as an alternative to\n * JSON.stringify() to compare inspected MP4s.\n * @param inspectedMp4 {array} the parsed array of boxes in an MP4\n * file\n * @param depth {number} (optional) the number of ancestor boxes of\n * the elements of inspectedMp4. Assumed to be zero if unspecified.\n * @return {string} a text representation of the parsed MP4\n */\n\n\n_textifyMp = function textifyMp4(inspectedMp4, depth) {\n  var indent;\n  depth = depth || 0;\n  indent = new Array(depth * 2 + 1).join(' '); // iterate over all the boxes\n\n  return inspectedMp4.map(function (box, index) {\n    // list the box type first at the current indentation level\n    return indent + box.type + '\\n' + // the type is already included and handle child boxes separately\n    Object.keys(box).filter(function (key) {\n      return key !== 'type' && key !== 'boxes'; // output all the box properties\n    }).map(function (key) {\n      var prefix = indent + '  ' + key + ': ',\n          value = box[key]; // print out raw bytes as hexademical\n\n      if (value instanceof Uint8Array || value instanceof Uint32Array) {\n        var bytes = Array.prototype.slice.call(new Uint8Array(value.buffer, value.byteOffset, value.byteLength)).map(function (byte) {\n          return ' ' + ('00' + byte.toString(16)).slice(-2);\n        }).join('').match(/.{1,24}/g);\n\n        if (!bytes) {\n          return prefix + '<>';\n        }\n\n        if (bytes.length === 1) {\n          return prefix + '<' + bytes.join('').slice(1) + '>';\n        }\n\n        return prefix + '<\\n' + bytes.map(function (line) {\n          return indent + '  ' + line;\n        }).join('\\n') + '\\n' + indent + '  >';\n      } // stringify generic objects\n\n\n      return prefix + JSON.stringify(value, null, 2).split('\\n').map(function (line, index) {\n        if (index === 0) {\n          return line;\n        }\n\n        return indent + '  ' + line;\n      }).join('\\n');\n    }).join('\\n') + ( // recursively textify the child boxes\n    box.boxes ? '\\n' + _textifyMp(box.boxes, depth + 1) : '');\n  }).join('\\n');\n};\n\nmodule.exports = {\n  inspect: inspectMp4,\n  textify: _textifyMp,\n  parseType: parseType,\n  findBox: findBox,\n  parseTraf: parse.traf,\n  parseTfdt: parse.tfdt,\n  parseHdlr: parse.hdlr,\n  parseTfhd: parse.tfhd,\n  parseTrun: parse.trun,\n  parseSidx: parse.sidx\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nvar tagTypes = {\n  0x08: 'audio',\n  0x09: 'video',\n  0x12: 'metadata'\n},\n    hex = function hex(val) {\n  return '0x' + ('00' + val.toString(16)).slice(-2).toUpperCase();\n},\n    hexStringList = function hexStringList(data) {\n  var arr = [],\n      i;\n\n  while (data.byteLength > 0) {\n    i = 0;\n    arr.push(hex(data[i++]));\n    data = data.subarray(i);\n  }\n\n  return arr.join(' ');\n},\n    parseAVCTag = function parseAVCTag(tag, obj) {\n  var avcPacketTypes = ['AVC Sequence Header', 'AVC NALU', 'AVC End-of-Sequence'],\n      compositionTime = tag[1] & parseInt('01111111', 2) << 16 | tag[2] << 8 | tag[3];\n  obj = obj || {};\n  obj.avcPacketType = avcPacketTypes[tag[0]];\n  obj.CompositionTime = tag[1] & parseInt('10000000', 2) ? -compositionTime : compositionTime;\n\n  if (tag[0] === 1) {\n    obj.nalUnitTypeRaw = hexStringList(tag.subarray(4, 100));\n  } else {\n    obj.data = hexStringList(tag.subarray(4));\n  }\n\n  return obj;\n},\n    parseVideoTag = function parseVideoTag(tag, obj) {\n  var frameTypes = ['Unknown', 'Keyframe (for AVC, a seekable frame)', 'Inter frame (for AVC, a nonseekable frame)', 'Disposable inter frame (H.263 only)', 'Generated keyframe (reserved for server use only)', 'Video info/command frame'],\n      codecID = tag[0] & parseInt('00001111', 2);\n  obj = obj || {};\n  obj.frameType = frameTypes[(tag[0] & parseInt('11110000', 2)) >>> 4];\n  obj.codecID = codecID;\n\n  if (codecID === 7) {\n    return parseAVCTag(tag.subarray(1), obj);\n  }\n\n  return obj;\n},\n    parseAACTag = function parseAACTag(tag, obj) {\n  var packetTypes = ['AAC Sequence Header', 'AAC Raw'];\n  obj = obj || {};\n  obj.aacPacketType = packetTypes[tag[0]];\n  obj.data = hexStringList(tag.subarray(1));\n  return obj;\n},\n    parseAudioTag = function parseAudioTag(tag, obj) {\n  var formatTable = ['Linear PCM, platform endian', 'ADPCM', 'MP3', 'Linear PCM, little endian', 'Nellymoser 16-kHz mono', 'Nellymoser 8-kHz mono', 'Nellymoser', 'G.711 A-law logarithmic PCM', 'G.711 mu-law logarithmic PCM', 'reserved', 'AAC', 'Speex', 'MP3 8-Khz', 'Device-specific sound'],\n      samplingRateTable = ['5.5-kHz', '11-kHz', '22-kHz', '44-kHz'],\n      soundFormat = (tag[0] & parseInt('11110000', 2)) >>> 4;\n  obj = obj || {};\n  obj.soundFormat = formatTable[soundFormat];\n  obj.soundRate = samplingRateTable[(tag[0] & parseInt('00001100', 2)) >>> 2];\n  obj.soundSize = (tag[0] & parseInt('00000010', 2)) >>> 1 ? '16-bit' : '8-bit';\n  obj.soundType = tag[0] & parseInt('00000001', 2) ? 'Stereo' : 'Mono';\n\n  if (soundFormat === 10) {\n    return parseAACTag(tag.subarray(1), obj);\n  }\n\n  return obj;\n},\n    parseGenericTag = function parseGenericTag(tag) {\n  return {\n    tagType: tagTypes[tag[0]],\n    dataSize: tag[1] << 16 | tag[2] << 8 | tag[3],\n    timestamp: tag[7] << 24 | tag[4] << 16 | tag[5] << 8 | tag[6],\n    streamID: tag[8] << 16 | tag[9] << 8 | tag[10]\n  };\n},\n    inspectFlvTag = function inspectFlvTag(tag) {\n  var header = parseGenericTag(tag);\n\n  switch (tag[0]) {\n    case 0x08:\n      parseAudioTag(tag.subarray(11), header);\n      break;\n\n    case 0x09:\n      parseVideoTag(tag.subarray(11), header);\n      break;\n\n    case 0x12:\n  }\n\n  return header;\n},\n    inspectFlv = function inspectFlv(bytes) {\n  var i = 9,\n      // header\n  dataSize,\n      parsedResults = [],\n      tag; // traverse the tags\n\n  i += 4; // skip previous tag size\n\n  while (i < bytes.byteLength) {\n    dataSize = bytes[i + 1] << 16;\n    dataSize |= bytes[i + 2] << 8;\n    dataSize |= bytes[i + 3];\n    dataSize += 11;\n    tag = bytes.subarray(i, i + dataSize);\n    parsedResults.push(inspectFlvTag(tag));\n    i += dataSize + 4;\n  }\n\n  return parsedResults;\n},\n    textifyFlv = function textifyFlv(flvTagArray) {\n  return JSON.stringify(flvTagArray, null, 2);\n};\n\nmodule.exports = {\n  inspectTag: inspectFlvTag,\n  inspect: inspectFlv,\n  textify: textifyFlv\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Utilities to detect basic properties and metadata about TS Segments.\n */\n'use strict';\n\nvar StreamTypes = require('./stream-types.js');\n\nvar parsePid = function parsePid(packet) {\n  var pid = packet[1] & 0x1f;\n  pid <<= 8;\n  pid |= packet[2];\n  return pid;\n};\n\nvar parsePayloadUnitStartIndicator = function parsePayloadUnitStartIndicator(packet) {\n  return !!(packet[1] & 0x40);\n};\n\nvar parseAdaptionField = function parseAdaptionField(packet) {\n  var offset = 0; // if an adaption field is present, its length is specified by the\n  // fifth byte of the TS packet header. The adaptation field is\n  // used to add stuffing to PES packets that don't fill a complete\n  // TS packet, and to specify some forms of timing and control data\n  // that we do not currently use.\n\n  if ((packet[3] & 0x30) >>> 4 > 0x01) {\n    offset += packet[4] + 1;\n  }\n\n  return offset;\n};\n\nvar parseType = function parseType(packet, pmtPid) {\n  var pid = parsePid(packet);\n\n  if (pid === 0) {\n    return 'pat';\n  } else if (pid === pmtPid) {\n    return 'pmt';\n  } else if (pmtPid) {\n    return 'pes';\n  }\n\n  return null;\n};\n\nvar parsePat = function parsePat(packet) {\n  var pusi = parsePayloadUnitStartIndicator(packet);\n  var offset = 4 + parseAdaptionField(packet);\n\n  if (pusi) {\n    offset += packet[offset] + 1;\n  }\n\n  return (packet[offset + 10] & 0x1f) << 8 | packet[offset + 11];\n};\n\nvar parsePmt = function parsePmt(packet) {\n  var programMapTable = {};\n  var pusi = parsePayloadUnitStartIndicator(packet);\n  var payloadOffset = 4 + parseAdaptionField(packet);\n\n  if (pusi) {\n    payloadOffset += packet[payloadOffset] + 1;\n  } // PMTs can be sent ahead of the time when they should actually\n  // take effect. We don't believe this should ever be the case\n  // for HLS but we'll ignore \"forward\" PMT declarations if we see\n  // them. Future PMT declarations have the current_next_indicator\n  // set to zero.\n\n\n  if (!(packet[payloadOffset + 5] & 0x01)) {\n    return;\n  }\n\n  var sectionLength, tableEnd, programInfoLength; // the mapping table ends at the end of the current section\n\n  sectionLength = (packet[payloadOffset + 1] & 0x0f) << 8 | packet[payloadOffset + 2];\n  tableEnd = 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\n  // long the program info descriptors are\n\n  programInfoLength = (packet[payloadOffset + 10] & 0x0f) << 8 | packet[payloadOffset + 11]; // advance the offset to the first entry in the mapping table\n\n  var offset = 12 + programInfoLength;\n\n  while (offset < tableEnd) {\n    var i = payloadOffset + offset; // add an entry that maps the elementary_pid to the stream_type\n\n    programMapTable[(packet[i + 1] & 0x1F) << 8 | packet[i + 2]] = packet[i]; // move to the next table entry\n    // skip past the elementary stream descriptors, if present\n\n    offset += ((packet[i + 3] & 0x0F) << 8 | packet[i + 4]) + 5;\n  }\n\n  return programMapTable;\n};\n\nvar parsePesType = function parsePesType(packet, programMapTable) {\n  var pid = parsePid(packet);\n  var type = programMapTable[pid];\n\n  switch (type) {\n    case StreamTypes.H264_STREAM_TYPE:\n      return 'video';\n\n    case StreamTypes.ADTS_STREAM_TYPE:\n      return 'audio';\n\n    case StreamTypes.METADATA_STREAM_TYPE:\n      return 'timed-metadata';\n\n    default:\n      return null;\n  }\n};\n\nvar parsePesTime = function parsePesTime(packet) {\n  var pusi = parsePayloadUnitStartIndicator(packet);\n\n  if (!pusi) {\n    return null;\n  }\n\n  var offset = 4 + parseAdaptionField(packet);\n\n  if (offset >= packet.byteLength) {\n    // From the H 222.0 MPEG-TS spec\n    // \"For transport stream packets carrying PES packets, stuffing is needed when there\n    //  is insufficient PES packet data to completely fill the transport stream packet\n    //  payload bytes. Stuffing is accomplished by defining an adaptation field longer than\n    //  the sum of the lengths of the data elements in it, so that the payload bytes\n    //  remaining after the adaptation field exactly accommodates the available PES packet\n    //  data.\"\n    //\n    // If the offset is >= the length of the packet, then the packet contains no data\n    // and instead is just adaption field stuffing bytes\n    return null;\n  }\n\n  var pes = null;\n  var ptsDtsFlags; // PES packets may be annotated with a PTS value, or a PTS value\n  // and a DTS value. Determine what combination of values is\n  // available to work with.\n\n  ptsDtsFlags = packet[offset + 7]; // PTS and DTS are normally stored as a 33-bit number.  Javascript\n  // performs all bitwise operations on 32-bit integers but javascript\n  // supports a much greater range (52-bits) of integer using standard\n  // mathematical operations.\n  // We construct a 31-bit value using bitwise operators over the 31\n  // most significant bits and then multiply by 4 (equal to a left-shift\n  // of 2) before we add the final 2 least significant bits of the\n  // timestamp (equal to an OR.)\n\n  if (ptsDtsFlags & 0xC0) {\n    pes = {}; // the PTS and DTS are not written out directly. For information\n    // on how they are encoded, see\n    // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n\n    pes.pts = (packet[offset + 9] & 0x0E) << 27 | (packet[offset + 10] & 0xFF) << 20 | (packet[offset + 11] & 0xFE) << 12 | (packet[offset + 12] & 0xFF) << 5 | (packet[offset + 13] & 0xFE) >>> 3;\n    pes.pts *= 4; // Left shift by 2\n\n    pes.pts += (packet[offset + 13] & 0x06) >>> 1; // OR by the two LSBs\n\n    pes.dts = pes.pts;\n\n    if (ptsDtsFlags & 0x40) {\n      pes.dts = (packet[offset + 14] & 0x0E) << 27 | (packet[offset + 15] & 0xFF) << 20 | (packet[offset + 16] & 0xFE) << 12 | (packet[offset + 17] & 0xFF) << 5 | (packet[offset + 18] & 0xFE) >>> 3;\n      pes.dts *= 4; // Left shift by 2\n\n      pes.dts += (packet[offset + 18] & 0x06) >>> 1; // OR by the two LSBs\n    }\n  }\n\n  return pes;\n};\n\nvar parseNalUnitType = function parseNalUnitType(type) {\n  switch (type) {\n    case 0x05:\n      return 'slice_layer_without_partitioning_rbsp_idr';\n\n    case 0x06:\n      return 'sei_rbsp';\n\n    case 0x07:\n      return 'seq_parameter_set_rbsp';\n\n    case 0x08:\n      return 'pic_parameter_set_rbsp';\n\n    case 0x09:\n      return 'access_unit_delimiter_rbsp';\n\n    default:\n      return null;\n  }\n};\n\nvar videoPacketContainsKeyFrame = function videoPacketContainsKeyFrame(packet) {\n  var offset = 4 + parseAdaptionField(packet);\n  var frameBuffer = packet.subarray(offset);\n  var frameI = 0;\n  var frameSyncPoint = 0;\n  var foundKeyFrame = false;\n  var nalType; // advance the sync point to a NAL start, if necessary\n\n  for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {\n    if (frameBuffer[frameSyncPoint + 2] === 1) {\n      // the sync point is properly aligned\n      frameI = frameSyncPoint + 5;\n      break;\n    }\n  }\n\n  while (frameI < frameBuffer.byteLength) {\n    // look at the current byte to determine if we've hit the end of\n    // a NAL unit boundary\n    switch (frameBuffer[frameI]) {\n      case 0:\n        // skip past non-sync sequences\n        if (frameBuffer[frameI - 1] !== 0) {\n          frameI += 2;\n          break;\n        } else if (frameBuffer[frameI - 2] !== 0) {\n          frameI++;\n          break;\n        }\n\n        if (frameSyncPoint + 3 !== frameI - 2) {\n          nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n\n          if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n            foundKeyFrame = true;\n          }\n        } // drop trailing zeroes\n\n\n        do {\n          frameI++;\n        } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);\n\n        frameSyncPoint = frameI - 2;\n        frameI += 3;\n        break;\n\n      case 1:\n        // skip past non-sync sequences\n        if (frameBuffer[frameI - 1] !== 0 || frameBuffer[frameI - 2] !== 0) {\n          frameI += 3;\n          break;\n        }\n\n        nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n\n        if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n          foundKeyFrame = true;\n        }\n\n        frameSyncPoint = frameI - 2;\n        frameI += 3;\n        break;\n\n      default:\n        // the current byte isn't a one or zero, so it cannot be part\n        // of a sync sequence\n        frameI += 3;\n        break;\n    }\n  }\n\n  frameBuffer = frameBuffer.subarray(frameSyncPoint);\n  frameI -= frameSyncPoint;\n  frameSyncPoint = 0; // parse the final nal\n\n  if (frameBuffer && frameBuffer.byteLength > 3) {\n    nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n\n    if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n      foundKeyFrame = true;\n    }\n  }\n\n  return foundKeyFrame;\n};\n\nmodule.exports = {\n  parseType: parseType,\n  parsePat: parsePat,\n  parsePmt: parsePmt,\n  parsePayloadUnitStartIndicator: parsePayloadUnitStartIndicator,\n  parsePesType: parsePesType,\n  parsePesTime: parsePesTime,\n  videoPacketContainsKeyFrame: videoPacketContainsKeyFrame\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n *\n * Parse mpeg2 transport stream packets to extract basic timing information\n */\n'use strict';\n\nvar StreamTypes = require('../m2ts/stream-types.js');\n\nvar handleRollover = require('../m2ts/timestamp-rollover-stream.js').handleRollover;\n\nvar probe = {};\nprobe.ts = require('../m2ts/probe.js');\nprobe.aac = require('../aac/utils.js');\n\nvar ONE_SECOND_IN_TS = require('../utils/clock').ONE_SECOND_IN_TS;\n\nvar MP2T_PACKET_LENGTH = 188,\n    // bytes\nSYNC_BYTE = 0x47;\n/**\n * walks through segment data looking for pat and pmt packets to parse out\n * program map table information\n */\n\nvar parsePsi_ = function parsePsi_(bytes, pmt) {\n  var startIndex = 0,\n      endIndex = MP2T_PACKET_LENGTH,\n      packet,\n      type;\n\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pat':\n          pmt.pid = probe.ts.parsePat(packet);\n          break;\n\n        case 'pmt':\n          var table = probe.ts.parsePmt(packet);\n          pmt.table = pmt.table || {};\n          Object.keys(table).forEach(function (key) {\n            pmt.table[key] = table[key];\n          });\n          break;\n\n        default:\n          break;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    } // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n\n\n    startIndex++;\n    endIndex++;\n  }\n};\n/**\n * walks through the segment data from the start and end to get timing information\n * for the first and last audio pes packets\n */\n\n\nvar parseAudioPes_ = function parseAudioPes_(bytes, pmt, result) {\n  var startIndex = 0,\n      endIndex = MP2T_PACKET_LENGTH,\n      packet,\n      type,\n      pesType,\n      pusi,\n      parsed;\n  var endLoop = false; // Start walking from start of segment to get first audio packet\n\n  while (endIndex <= bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n          if (pesType === 'audio' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n\n            if (parsed) {\n              parsed.type = 'audio';\n              result.audio.push(parsed);\n              endLoop = true;\n            }\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    } // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n\n\n    startIndex++;\n    endIndex++;\n  } // Start walking from end of segment to get last audio packet\n\n\n  endIndex = bytes.byteLength;\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\n  endLoop = false;\n\n  while (startIndex >= 0) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n          if (pesType === 'audio' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n\n            if (parsed) {\n              parsed.type = 'audio';\n              result.audio.push(parsed);\n              endLoop = true;\n            }\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex -= MP2T_PACKET_LENGTH;\n      endIndex -= MP2T_PACKET_LENGTH;\n      continue;\n    } // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n\n\n    startIndex--;\n    endIndex--;\n  }\n};\n/**\n * walks through the segment data from the start and end to get timing information\n * for the first and last video pes packets as well as timing information for the first\n * key frame.\n */\n\n\nvar parseVideoPes_ = function parseVideoPes_(bytes, pmt, result) {\n  var startIndex = 0,\n      endIndex = MP2T_PACKET_LENGTH,\n      packet,\n      type,\n      pesType,\n      pusi,\n      parsed,\n      frame,\n      i,\n      pes;\n  var endLoop = false;\n  var currentFrame = {\n    data: [],\n    size: 0\n  }; // Start walking from start of segment to get first video packet\n\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n          if (pesType === 'video') {\n            if (pusi && !endLoop) {\n              parsed = probe.ts.parsePesTime(packet);\n\n              if (parsed) {\n                parsed.type = 'video';\n                result.video.push(parsed);\n                endLoop = true;\n              }\n            }\n\n            if (!result.firstKeyFrame) {\n              if (pusi) {\n                if (currentFrame.size !== 0) {\n                  frame = new Uint8Array(currentFrame.size);\n                  i = 0;\n\n                  while (currentFrame.data.length) {\n                    pes = currentFrame.data.shift();\n                    frame.set(pes, i);\n                    i += pes.byteLength;\n                  }\n\n                  if (probe.ts.videoPacketContainsKeyFrame(frame)) {\n                    var firstKeyFrame = probe.ts.parsePesTime(frame); // PTS/DTS may not be available. Simply *not* setting\n                    // the keyframe seems to work fine with HLS playback\n                    // and definitely preferable to a crash with TypeError...\n\n                    if (firstKeyFrame) {\n                      result.firstKeyFrame = firstKeyFrame;\n                      result.firstKeyFrame.type = 'video';\n                    } else {\n                      // eslint-disable-next-line\n                      console.warn('Failed to extract PTS/DTS from PES at first keyframe. ' + 'This could be an unusual TS segment, or else mux.js did not ' + 'parse your TS segment correctly. If you know your TS ' + 'segments do contain PTS/DTS on keyframes please file a bug ' + 'report! You can try ffprobe to double check for yourself.');\n                    }\n                  }\n\n                  currentFrame.size = 0;\n                }\n              }\n\n              currentFrame.data.push(packet);\n              currentFrame.size += packet.byteLength;\n            }\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      if (endLoop && result.firstKeyFrame) {\n        break;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    } // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n\n\n    startIndex++;\n    endIndex++;\n  } // Start walking from end of segment to get last video packet\n\n\n  endIndex = bytes.byteLength;\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\n  endLoop = false;\n\n  while (startIndex >= 0) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n          if (pesType === 'video' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n\n            if (parsed) {\n              parsed.type = 'video';\n              result.video.push(parsed);\n              endLoop = true;\n            }\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex -= MP2T_PACKET_LENGTH;\n      endIndex -= MP2T_PACKET_LENGTH;\n      continue;\n    } // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n\n\n    startIndex--;\n    endIndex--;\n  }\n};\n/**\n * Adjusts the timestamp information for the segment to account for\n * rollover and convert to seconds based on pes packet timescale (90khz clock)\n */\n\n\nvar adjustTimestamp_ = function adjustTimestamp_(segmentInfo, baseTimestamp) {\n  if (segmentInfo.audio && segmentInfo.audio.length) {\n    var audioBaseTimestamp = baseTimestamp;\n\n    if (typeof audioBaseTimestamp === 'undefined' || isNaN(audioBaseTimestamp)) {\n      audioBaseTimestamp = segmentInfo.audio[0].dts;\n    }\n\n    segmentInfo.audio.forEach(function (info) {\n      info.dts = handleRollover(info.dts, audioBaseTimestamp);\n      info.pts = handleRollover(info.pts, audioBaseTimestamp); // time in seconds\n\n      info.dtsTime = info.dts / ONE_SECOND_IN_TS;\n      info.ptsTime = info.pts / ONE_SECOND_IN_TS;\n    });\n  }\n\n  if (segmentInfo.video && segmentInfo.video.length) {\n    var videoBaseTimestamp = baseTimestamp;\n\n    if (typeof videoBaseTimestamp === 'undefined' || isNaN(videoBaseTimestamp)) {\n      videoBaseTimestamp = segmentInfo.video[0].dts;\n    }\n\n    segmentInfo.video.forEach(function (info) {\n      info.dts = handleRollover(info.dts, videoBaseTimestamp);\n      info.pts = handleRollover(info.pts, videoBaseTimestamp); // time in seconds\n\n      info.dtsTime = info.dts / ONE_SECOND_IN_TS;\n      info.ptsTime = info.pts / ONE_SECOND_IN_TS;\n    });\n\n    if (segmentInfo.firstKeyFrame) {\n      var frame = segmentInfo.firstKeyFrame;\n      frame.dts = handleRollover(frame.dts, videoBaseTimestamp);\n      frame.pts = handleRollover(frame.pts, videoBaseTimestamp); // time in seconds\n\n      frame.dtsTime = frame.dts / ONE_SECOND_IN_TS;\n      frame.ptsTime = frame.pts / ONE_SECOND_IN_TS;\n    }\n  }\n};\n/**\n * inspects the aac data stream for start and end time information\n */\n\n\nvar inspectAac_ = function inspectAac_(bytes) {\n  var endLoop = false,\n      audioCount = 0,\n      sampleRate = null,\n      timestamp = null,\n      frameSize = 0,\n      byteIndex = 0,\n      packet;\n\n  while (bytes.length - byteIndex >= 3) {\n    var type = probe.aac.parseType(bytes, byteIndex);\n\n    switch (type) {\n      case 'timed-metadata':\n        // Exit early because we don't have enough to parse\n        // the ID3 tag header\n        if (bytes.length - byteIndex < 10) {\n          endLoop = true;\n          break;\n        }\n\n        frameSize = probe.aac.parseId3TagSize(bytes, byteIndex); // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n\n        if (frameSize > bytes.length) {\n          endLoop = true;\n          break;\n        }\n\n        if (timestamp === null) {\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n          timestamp = probe.aac.parseAacTimestamp(packet);\n        }\n\n        byteIndex += frameSize;\n        break;\n\n      case 'audio':\n        // Exit early because we don't have enough to parse\n        // the ADTS frame header\n        if (bytes.length - byteIndex < 7) {\n          endLoop = true;\n          break;\n        }\n\n        frameSize = probe.aac.parseAdtsSize(bytes, byteIndex); // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n\n        if (frameSize > bytes.length) {\n          endLoop = true;\n          break;\n        }\n\n        if (sampleRate === null) {\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n          sampleRate = probe.aac.parseSampleRate(packet);\n        }\n\n        audioCount++;\n        byteIndex += frameSize;\n        break;\n\n      default:\n        byteIndex++;\n        break;\n    }\n\n    if (endLoop) {\n      return null;\n    }\n  }\n\n  if (sampleRate === null || timestamp === null) {\n    return null;\n  }\n\n  var audioTimescale = ONE_SECOND_IN_TS / sampleRate;\n  var result = {\n    audio: [{\n      type: 'audio',\n      dts: timestamp,\n      pts: timestamp\n    }, {\n      type: 'audio',\n      dts: timestamp + audioCount * 1024 * audioTimescale,\n      pts: timestamp + audioCount * 1024 * audioTimescale\n    }]\n  };\n  return result;\n};\n/**\n * inspects the transport stream segment data for start and end time information\n * of the audio and video tracks (when present) as well as the first key frame's\n * start time.\n */\n\n\nvar inspectTs_ = function inspectTs_(bytes) {\n  var pmt = {\n    pid: null,\n    table: null\n  };\n  var result = {};\n  parsePsi_(bytes, pmt);\n\n  for (var pid in pmt.table) {\n    if (pmt.table.hasOwnProperty(pid)) {\n      var type = pmt.table[pid];\n\n      switch (type) {\n        case StreamTypes.H264_STREAM_TYPE:\n          result.video = [];\n          parseVideoPes_(bytes, pmt, result);\n\n          if (result.video.length === 0) {\n            delete result.video;\n          }\n\n          break;\n\n        case StreamTypes.ADTS_STREAM_TYPE:\n          result.audio = [];\n          parseAudioPes_(bytes, pmt, result);\n\n          if (result.audio.length === 0) {\n            delete result.audio;\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    }\n  }\n\n  return result;\n};\n/**\n * Inspects segment byte data and returns an object with start and end timing information\n *\n * @param {Uint8Array} bytes The segment byte data\n * @param {Number} baseTimestamp Relative reference timestamp used when adjusting frame\n *  timestamps for rollover. This value must be in 90khz clock.\n * @return {Object} Object containing start and end frame timing info of segment.\n */\n\n\nvar inspect = function inspect(bytes, baseTimestamp) {\n  var isAacData = probe.aac.isLikelyAacData(bytes);\n  var result;\n\n  if (isAacData) {\n    result = inspectAac_(bytes);\n  } else {\n    result = inspectTs_(bytes);\n  }\n\n  if (!result || !result.audio && !result.video) {\n    return null;\n  }\n\n  adjustTimestamp_(result, baseTimestamp);\n  return result;\n};\n\nmodule.exports = {\n  inspect: inspect,\n  parseAudioPes_: parseAudioPes_\n};", "/**\n * mux.js\n *\n * Copyright (c) Brightcove\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n */\n'use strict';\n\nvar muxjs = {\n  codecs: require('./codecs'),\n  mp4: require('./mp4'),\n  flv: require('./flv'),\n  mp2t: require('./m2ts'),\n  partial: require('./partial')\n}; // include all the tools when the full library is required\n\nmuxjs.mp4.tools = require('./tools/mp4-inspector');\nmuxjs.flv.tools = require('./tools/flv-inspector');\nmuxjs.mp2t.tools = require('./tools/ts-inspector');\nmodule.exports = muxjs;"],
  "mappings": "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",
  "names": ["Stream", "secondsToVideoTs", "secondsToAudioTs", "videoTsToSeconds", "audioTsToSeconds", "audioTsToVideoTs", "videoTsToAudioTs", "metadataTsToSeconds", "ExpGolomb", "skipScalingList", "discardEmulationPreventionBytes", "readSequenceParameterSet", "box", "dinf", "esds", "ftyp", "hdlr", "mdat", "mdhd", "mdia", "mfhd", "minf", "moof", "moov", "mvex", "mvhd", "sdtp", "stbl", "stsd", "videoSample", "audioSample", "tkhd", "traf", "trak", "trex", "trunHeader", "videoTrun", "audioTrun", "trun", "toUnsigned", "toHexString", "parseType", "findBox", "tfhd", "parseSampleFlags", "trun", "tfdt", "timescale", "result", "startTime", "compositionStartTime", "getVideoTrackIds", "getTimescaleFromMediaHeader", "getTracks", "groupNalsIntoFrames", "groupFramesIntoGops", "extendFirstKeyFrame", "createDefaultSample", "sampleForFrame", "generateSampleTable", "concatenateNalData", "generateSampleTableForFrame", "concatenateNalDataForFrame", "zeroFill", "makeTable", "sumFrameByteLengths", "prefixWithSilence", "trimAdtsFramesByEarliestDts", "generateSampleTable", "concatenateFrameData", "collectDtsInfo", "clearDtsInfo", "calculateTrackBaseMediaDecodeTime", "parseSei", "parseUserData", "parseCaptionPackets", "discardEmulationPreventionBytes", "CaptionStream", "get708CharFromCode", "within708TextBlock", "Cea708Window", "Cea708Service", "Cea708Stream", "getCharFromCode", "createDisplayBuffer", "Cea608Stream", "text", "format", "handleRollover", "TimestampRolloverStream", "percentEncode", "parseUtf8", "parseIso88591", "parseSyncSafeInteger", "i", "parsePsi", "parsePat", "parsePmt", "parsePes", "flushStream", "type", "parseId3TagSize", "getId3Offset", "isLikelyAacData", "parseSyncSafeInteger", "percentEncode", "parseIso88591", "parseAdtsSize", "parseType", "parseSampleRate", "parseAacTimestamp", "retriggerForStream", "addPipelineLogRetriggers", "arrayEquals", "generateSegmentTimingInfo", "gop", "self", "mapToSample", "findSeiNals", "parseSamples", "parseCaptionNals", "parseEmbeddedCaptions", "CaptionParser", "prepareWrite", "i", "CoalesceStream", "TagList", "require_transmuxer", "collectTimelineInfo", "metaDataTag", "extraDataTag", "getFlvHeader", "require_m2ts", "AudioSegmentStream", "VideoSegmentStream", "require_transmuxer", "createPipeline", "tsPipeline", "data", "aacPipeline", "setupPipelineListeners", "Transmuxer", "parseSidx", "parseMp4Date", "nalParse", "inspectMp4", "data", "index", "hex", "hexStringList", "parseAVCTag", "parseVideoTag", "parseAACTag", "parseAudioTag", "parseGenericTag", "inspectFlvTag", "inspectFlv", "textifyFlv", "require_probe", "parsePid", "parsePayloadUnitStartIndicator", "parseAdaptionField", "parseType", "parsePat", "parsePmt", "parsePesType", "parsePesTime", "parseNalUnitType", "videoPacketContainsKeyFrame", "parsePsi_", "parseAudioPes_", "parseVideoPes_", "adjustTimestamp_", "inspectAac_", "inspectTs_", "inspect"]
}
