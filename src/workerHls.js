import { Canvas2DRenderer } from "./canvas2DRenderer.js";
import { TransmuxHlsToMp4 } from "./transmuxHlsToMp4";
import { MP4Demuxer } from "./mp4Demuxer.js";

let decoder = null;
let renderer = null;
let pendingFrame = null;

let texResource = null;
let tsUrls = null;
let isWasmLoaded = false;
let gl = null;
let GL = null;

self.Module = {
  print: (e) => {
    console.log("print", e);
  },
  setStatus: (text) => {
    console.log("setStatus", text);
  },
  totalDependencies: 0,
  monitorRunDependencies: (left) => {
    console.log("monitorRunDependencies", left);
  },
  onRuntimeInitialized: () => {
    console.log("wasm loaded");

    isWasmLoaded = true;

    GL = self.Module.GL;

    start();
  },
};

function renderFrame(frame) {
  if (!pendingFrame) {
    // Schedule rendering in the next animation frame.
    requestAnimationFrame(renderAnimationFrame);
  } else {
    // Close the current pending frame before replacing it.
    pendingFrame.close();
  }
  // Set or replace the pending frame.
  pendingFrame = frame;
}

function renderAnimationFrame() {
  // renderer.draw(pendingFrame);
  updateGLTexture(
    gl,
    texResource,
    gl.RGB,
    pendingFrame.displayWidth,
    pendingFrame.displayHeight,
    false,
    pendingFrame
  );
  pendingFrame.close();
  pendingFrame = null;
}

async function initCanvas(canvas) {
  self.Module.canvas = canvas;
  renderer = new Canvas2DRenderer(canvas);

  gl = renderer.ctx;

  await import("../public/wasm/Uncensored3D.js");
}

async function initDecoder(decoderConfig) {
  decoder = new VideoDecoder({
    output(frame) {
      renderFrame(frame);
    },
    error(e) {
      console.error(e);
    },
  });

  decoder.configure(decoderConfig);
}

function createGLTexture(
  gl,
  format,
  intFormat,
  w,
  h,
  wrapType,
  flip,
  genMipmaps,
  data
) {
  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flip);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapType);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapType);

  if (genMipmaps === true) {
    gl.texParameteri(
      gl.TEXTURE_2D,
      gl.TEXTURE_MIN_FILTER,
      gl.LINEAR_MIPMAP_LINEAR
    );
    gl.texStorage2D(gl.TEXTURE_2D, 1, intFormat, w, h);
  } else {
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texStorage2D(gl.TEXTURE_2D, 1, intFormat, w, h);
  }

  if (data != null) {
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, format, gl.UNSIGNED_BYTE, data);
  }

  if (genMipmaps === true) {
    gl.generateMipmap(gl.TEXTURE_2D);
  }

  return texture;
}

function createAndRegisterGLTex(w, h, format, internalFormat) {
  texResource = createGLTexture(
    gl,
    format,
    internalFormat,
    w,
    h,
    gl.CLAMP_TO_EDGE,
    false,
    false,
    null
  );

  var id = GL.getNewId(GL.textures); // already included in code generated by emscripten
  texResource.name = id;
  GL.textures[id] = texResource;
  var bpp = format == gl.RGB ? 3 : 4;
  self.Module._register_gl_tex_handle(id, w, h, bpp);
}

function updateGLTexture(gl, texture, format, w, h, genMipmaps, data) {
  gl.bindTexture(gl.TEXTURE_2D, texture);

  gl.texSubImage2D(
    gl.TEXTURE_2D,
    0,
    0,
    0,
    w,
    h,
    format,
    gl.UNSIGNED_BYTE,
    data
  );

  if (genMipmaps === true) {
    gl.generateMipmap(gl.TEXTURE_2D);
  }

  gl.bindTexture(gl.TEXTURE_2D, null);
}

function onTsLoaded(_tsUrls) {
  tsUrls = _tsUrls;
  start();
}

function start() {
  if (tsUrls === null || isWasmLoaded === false) {
    return;
  }

  const mp4Demuxer = new MP4Demuxer({
    onConfig: (data) => {
      initDecoder(data);

      createAndRegisterGLTex(
        data.codedWidth,
        data.codedHeight,
        gl.RGB,
        gl.RGB8
      );
    },
    onChunk: (encodedVideoChunk) => {
      decoder.decode(encodedVideoChunk);
    },
  });

  new TransmuxHlsToMp4({
    tsUrls,
    onChunk: (chunk) => {
      mp4Demuxer.write(chunk);
    },
  });
}

self.addEventListener("message", (e) => {
  const { type, ...data } = e.data;

  if (type === "initCanvas") {
    initCanvas(data.canvas);
  } else if (type === "start") {
    onTsLoaded(data.tsUrls);
  }
});
